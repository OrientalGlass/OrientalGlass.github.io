[{"content":"前言 近期学习DEX文件结构为学习APP加壳脱壳打基础,自实现了一个简易的DEX解析器加深理解\nDEX文件结构整体看不复杂,深究时发现DexCLassDef结构非常复杂,编码的数据结构,嵌套和指向关系\n本文作为近期学习的一个阶段总结以及知识分享,后期再完善Todo部分\n由于本人水平有限,文章错漏之处还望大佬批评指正\n环境\u0026amp;工具:\n010editor 15.0.1 (13.0.1有bug,打开大文件分析时容易崩溃)\nClion 2024.2.3\nJDK 11.0.23\nMinGW 14.2.0\nAndroid Studio\n准备 自行编译dex文件供后续分析\n1 2 3 4 5 public class HelloDEX{ public static void main(String[] args){ System.out.println(\u0026#34;Hello Dex!\u0026#34;); } } 1 2 javac HelloDEX.java d8 HelloDEX.class 可能遇到报错如下,这是因为d8需要java11+的环境,不支持java8\n1 2 Error: A JNI error has occurred, please check your installation and try again Exception in thread \u0026#34;main\u0026#34; java.lang.UnsupportedClassVersionError: com/android/tools/r8/D8 has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0 数据类型 Android源码 http://androidxref.com/2.3.7/xref/dalvik/libdex/DexFile.h 定义了dex文件用到的数据结构\n自定义类型 原类型 含义 s1 int8_t 有符号单字节 u1 uint8_t 无符号单字节 s2 int16_t u2 uint16_t s4 int32_t u4 uint32_t s8 int64_t u8 uint64_t sleb128 无 有符号LEB128,可变长度 uleb128 无 无符号LEB128,可变长度 uleb128p1 无 等于ULEB128加1,可变长度 Leb128 sleb128、uleb128、uleb128p1是Dex文件中特有的LEB128类型.在下述Android源码位置可以找到LEB128的实现.http://androidxref.com/2.3.7/xref/dalvik/libdex/Leb128.h\n每个LEB128由1-5字节组成,所有字节组合在一起表示一个32位的数据, 每个字节只有低7位为有效位,最高位标识是否需要使用额外字节\n如果第1个字节的最高位为1,表示LEB128需要使用第2个字节,如果第2个字节的最高位为1,表示会使用第3个字节,依次类推,直到最后一个字节的最高位为0\nuleb128读取代码如下\n值得注意的是参数为二级指针,也就是说,调用该函数时会移动一级指针,一级指针的偏移量即为读取到的uleb128的大小\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int readUnsignedLeb128(const u1** pStream) { const u1* ptr = *pStream; int result = *(ptr++); if (result \u0026gt; 0x7f) { int cur = *(ptr++); result = (result \u0026amp; 0x7f) | ((cur \u0026amp; 0x7f) \u0026lt;\u0026lt; 7); if (cur \u0026gt; 0x7f) { cur = *(ptr++); result |= (cur \u0026amp; 0x7f) \u0026lt;\u0026lt; 14; if (cur \u0026gt; 0x7f) { cur = *(ptr++); result |= (cur \u0026amp; 0x7f) \u0026lt;\u0026lt; 21; if (cur \u0026gt; 0x7f) { /* * Note: We don\u0026#39;t check to see if cur is out of * range here, meaning we tolerate garbage in the * high four-order bits. */ cur = *(ptr++); result |= cur \u0026lt;\u0026lt; 28; } } } } *pStream = ptr; return result; } 为方便使用自定义了myReadUnsignedLeb128函数,参数为一级指针,返回读取的数据及其大小\n1 2 3 4 5 6 7 8 // 传入指针直接读取数据并返回数据和读取的大小(可选) int myReadUnsignedLeb128(const u1* pData,size_t* readSize) { const u1** pStream = \u0026amp;pData; u4 result=readUnsignedLeb128(pStream); if(readSize) *readSize=unsignedLeb128Size(result); return result; } encoded_value 参考Android官方文档https://source.android.com/docs/core/dalvik/dex-format?hl=zh-cn#encoding\n解析代码参考以下文档,只找到了java代码\nhttp://androidxref.com/2.3.7/xref/cts/tools/dex-tools/src/dex/reader/DexEncodedValueImpl.java\nhttp://androidxref.com/2.3.7/xref/dalvik/dx/src/com/android/dx/dex/file/ValueEncoder.java\n解析DexClassDef结构时,Annotation的annotation_element和encoded_array_item会使用该编码\n编码格式如下,1字节的头用于指定value格式和大小,后续紧跟数据,需要根据类型解析\n名称 格式 说明 (value_arg \u0026laquo; 5) | value_type ubyte 高3位为value_arg的值，低5位为value_type的值，value_type指定value的格式。 value ubyte[] 用于表示值的字节，不同 value_type 字节的长度不同且采用不同的解译方式；不过一律采用小端字节序。 value_type枚举定义如下\n类型名称 value_type value_arg value格式 说明 VALUE_BYTE 0x00 （无；必须为 0） ubyte[1] 有符号的单字节整数值 VALUE_SHORT 0x02 size - 1 (0…1) ubyte[size] 有符号的双字节整数值，符号扩展 VALUE_CHAR 0x03 size - 1 (0…1) ubyte[size] 无符号的双字节整数值，零扩展 VALUE_INT 0x04 size - 1 (0…3) ubyte[size] 有符号的四字节整数值，符号扩展 VALUE_LONG 0x06 size - 1 (0…7) ubyte[size] 有符号的八字节整数值，符号扩展 VALUE_FLOAT 0x10 size - 1 (0…3) ubyte[size] 四字节位模式，向右零扩展，系统会将其解译为 IEEE754 32 位浮点值 VALUE_DOUBLE 0x11 size - 1 (0…7) ubyte[size] 八字节位模式，向右零扩展，系统会将其解译为 IEEE754 64 位浮点值 VALUE_METHOD_TYPE 0x15 size - 1 (0…3) ubyte[size] 无符号（零扩展）四字节整数值，会被解译为要编入 proto_ids 区段的索引；表示方法类型值 VALUE_METHOD_HANDLE 0x16 size - 1 (0…3) ubyte[size] 无符号（零扩展）四字节整数值，会被解译为要编入 method_handles 区段的索引；表示方法句柄值 VALUE_STRING 0x17 size - 1 (0…3) ubyte[size] 无符号（零扩展）四字节整数值，会被解译为要编入 string_ids 区段的索引；表示字符串值 VALUE_TYPE 0x18 size - 1 (0…3) ubyte[size] 无符号（零扩展）四字节整数值，会被解译为要编入 type_ids 区段的索引；表示反射类型/类值 VALUE_FIELD 0x19 size - 1 (0…3) ubyte[size] 无符号（零扩展）四字节整数值，会被解译为要编入 field_ids 区段的索引；表示反射字段值 VALUE_METHOD 0x1a size - 1 (0…3) ubyte[size] 无符号（零扩展）四字节整数值，会被解译为要编入 method_ids 区段的索引；表示反射方法值 VALUE_ENUM 0x1b size - 1 (0…3) ubyte[size] 无符号（零扩展）四字节整数值，会被解译为要编入 field_ids 区段的索引；表示枚举类型常量的值 VALUE_ARRAY 0x1c （无；必须为 0） encoded_array 值的数组，采用下文“encoded_array 格式”所指定的格式。value 的大小隐含在编码中。 VALUE_ANNOTATION 0x1d （无；必须为 0） encoded_annotation 子注解，采用下文“encoded_annotation 格式”所指定的格式。value 的大小隐含在编码中。 VALUE_NULL 0x1e （无；必须为 0） （无） null 引用值 VALUE_BOOLEAN 0x1f 布尔值 (0…1) （无） 一位值；0 表示 false，1 表示 true。该位在 value_arg 中表示。 解析代码如下(该函数在解析DexClassDef的Annotation时才会使用,可先忽略)\nparseEncodedValue函数会自动读取单个encoded_value并返回解析后的字符串(类型:值 的键值对形式)以及value占用的真实字节数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 // 读取EncodedValue, 由于大小不固定, 故直接以数组赋值形式取值 void DexFile::getEncodedValue(ubyte* pDest,const ubyte* pValue,int size) { for(int i=0;i\u0026lt;size;i++) { pDest[i]=pValue[i]; } } // 解析EncodedValue, 返回解析后的字符串以及value真实大小 Todo: 完善解析逻辑,剩余3个分支 std::string DexFile::parseEncodedValue(ubyte* pEncodedValue,size_t\u0026amp; valueRealSize) { ubyte valueArg = GetValueArg(pEncodedValue[0]);// arg=size-1,值占用的字节数\u0026lt;=对应类型大小,不含头部的单字节 ubyte valueType = GetValueType(pEncodedValue[0]); // 假如int=0时,占2字节,头1字节,值0占1字节,所以要同时判断arg和type if(valueArg==0) { //arg==0时,要确定是arg固定为0的特殊类型还是其他类型 //特殊类型只有1字节头,其他类型是1字节头+1字节数据 bool isSpecialType=false; switch (valueType) { case VALUE_BYTE: case VALUE_ARRAY: case VALUE_ANNOTATION: case VALUE_NULL: case VALUE_BOOLEAN: isSpecialType=true; break; } if(isSpecialType) valueRealSize=1; else valueRealSize=2; } else valueRealSize=valueArg+2;// 头部1字节+实际大小 size=head+arg+1 int readValueSize=valueArg+1;// 需要读取的字节数 ubyte* pValue=\u0026amp;pEncodedValue[1]; std::string result; unsigned int index=0; switch(valueType) { // 有符号单字节 case VALUE_BYTE: { char byte=0; getEncodedValue((ubyte*)\u0026amp;byte,pValue,readValueSize); result=\u0026#34;byte:\u0026#34;+std::format(\u0026#34;0x{:x}\u0026#34;,byte); break; } // 有符号双字节 case VALUE_SHORT: { short value_short=0; getEncodedValue((ubyte*)\u0026amp;value_short,pValue,readValueSize); result=\u0026#34;short:\u0026#34;+std::format(\u0026#34;0x{:x}\u0026#34;,value_short); break; } // 无符号双字节 case VALUE_CHAR: { unsigned short value_char=0; getEncodedValue((ubyte*)\u0026amp;value_char,pValue,readValueSize); result=\u0026#34;char:\u0026#34;+std::format(\u0026#34;0x{:x}\u0026#34;,value_char); break; } // 有符号4字节 case VALUE_INT: { int value_int=0; getEncodedValue((ubyte*)\u0026amp;value_int,pValue,readValueSize); result=\u0026#34;int:\u0026#34;+std::format(\u0026#34;0x{:x}\u0026#34;,value_int); break; } // 有符号8字节 case VALUE_LONG: { long long value_long=0; getEncodedValue((ubyte*)\u0026amp;value_long,pValue,readValueSize); result=\u0026#34;long:\u0026#34;+std::format(\u0026#34;0x{:x}\u0026#34;,value_long); break; } // 4字节浮点 case VALUE_FLOAT: { float value_float=0; getEncodedValue((ubyte*)\u0026amp;value_float,pValue,readValueSize); result=\u0026#34;float:\u0026#34;+std::format(\u0026#34;{:f}\u0026#34;,value_float); break; } // 8字节浮点 case VALUE_DOUBLE: { double value_double=0; getEncodedValue((ubyte*)\u0026amp;value_double,pValue,readValueSize); result=\u0026#34;double:\u0026#34;+std::format(\u0026#34;{:f}\u0026#34;,value_double); break; } // 无符号4字节索引 指向对应结构 case VALUE_METHOD_TYPE: { // ProtoId getEncodedValue((ubyte*)\u0026amp;index,pValue,readValueSize); result=\u0026#34;MethodType:\u0026#34;+std::format(\u0026#34;0x{:x}\u0026#34;,index)+\u0026#34; \u0026#34;+getProtoIdDataByIndex(index); break; } // todo: 这部分没有定义的成员指向,暂时不知如何解析,参考 https://source.android.com/docs/core/runtime/dex-format?hl=zh-cn#method-handle-item case VALUE_METHOD_HANDLE: { // MethodHandles getEncodedValue((ubyte*)\u0026amp;index,pValue,readValueSize); result=\u0026#34;MethodHandle Index:\u0026#34;+std::format(\u0026#34;0x{:x}\u0026#34;,index); break; } case VALUE_STRING: { // StringId getEncodedValue((ubyte*)\u0026amp;index,pValue,readValueSize); result=\u0026#34;String:\u0026#34;+getStringIdDataByIndex(index); break; } case VALUE_TYPE: { // TypeId getEncodedValue((ubyte*)\u0026amp;index,pValue,readValueSize); result=\u0026#34;Type:\u0026#34;+parseString(getTypeIdDataByIndex(index)); break; } case VALUE_FIELD: { // FieldId getEncodedValue((ubyte*)\u0026amp;index,pValue,readValueSize); result=\u0026#34;Field:\u0026#34;+parseString(getFieldIdDataByIndex(index)); break; } case VALUE_METHOD: { // MethodId getEncodedValue((ubyte*)\u0026amp;index,pValue,readValueSize); result=\u0026#34;Method:\u0026#34;+parseString(getMethodIdDataByIndex(index)); break; } case VALUE_ENUM: { // FieldId getEncodedValue((ubyte*)\u0026amp;index,pValue,readValueSize); result=\u0026#34;Enum:\u0026#34;+parseString(getFieldIdDataByIndex(index)); break; } // todo encoded_array和encoded_annotation结构,不太容易解析 case VALUE_ARRAY: { //getEncodedValue((ubyte*)\u0026amp;index,pValue,readValueSize); // DexEncodedArray encodedArray;//直接解析貌似不正确 // getEncodedValue((ubyte*)\u0026amp;encodedArray,pValue,readValueSize); // printClassDefStaticValues(encodedArray); // int sizeLen=0; // u4 size=myReadUnsignedLeb128(pValue,\u0026amp;sizeLen); // u1* pValues=pValue+sizeLen; // printf(\u0026#34;EncodedArray contains %d values\\n\u0026#34;,size); // unsigned int offset=0;// offset保存前方已访问的结构大小 // for(int i=0;i\u0026lt;size;i++) { // printf(\u0026#34;%s\\n\u0026#34;,parseEncodedValue(pValues+offset,offset).c_str()); // } //system(\u0026#34;pause\u0026#34;); break; } case VALUE_ANNOTATION: result=\u0026#34;Todo......\u0026#34;; break; case VALUE_NULL: result=\u0026#34;null\u0026#34;; break; // boolean的值存在value_arg中 case VALUE_BOOLEAN: result=\u0026#34;bool:\u0026#34;; if(valueArg) result+=\u0026#34;true\u0026#34;; else result+=\u0026#34;false\u0026#34;; break; default: result=\u0026#34;Unknown value type\u0026#34;; } return result; } encoded_array 名称 格式 说明 size uleb128 数组中的元素数量 values encoded_value[size] 采用本部分所指定格式的一系列 size encoded_value 字节序列；依序串联。 由于encoded_array.values数组元素为encoded_value,所以每个元素的大小不固定,不能当作一般的数组解析\nencoded_annotation 该类型主要在DexClassDef的Annotations部分使用,此处仅做介绍\n名称 格式 说明 type_idx uleb128 注释的类型。这种类型必须是“类”（而非“数组”或“基元”）。 size uleb128 此注解中 name-value 映射的数量 elements annotation_element[size] 注解的元素，直接以内嵌形式（不作为偏移量）表示。元素必须按 string_id 索引以升序进行排序。 annotation_element 名称 格式 说明 name_idx uleb128 元素名称，表示为要编入 string_ids 区段的索引。该字符串必须符合上文定义的 MemberName 的语法。 value encoded_value 元素值 Dex整体结构 dex文件整体结构分为: dex文件头, 索引结构区, data数据区, 示意图如下:\ndex文件头\n保存了dex文件的基本信息, 例如文件大小,dex头大小,大小端序,索引表的起始地址和大小等\n索引结构区\n这部分保存了字符串表,类型表,方法原型表,域表,方法表等结构\n根据这些表和索引可以访问到对应数据\ndata数据区\n所有的代码和数据存放在该区域\ndex文件结构体的定义在Android源码目录/dalvik/libdex/DexFile.h中可以找到，其中定义的dex文件结构体如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 struct DexFile { /* directly-mapped \u0026#34;opt\u0026#34; header */ const DexOptHeader* pOptHeader; /* pointers to directly-mapped structs and arrays in base DEX */ const DexHeader* pHeader; const DexStringId* pStringIds; const DexTypeId* pTypeIds; const DexFieldId* pFieldIds; const DexMethodId* pMethodIds; const DexProtoId* pProtoIds; const DexClassDef* pClassDefs; const DexLink* pLinkData; /* * These are mapped out of the \u0026#34;auxillary\u0026#34; section, and may not be * included in the file. */ const DexClassLookup* pClassLookup; const void* pRegisterMapPool; // RegisterMapClassPool /* points to start of DEX file data */ const u1* baseAddr; /* track memory overhead for auxillary structures */ int overhead; /* additional app-specific data structures associated with the DEX */ //void* auxData; }; 为方便使用仅保留部分字段,编写相关函数如下\n通过字节buffer或文件路径创建DexFile类并初始化各个字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class DexFile { u1* baseAddr{nullptr}; DexHeader* pHeader{nullptr}; DexStringId* pStringIds{nullptr}; DexTypeId* pTypeIds{nullptr}; DexFieldId* pFieldIds{nullptr}; DexMethodId* pMethodIds{nullptr}; DexProtoId* pProtoIds{nullptr}; DexClassDef* pClassDefs{nullptr}; void initFields(unsigned char *buffer); } // Init functions void DexFile::initFields(unsigned char* buffer) { if(buffer==nullptr) { printf(\u0026#34;Null pointer provided!\\n\u0026#34;); exit(0); } baseAddr=buffer; pHeader=(DexHeader*)baseAddr; pStringIds=(DexStringId*)(baseAddr+pHeader-\u0026gt;stringIdsOff); pTypeIds=(DexTypeId*)(baseAddr+pHeader-\u0026gt;typeIdsOff); pFieldIds=(DexFieldId*)(baseAddr+pHeader-\u0026gt;fieldIdsOff); pMethodIds=(DexMethodId*)(baseAddr+pHeader-\u0026gt;methodIdsOff); pProtoIds=(DexProtoId*)(baseAddr+pHeader-\u0026gt;protoIdsOff); pClassDefs=(DexClassDef*)(baseAddr+pHeader-\u0026gt;classDefsOff); } DexFile::DexFile(unsigned char *buffer) { initFields(buffer); } DexFile::DexFile(std::string filePath) { size_t fileLength=0; initFields(readFileToBytes(filePath, fileLength)); } DexFile::~DexFile() { delete baseAddr; } Dex Header DexHeader定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 typedef struct DexHeader { u1 magic[8];\t//Dex版本号 dex.035 .035即为版本号 u4 checksum; //adler32检验,如果修改了Dex文件,需要修正这个值,否则会运行不起来 u1 signature[kSHA1DigestLen]; //SHA-1值,Android不检测该值,但如果修改了Dex文件,最好修复该值,再修checksum u4 fileSize; //整个dex文件的大小 u4 headerSize; //DexHeader结构的大小,固定为0x70 u4 endianTag; //字节序标记,若该字段按小端方式读出来为0x12345678,则整个Dex文件就是小端方式.如果按大端方式读出来为0x12345678,那整个Dex文件就是大端方式 u4 linkSize;\t//链接段大小 u4 linkOff;\t//链接段偏移 u4 mapOff;\t//DexMapList文件偏移 u4 stringIdsSize;\t//DexStringId个数 u4 stringIdsOff;\t//DexStringId文件偏移 u4 typeIdsSize;\t//DexTypeId个数 u4 typeIdsOff;\t//DexTypeId文件偏移 u4 protoIdsSize;\t//DexProtoId个数 u4 protoIdsOff;\t//DexProtoId文件偏移 u4 fieldIdsSize;\t//DexFieldId个数 u4 fieldIdsOff;\t//DexFieldId文件偏移 u4 methodIdsSize;\t//DexMethodId个数 u4 methodIdsOff;\t//DexMethodId文件偏移 u4 classDefsSize;\t//DexClassDef个数 u4 classDefsOff;\t//DexClassDef文件偏移 u4 dataSize;\t//数据段大小 u4 dataOff;\t//数据段文件偏移 } DexHeader; 打印DexHeader\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void DexFile::printDexHeader() { printf(\u0026#34;DexHeader:\\n\u0026#34;); printf(\u0026#34;\\tmagic: \u0026#34;);printHexBytes(pHeader-\u0026gt;magic,sizeof(pHeader-\u0026gt;magic));printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;\\tchecksum: %#x\\n\u0026#34;,pHeader-\u0026gt;checksum); printf(\u0026#34;\\tsignature: \u0026#34;);printHexBytes(pHeader-\u0026gt;signature,kSHA1DigestLen);printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;\\tFileSize: %#x\\n\u0026#34;,pHeader-\u0026gt;fileSize); printf(\u0026#34;\\tHeaderSize: %#x\\n\u0026#34;,pHeader-\u0026gt;headerSize); printf(\u0026#34;\\tEndianTag: %#x\\n\u0026#34;,pHeader-\u0026gt;endianTag); printf(\u0026#34;\\tLinkOff: %#x\\n\u0026#34;,pHeader-\u0026gt;linkOff); printf(\u0026#34;\\tLinkSize: %#x\\n\u0026#34;,pHeader-\u0026gt;linkSize); printf(\u0026#34;\\tMapOff: %#x\\n\u0026#34;,pHeader-\u0026gt;mapOff); printf(\u0026#34;\\tStringIDs Offset: %#x\\n\u0026#34;,pHeader-\u0026gt;stringIdsOff); printf(\u0026#34;\\tNum of StringIDs: %#x\\n\u0026#34;,pHeader-\u0026gt;stringIdsSize); printf(\u0026#34;\\tTypeIDs Offset: %#x\\n\u0026#34;,pHeader-\u0026gt;typeIdsOff); printf(\u0026#34;\\tNum of TypeIDs: %#x\\n\u0026#34;,pHeader-\u0026gt;typeIdsSize); printf(\u0026#34;\\tProtoIDs Offset: %#x\\n\u0026#34;,pHeader-\u0026gt;protoIdsOff); printf(\u0026#34;\\tNum of ProtoIDs: %#x\\n\u0026#34;,pHeader-\u0026gt;protoIdsSize); printf(\u0026#34;\\tFieldIDs Offset: %#x\\n\u0026#34;,pHeader-\u0026gt;fieldIdsOff); printf(\u0026#34;\\tNum of FieldIDs: %#x\\n\u0026#34;,pHeader-\u0026gt;fieldIdsSize); printf(\u0026#34;\\tMethodIDs Offset: %#x\\n\u0026#34;,pHeader-\u0026gt;methodIdsOff); printf(\u0026#34;\\tNum of MethodIDs: %#x\\n\u0026#34;,pHeader-\u0026gt;methodIdsSize); printf(\u0026#34;\\tClassDefs Offset: %#x\\n\u0026#34;,pHeader-\u0026gt;classDefsOff); printf(\u0026#34;\\tNum of ClassDefs: %#x\\n\u0026#34;,pHeader-\u0026gt;classDefsSize); printf(\u0026#34;\\tData Offset: %#x\\n\u0026#34;,pHeader-\u0026gt;dataOff); printf(\u0026#34;\\tSize of Data: %#x\\n\u0026#34;,pHeader-\u0026gt;dataSize); printf(\u0026#34;DexHeader End\\n\u0026#34;); } 效果如下\nDex String ID 定义如下\n1 2 3 4 5 6 7 8 9 struct DexStringId { u4 stringDataOff; /* 字符串的文件偏移量 */ }; //伪结构表示如下: struct string_data_item { uleb128 utf16_size; //字符串长度 ubyte[] data; //字符串数据 } 注意dex文件的字符串采用MUTF-8编码,与UTF-8区别如下:\nMUTF-8使用1~3字节编码 大于16位的Unicode编码U+10000~U+10ffff使用3字节编码 U+000采用2字节编码 以0x00空字符作为字符串结尾 MUTF-8字符串头部保存的是字符串长度,是uleb128类型\n相关函数定义如下,解析StringId\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // StringId functions // 通过索引获取对应StringId DexStringId DexFile::getStringIdByIndex(u4 index) { if(checkIndexIsLegal(index,pHeader-\u0026gt;stringIdsSize-1)) { return pStringIds[index]; } printf(\u0026#34;No such index: %x\\n\u0026#34;,index); exit(0); } // 解析StringId 获取字符串长度 size_t DexFile::getStringDataLength(DexStringId\u0026amp; stringId) { const u1* ptr = baseAddr + stringId.stringDataOff; size_t size=0; myReadUnsignedLeb128(ptr,\u0026amp;size); return size; } // 解析StringId 获取字符串 std::string DexFile::getStringIdData(const DexStringId\u0026amp; stringId) { const u1* ptr = baseAddr + stringId.stringDataOff; while (*(ptr++) \u0026gt; 0x7f);// Skip the uleb128 length. return (char*)ptr; } // 通过索引获取StringId的字符串 std::string DexFile::getStringIdDataByIndex(u4 index) { if(checkIndexIsLegal(index,pHeader-\u0026gt;stringIdsSize-1)) { return getStringIdData(pStringIds[index]); } return nullptr; } 打印所有StringId,没有做MUTF编码处理,直接打印ASCII字符串\n1 2 3 4 5 6 7 8 void DexFile::printStringIds() { printf(\u0026#34;StringIds:\\n\u0026#34;); printf(\u0026#34;\\tNums\\t\\tStrings\\n\u0026#34;); for(int i=0;i\u0026lt;pHeader-\u0026gt;stringIdsSize;i++) { printf(\u0026#34;\\t%08x\\t%s\\n\u0026#34;,i,getStringIdDataByIndex(i).c_str()); } printf(\u0026#34;StringIds End\\n\u0026#34;); } 效果如下,没有做编码处理故可能出现乱码\nDex Type ID 定义如下\n1 2 3 typedef struct DexTypeId { u4 descriptorIdx; //指向DexStringId列表的索引 } DexTypeId; descriptorIdx为DexStringID表的索引,对应字符串表示类的类型\n例如此处DexTypeID[3].descriptorIdx=6, 而DexStringID[6]对应的字符串为\u0026quot;Ljava/lang/String;\u0026quot;\n和StringId类似,TypeId的解析代码如下,通过索引获取StringId及其对应的字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // TypeId functions // 通过索引获取对应TypeId DexTypeId DexFile::getTypeIdByIndex(u4 index) { if(checkIndexIsLegal(index,pHeader-\u0026gt;typeIdsSize-1)) { return pTypeIds[index]; } printf(\u0026#34;No such index: %x\\n\u0026#34;,index); exit(0); } // 通过索引获取TypeId对应的字符串 std::string DexFile::getTypeIdDataByIndex(u4 index) { if(checkIndexIsLegal(index,pHeader-\u0026gt;typeIdsSize-1)) { return getStringIdDataByIndex(pTypeIds[index].descriptorIdx); } return nullptr; } 打印所有TypeId\n1 2 3 4 5 6 7 8 void DexFile::printTypeIds() { printf(\u0026#34;TypeIds:\\n\u0026#34;); printf(\u0026#34;\\tNums\\t\\tTypeIds\\n\u0026#34;); for(int i=0;i\u0026lt;pHeader-\u0026gt;typeIdsSize;i++) { printf(\u0026#34;\\t%08x\\t%s\\n\u0026#34;,i,getTypeIdDataByIndex(i).c_str()); } printf(\u0026#34;TypeIds End\\n\u0026#34;); } 效果如下\nDex Proto ID DexProtoId是**方法声明（方法签名）**的结构体,保存方法(函数)的返回值类型和参数类型列表,没有函数名,定义如下\n1 2 3 4 5 typedef struct DexProtoId { u4 shortyIdx; //方法声明字符串,指向DexStringId列表的索引 u4 returnTypeIdx; //方法返回类型字符串,指向DexTypeId列表的索引 u4 parametersOff; //方法的参数列表,指向DexTypeList列表的索引 } DexProtoId; parametersOff是DexTypeList的文件偏移\nDexTypeList 结构定义如下\n1 2 3 4 5 6 7 8 typedef struct DexTypeList { u4 size; //DexTypeItem个数, 即参数个数 DexTypeItem list[size]; //DexTypeItem数组, 按从左到右的顺序保存了方法的参数 } DexTypeList; typedef struct DexTypeItem { u2 typeIdx; //指向DexTypeId列表的索引 } DexTypeItem; 例如此处DexProtoID[1]\n方法声明 DexStringID[shortyIdx]=\u0026ldquo;VL\u0026rdquo;\n返回类型 DexStringID[DexTypeID[returnTypeIdx]]=\u0026ldquo;V\u0026rdquo;\n参数列表 DexStringID[DexTypeID[typeIdx]]=\u0026ldquo;Ljava/lang/String;\u0026rdquo;\n解析代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // ProtoId functions const DexProtoId DexFile::getProtoIdByIndex(u4 index) { if(checkIndexIsLegal(index,pHeader-\u0026gt;protoIdsSize-1)) { return pProtoIds[index]; } illegalIndex(index); } std::string DexFile::getProtoIdShorty(const DexProtoId\u0026amp; protoId) { return getStringIdDataByIndex(protoId.shortyIdx); } std::string DexFile::getProtoIdReturnType(const DexProtoId\u0026amp; protoId) { return getTypeIdDataByIndex(protoId.returnTypeIdx); } // 获取ProtoId的参数列表,解析TypeList结构 std::vector\u0026lt;std::string\u0026gt; DexFile::getProtoIdParameters(const DexProtoId\u0026amp; protoId) { std::vector\u0026lt;std::string\u0026gt; parameters; //无参数 if(protoId.parametersOff==0) { return parameters; } //解析TypeList结构 获取参数列表 DexTypeList* typeList=(DexTypeList*)(baseAddr+protoId.parametersOff); for(int i=0;i\u0026lt;typeList-\u0026gt;size;i++) { parameters.push_back(getTypeIdDataByIndex(typeList-\u0026gt;list[i].typeIdx)); } return parameters; } // 解析DexProtoId结构体 返回解析后的字符串 std::string DexFile::parseProtoId(const DexProtoId\u0026amp; protoId) { std::string shorty=getProtoIdShorty(protoId);//c++的string类型会自动遍历const char*字符串并复制 std::string return_type = getProtoIdReturnType(protoId); std::vector\u0026lt;std::string\u0026gt; parameters=getProtoIdParameters(protoId); std::string result; result+=parseString(return_type)+\u0026#34; (\u0026#34;; //解析参数 for(int i=0;i\u0026lt;parameters.size();i++) { result+=parseString(parameters[i]); if(i!=parameters.size()-1)//多个参数以,分隔 result+=\u0026#34;,\u0026#34;; } result+=\u0026#34;)\u0026#34;; return result; } // 通过索引解析ProtoId,返回解析后的对应字符串 std::string DexFile::getProtoIdDataByIndex(u4 index) { if(checkIndexIsLegal(index,pHeader-\u0026gt;protoIdsSize-1)) { return parseProtoId(getProtoIdByIndex(index)); } return nullptr; } 打印所有ProtoId\n1 2 3 4 5 6 7 8 void DexFile::printProtoIds() { printf(\u0026#34;ProtoIds:\\n\u0026#34;); printf(\u0026#34;\\tNums\\t\\tProtoIds\\n\u0026#34;); for(int i=0;i\u0026lt;pHeader-\u0026gt;protoIdsSize;i++) { printf(\u0026#34;\\t%08x\\t%s\\n\u0026#34;,i,getProtoIdDataByIndex(i).c_str()); } printf(\u0026#34;ProtoIds End\\n\u0026#34;); } 效果如下\nDex Field ID DexFieldID结构体指明了成员变量所在的类,类型以及变量名\n1 2 3 4 5 typedef struct DexFieldId { u2 classIdx; //类的类型,指向DexTypeId列表的索引 u2 typeIdx; //字段类型,指向DexTypeId列表的索引 u4 nameIdx; //字段名,指向DexStringId列表的索引 } DexFieldId; 寻找方法类似,out是java.lang.System类的成员,类型为java.io.PrintStream\n解析代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // FieldId functions const DexFieldId DexFile::getFieldIdByIndex(u4 index) { if(checkIndexIsLegal(index,pHeader-\u0026gt;fieldIdsSize-1)) { return pFieldIds[index]; } illegalIndex(index); } // 获取FieldId所在类类名 std::string DexFile::getFieldIdClass(const DexFieldId\u0026amp; fieldId) { return getTypeIdDataByIndex(fieldId.classIdx); } // 获取FieldId类型 std::string DexFile::getFieldIdType(const DexFieldId\u0026amp; fieldId) { return getTypeIdDataByIndex(fieldId.typeIdx); } // 获取FieldId名称 std::string DexFile::getFieldIdName(const DexFieldId\u0026amp; fieldId) { return getStringIdDataByIndex(fieldId.nameIdx); } // 解析DexFieldId结构,字段所在类,类型,名称 std::string DexFile::parseFieldId(const DexFieldId\u0026amp; fieldId) { std::string fieldClass=getFieldIdClass(fieldId); std::string fieldType=getFieldIdType(fieldId); std::string fieldName=getFieldIdName(fieldId); return parseString(fieldType)+\u0026#34; \u0026#34;+parseString(fieldClass)+\u0026#34;.\u0026#34;+fieldName; } // 通过索引获取FieldId对应的字符串 std::string DexFile::getFieldIdDataByIndex(u4 index) { if(checkIndexIsLegal(index,pHeader-\u0026gt;fieldIdsSize-1)) { return parseFieldId(getFieldIdByIndex(index)); } return nullptr; } 打印所有ProtoId\n1 2 3 4 5 6 7 8 void DexFile::printFieldIds() { printf(\u0026#34;FieldIds:\\n\u0026#34;); printf(\u0026#34;\\tNums\\t\\tFieldIds\\n\u0026#34;); for(int i=0;i\u0026lt;pHeader-\u0026gt;fieldIdsSize;i++) { printf(\u0026#34;\\t%08x\\t%s\\n\u0026#34;,i,getFieldIdDataByIndex(i).c_str()); } printf(\u0026#34;FieldId End\\n\u0026#34;); } 效果如下\nDex Method ID DexMethodId结构体指明了方法所在的类、方法声明（签名）以及方法名, 即完整的方法声明\n1 2 3 4 5 struct DexMethodId { u2 classIdx; /* 方法的所属的类，指向DexTypeId列表的索引 */ u2 protoIdx; /* 声明类型，指向DexProtoId列表的索引 */ u4 nameIdx; /* 方法名，指向DexStringId列表的索引 */ }; 寻找方法\n对应解析代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // MethodId functions const DexMethodId DexFile::getMethodIdByIndex(u4 index) { if(checkIndexIsLegal(index,pHeader-\u0026gt;methodIdsSize-1)) { return pMethodIds[index]; } illegalIndex(index); } // 获取MethodId所在类名 std::string DexFile::getMethodIdClass(const DexMethodId\u0026amp; methodId) { return getTypeIdDataByIndex(methodId.classIdx); } // 获取MethodId对应方法签名 std::string DexFile::getMethodIdProto(const DexMethodId\u0026amp; methodId) { return getProtoIdDataByIndex(methodId.protoIdx); } // 获取MethodId对应方法名 std::string DexFile::getMethodIdName(const DexMethodId\u0026amp; methodId) { return getStringIdDataByIndex(methodId.nameIdx); } // 解析DexMethodId结构 std::string DexFile::parseMethodId(const DexMethodId\u0026amp; methodId) { std::string methodProto=getMethodIdProto(methodId); //解析class并拼接name std::string methodFullName=parseString(getMethodIdClass(methodId))+getMethodIdName(methodId); //拼接proto和class.name return methodProto.insert(methodProto.find(\u0026#39; \u0026#39;)+1,methodFullName); } // 通过索引获取MethodId对应字符串 std::string DexFile::getMethodIdDataByIndex(u4 index) { if(checkIndexIsLegal(index,pHeader-\u0026gt;methodIdsSize-1)) { return parseMethodId(getMethodIdByIndex(index)); } return nullptr; } 打印所有MethodId\n1 2 3 4 5 6 7 8 void DexFile::printMethodIds() { printf(\u0026#34;MethodIds:\\n\u0026#34;); printf(\u0026#34;\\tNums\\t\\tMethodIds\\n\u0026#34;); for(int i=0;i\u0026lt;pHeader-\u0026gt;methodIdsSize;i++) { printf(\u0026#34;\\t%08x\\t%s\\n\u0026#34;,i,getMethodIdDataByIndex(i).c_str()); } printf(\u0026#34;MethodIds End\\n\u0026#34;); } 效果如下\nDex Map List Dalvik虚拟机解析dex文件后,映射为DexMapList的数据结构, 该结构由DexHeader.mapOff指明位置\n1 2 3 4 5 6 7 8 9 10 11 struct DexMapList { u4 size; /* DexMapItem个数 */ DexMapItem list[1]; /* DexMapItem数组 */ }; struct DexMapItem { u2 type; /* KDexType开头的类型 */ u2 unused;\t/* 未使用，用于字节对齐 */ u4 size; /* 类型的个数 */ u4 offset; /* 类型数据的文件偏移 */ }; type是枚举常量,用于判断类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* map item type codes */ enum { kDexTypeHeaderItem = 0x0000, kDexTypeStringIdItem = 0x0001, kDexTypeTypeIdItem = 0x0002, kDexTypeProtoIdItem = 0x0003, kDexTypeFieldIdItem = 0x0004, kDexTypeMethodIdItem = 0x0005, kDexTypeClassDefItem = 0x0006, kDexTypeCallSiteIdItem = 0x0007, kDexTypeMethodHandleItem = 0x0008, kDexTypeMapList = 0x1000, kDexTypeTypeList = 0x1001, kDexTypeAnnotationSetRefList = 0x1002, kDexTypeAnnotationSetItem = 0x1003, kDexTypeClassDataItem = 0x2000, kDexTypeCodeItem = 0x2001, kDexTypeStringDataItem = 0x2002, kDexTypeDebugInfoItem = 0x2003, kDexTypeAnnotationItem = 0x2004, kDexTypeEncodedArrayItem = 0x2005, kDexTypeAnnotationsDirectoryItem = 0x2006, }; size指定了类型个数,在dex文件中连续存放, offset是起始地址文件偏移\n例如DexMapList[1] type=string_id_item, size=0xF, offset=0x70\n和DexStringID表正好对应,起始地址,表项数\n解析代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 void DexFile::printMapList() { static std::map\u0026lt;int, std::string\u0026gt; MapItemTypeToStringMap = { {kDexTypeHeaderItem, \u0026#34;HeaderItem\u0026#34;}, {kDexTypeStringIdItem, \u0026#34;StringIdItem\u0026#34;}, {kDexTypeTypeIdItem, \u0026#34;TypeIdItem\u0026#34;}, {kDexTypeProtoIdItem, \u0026#34;ProtoIdItem\u0026#34;}, {kDexTypeFieldIdItem, \u0026#34;FieldIdItem\u0026#34;}, {kDexTypeMethodIdItem, \u0026#34;MethodIdItem\u0026#34;}, {kDexTypeClassDefItem, \u0026#34;ClassDefItem\u0026#34;}, {kDexTypeMapList, \u0026#34;MapList\u0026#34;}, {kDexTypeTypeList, \u0026#34;TypeList\u0026#34;}, {kDexTypeAnnotationSetRefList, \u0026#34;AnnotationSetRefList\u0026#34;}, {kDexTypeAnnotationSetItem, \u0026#34;AnnotationSetItem\u0026#34;}, {kDexTypeClassDataItem, \u0026#34;ClassDataItem\u0026#34;}, {kDexTypeCodeItem, \u0026#34;CodeItem\u0026#34;}, {kDexTypeStringDataItem, \u0026#34;StringDataItem\u0026#34;}, {kDexTypeDebugInfoItem, \u0026#34;DebugInfoItem\u0026#34;}, {kDexTypeAnnotationItem, \u0026#34;AnnotationItem\u0026#34;}, {kDexTypeEncodedArrayItem, \u0026#34;EncodedArrayItem\u0026#34;}, {kDexTypeAnnotationsDirectoryItem, \u0026#34;AnnotationsDirectoryItem\u0026#34;} }; DexMapList* pMapList=(DexMapList*)(baseAddr+pHeader-\u0026gt;mapOff); DexMapItem* pMapItems=pMapList-\u0026gt;list; printf(\u0026#34;MapList has %d items, start at: %#x\\n\u0026#34;,pMapList-\u0026gt;size,pHeader-\u0026gt;mapOff); printf(\u0026#34;Nums\\t\\tType\\t\\t\\t\\tItemNums\\tStartOff\\n\u0026#34;); for(int i=0;i\u0026lt;pMapList-\u0026gt;size;i++) { // 解析MapType auto it=MapItemTypeToStringMap.find(pMapItems[i].type); std::string mapType; if(it!= MapItemTypeToStringMap.end()) mapType=it-\u0026gt;second; else mapType=\u0026#34;Unknown Type\u0026#34;; printf(\u0026#34;%08d\\t%-24s\\t%08d\\t%08x\\n\u0026#34;,i+1,mapType.c_str(),pMapItems[i].size,pMapItems[i].offset); } printf(\u0026#34;MapList End\\n\u0026#34;); } 打印效果如下\nDex Class Def 该结构较为复杂(这部分相关代码比前文所有结构代码之和都大)\n有了对Dex文件的基本了解和上面各个结构的基础,才能解析该结构\nDexClassDef保存了类的相关信息,定义如下\n1 2 3 4 5 6 7 8 9 10 struct DexClassDef { u4 classIdx; /* 类的类型（即全限定类名），指向DexTypeId列表的索引 */ u4 accessFlags;\t/* 访问标志，以ACC_开头的枚举值，如ACC_PUBLIC（0x1）、ACC_PRIVATE（0x2）*/ u4 superclassIdx; /* 父类类型，指向DexTypeId列表的索引*/ u4 interfacesOff; /* 接口，指向DexTypeList的文件偏移，如果类中不含有接口声明和实现，则值为0 */ u4 sourceFileIdx; /* 类所在源文件的文件名，指向DexStringId列表的索引 */ u4 annotationsOff; /* 注解，指向DexAnnotationsDirectoryItem结构体，根据类型不同会有注解类、注解方法、注解字段与注解参数，如果类中没有注解，则值为0 */ u4 classDataOff; /* 指向DexClassData结构的文件偏移，DexClassData结构是类的数据部分 */ u4 staticValuesOff; /* 指向DexEncodedArray结构的文件偏移，记录类中的静态数据, 没有则为0 */ }; 解析代码如下\n将ClassDef结构划分为4部分解析: BasicInfo, Annotations, ClassData, StaticValues, 从classIdx到sourceFileIx属于BasicInfo\n每部分使用单独的打印函数进行处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 打印所有ClassDef信息 void DexFile::printClassDefs() { printf(\u0026#34;ClassDefs:\\n\u0026#34;); for(int i=0;i\u0026lt;pHeader-\u0026gt;classDefsSize;i++) { DexClassDef classDef=pClassDefs[i]; // 1.Basic info printf(\u0026#34;=========================ClassDef %08d=========================\\n\u0026#34;,i+1); printClassDefBasicInfo(classDef); // 2. Annotations if(classDef.annotationsOff) { printf(\u0026#34;Annotations:\\n\u0026#34;); printClassDefAnnotations(*(DexAnnotationsDirectoryItem*)(baseAddr+classDef.annotationsOff)); // 值传递只保留前16字节导致内存访问错,需要引用传递 // DexAnnotationsDirectoryItem annotations_directory_item=*(DexAnnotationsDirectoryItem*)(baseAddr+classDef.annotationsOff); // parseClassDefAnnotations(annotations_directory_item); } else printf(\u0026#34;No Annotations\\n\u0026#34;); // 3. ClassData if(classDef.classDataOff) { printClassDefClassData(*(DexClassData*)(baseAddr+classDef.classDataOff)); }else printf(\u0026#34;No ClassData\\n\u0026#34;); // 4. StaticValues if(classDef.staticValuesOff) { printClassDefStaticValues(*(DexEncodedArray*)(baseAddr+classDef.staticValuesOff)); }else printf(\u0026#34;No StaticValues\\n\u0026#34;); printf(\u0026#34;===================================================================\\n\u0026#34;); } printf(\u0026#34;ClassDefs End\\n\u0026#34;); } ClassDefBasicInfo 代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 // ClassDef Basic Info functions // 获取class std::string DexFile::getClassDefClass(DexClassDef\u0026amp; classDef) { return parseString(getTypeIdDataByIndex(classDef.classIdx)); } // 解析权限修饰符 std::string DexFile::parseAccessFlags(u4 accessFlags) { static std::map\u0026lt;int, std::string\u0026gt; AccessFlagMap = { {ACC_PUBLIC, \u0026#34;public\u0026#34;}, {ACC_PRIVATE, \u0026#34;private\u0026#34;}, {ACC_PROTECTED, \u0026#34;protected\u0026#34;}, {ACC_STATIC, \u0026#34;static\u0026#34;}, {ACC_FINAL, \u0026#34;final\u0026#34;}, {ACC_SYNCHRONIZED, \u0026#34;synchronized\u0026#34;}, {ACC_SUPER, \u0026#34;super\u0026#34;}, {ACC_VOLATILE, \u0026#34;volatile\u0026#34;}, {ACC_BRIDGE, \u0026#34;bridge\u0026#34;}, {ACC_TRANSIENT, \u0026#34;transient\u0026#34;}, {ACC_VARARGS, \u0026#34;varargs\u0026#34;}, {ACC_NATIVE, \u0026#34;native\u0026#34;}, {ACC_INTERFACE, \u0026#34;interface\u0026#34;}, {ACC_ABSTRACT, \u0026#34;abstract\u0026#34;}, {ACC_STRICT, \u0026#34;strict\u0026#34;}, {ACC_SYNTHETIC, \u0026#34;synthetic\u0026#34;}, {ACC_ANNOTATION, \u0026#34;annotation\u0026#34;}, {ACC_ENUM, \u0026#34;enum\u0026#34;}, {ACC_CONSTRUCTOR, \u0026#34;constructor\u0026#34;}, {ACC_DECLARED_SYNCHRONIZED, \u0026#34;declared_synchronized\u0026#34;} }; std::string result; for(int i=0;i\u0026lt;32;i++) { if(accessFlags \u0026amp; (1 \u0026lt;\u0026lt; i)) { result+=AccessFlagMap[1 \u0026lt;\u0026lt; i]+\u0026#34; \u0026#34;;//遍历添加权限控制属性 } } if(!result.empty()) result=result.substr(0,result.length()-1);//去除末尾多余空格 return result; } // 获取父类 std::string DexFile::getClassDefSuperClass(DexClassDef\u0026amp; classDef) { return parseString(getTypeIdDataByIndex(classDef.superclassIdx)); } // 获取接口列表 std::vector\u0026lt;std::string\u0026gt; DexFile::getClassDefInterfaces(DexClassDef\u0026amp; classDef) { std::vector\u0026lt;std::string\u0026gt; interfaces; //无参数 if(classDef.interfacesOff==0) { return interfaces; } DexTypeList* typeList=(DexTypeList*)(baseAddr+classDef.interfacesOff); for(int i=0;i\u0026lt;typeList-\u0026gt;size;i++) { interfaces.push_back(getTypeIdDataByIndex(typeList-\u0026gt;list[i].typeIdx)); } return interfaces; } // 获取源文件 std::string DexFile::getClassDefSourceFile(DexClassDef\u0026amp; classDef) { return getStringIdDataByIndex(classDef.sourceFileIdx); } // 打印ClassDef结构的基本信息: 类名 父类 源文件名 接口 void DexFile::printClassDefBasicInfo(DexClassDef\u0026amp; classDef) { std::string className=getClassDefClass(classDef); std::string accessFlags=parseAccessFlags(classDef.accessFlags); std::string superClass=getClassDefSuperClass(classDef); std::vector\u0026lt;std::string\u0026gt; interfaces=getClassDefInterfaces(classDef); std::string sourceFile=getClassDefSourceFile(classDef); // Basic info, class super_class source_file interfaces printf(\u0026#34;Class:\\t\\t%s\\n\u0026#34;,combineAccFlagsAndName(accessFlags,className).c_str()); printf(\u0026#34;Super Class:\\t%s\\n\u0026#34;,superClass.c_str()); printf(\u0026#34;Source File:\\t%s\\n\u0026#34;,sourceFile.c_str()); // print interfaces if have it if(!interfaces.empty()) { printf(\u0026#34;Interfaces:\\nNums\\t\\tInterface\\n\u0026#34;); for(int j=0;j\u0026lt;interfaces.size();j++) { printf(\u0026#34;%08d\\t%s\\n\u0026#34;,j+1,parseString(interfaces[j]).c_str()); } }else { printf(\u0026#34;No Interfaces\\n\u0026#34;); } } 效果如下\nDexAnnotationsDirectoryItem annotationsOff指向该结构,用于指向类的所有注解,定义如下\n1 2 3 4 5 6 7 8 9 10 struct DexAnnotationsDirectoryItem { u4 classAnnotationsOff; /* 类注解，值为DexAnnotationSetItem的文件偏移量, 为0表示不存在*/ u4 fieldsSize; /* 域注解，值为DexFieldAnnotationsItem的数量 */ u4 methodsSize; /* 方法注解，值为DexMethodAnnotationsItem的数量 */ u4 parametersSize; /* 参数注解。值为DexParameterAnnotationsItem的数量 */ /* 后3结构中存在1个或多个，则在后面追加以下数据，并按顺序排列 */ /* followed by DexFieldAnnotationsItem[fieldsSize] */ /* followed by DexMethodAnnotationsItem[methodsSize] */ /* followed by DexParameterAnnotationsItem[parametersSize] */ }; printClassDefAnnotations函数用于打印该结构,根据不同注解类型调用不同函数解析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // 打印ClassDef的所有Annotations void DexFile::printClassDefAnnotations(DexAnnotationsDirectoryItem\u0026amp; annotationsDirectory) { //1. 类注解 if(annotationsDirectory.classAnnotationsOff) printClassAnnotations(*(DexAnnotationSetItem*)(baseAddr+annotationsDirectory.classAnnotationsOff)); else printf(\u0026#34;No Class Annotations\\n\\n\u0026#34;); //2. 域(字段)注解 if(annotationsDirectory.fieldsSize) { printFieldAnnotations( (DexFieldAnnotationsItem*)((uintptr_t)\u0026amp;annotationsDirectory +sizeof(DexAnnotationsDirectoryItem)) ,annotationsDirectory.fieldsSize); }else printf(\u0026#34;No Field Annotations\\n\\n\u0026#34;); //3. 方法注解 if(annotationsDirectory.methodsSize) { printMethodAnnotations( (DexMethodAnnotationsItem*) ((uintptr_t)\u0026amp;annotationsDirectory +sizeof(DexAnnotationsDirectoryItem) +sizeof(DexFieldAnnotationsItem)*annotationsDirectory.fieldsSize) ,annotationsDirectory.methodsSize); }else { printf(\u0026#34;No Method Annotations\\n\\n\u0026#34;); } //4. 参数注解 if(annotationsDirectory.parametersSize) { printParameterAnnotations( (DexParameterAnnotationsItem*)((uintptr_t)\u0026amp;annotationsDirectory +sizeof(DexAnnotationsDirectoryItem) +sizeof(DexFieldAnnotationsItem)*annotationsDirectory.fieldsSize +sizeof(DexMethodAnnotationsItem)*annotationsDirectory.methodsSize) ,annotationsDirectory.parametersSize); }else { printf(\u0026#34;No Parameter Annotations\\n\\n\u0026#34;); } } 类注解 DexAnnotationSetItem 1 2 3 4 5 6 7 8 9 struct DexAnnotationSetItem { u4 size;\t/* DexAnnotationItem的数量 */ u4 entries[1]; /* entries数组,存储DexAnnotationItem的文件偏移量 */ }; struct DexAnnotationItem { u1 visibility;\t/* 此注释的预期可见性 */ u1 annotation[1]; /* encoded_annotation格式的注释内容 */ }; visibility表示注释的可见性，主要有以下几种情况：\n名称 值 说明 VISIBILITY_BUILD 0x00 预计仅在构建（例如，在编译其他代码期间）时可见 VISIBILITY_RUNTIME 0x01 预计在运行时可见 VISIBILITY_SYSTEM 0x02 预计在运行时可见，但仅对基本系统（而不是常规用户代码）可见 annotation是采用encoded_annotation格式的注释内容, encoded_annotation格式如下：\n名称 格式 说明 type_idx uleb128 注解的类型，指向DexTypeId列表的索引值 size uleb128 此注解中 name-value 映射的数量 elements annotation_element[size] 注解的元素，直接以内嵌形式（不作为偏移量）表示。元素必须按 string_id 索引以升序进行排序。 annotation_element元素格式如下：\n名称 格式 说明 name_idx uleb128 元素名称，指向DexStringId列表的索引值 value encoded_value 元素值 解析代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // Annotation functions // 将权限修饰符和方法/类名组合 std::string DexFile::combineAccFlagsAndName(std::string accFlags,std::string name) { std::string result; if(accFlags.empty()) result=name;//无权限控制关键字,完整名即可 else result=accFlags+\u0026#34; \u0026#34;+name; return result; } // 打印DexAnnotationItem结构信息 void DexFile::printAnnotation(DexAnnotationItem\u0026amp; annotationItem) { std::string visibility;//注解可见性 switch(annotationItem.visibility) { case kDexVisibilityBuild: visibility=\u0026#34;build\u0026#34;;break; case kDexVisibilityRuntime:visibility=\u0026#34;runtime\u0026#34;;break; case kDexVisibilitySystem:visibility=\u0026#34;system\u0026#34;;break; default:visibility=\u0026#34;unknown\u0026#34;; } // 解析encoded_annotation u1* pAnnotation=annotationItem.annotation; size_t typeSize=0,sizeSize=0; u4 encoded_annotation_type_idx=myReadUnsignedLeb128(pAnnotation,\u0026amp;typeSize);//注解类型偏移 u4 encoded_annotation_size=myReadUnsignedLeb128(pAnnotation+typeSize,\u0026amp;sizeSize);//注解name-value映射数 std::string encoded_annotation_type=parseString(getTypeIdDataByIndex(encoded_annotation_type_idx)); //Size Visibility Type printf(\u0026#34;%08d\\t%s\\t\\t%s\\n\u0026#34;,encoded_annotation_size,visibility.c_str(),encoded_annotation_type.c_str()); // 解析encoded_annotation.elements u1* pAnnotationElements=pAnnotation+typeSize+sizeSize; for(int i=0;i\u0026lt;encoded_annotation_size;i++) { size_t name_idx_size=0;// name_idx std::string name=parseString(getStringIdDataByIndex(myReadUnsignedLeb128(pAnnotationElements,\u0026amp;name_idx_size))); size_t valueSize=0; std::string value=parseString(parseEncodedValue(pAnnotationElements+name_idx_size,valueSize)); printf(\u0026#34;\\t%s=%s\\n\u0026#34;,name.c_str(),value.c_str()); } } // 打印DexAnnotationSetItem信息 即多个DexAnnotationItem结构 void DexFile::printAnnotationSet(DexAnnotationSetItem\u0026amp; annotationSet) { printf(\u0026#34;Size\\t\\tVisibility\\tType\\n\u0026#34;); //AnnotationSetItem.entries[] 数组保存AnnotationItem结构的文件偏移值 for(int j=0;j\u0026lt;annotationSet.size;j++) { printAnnotation(*(DexAnnotationItem*)(annotationSet.entries[j]+baseAddr)); } } // 打印所有类注解 DexAnnotationSetItem void DexFile::printClassAnnotations(DexAnnotationSetItem\u0026amp; classAnnotations) { printf(\u0026#34;Class Annotations start at %#llx, contains %d entries\\n\u0026#34;,(uintptr_t)classAnnotations.entries-(uintptr_t)baseAddr,classAnnotations.size); printAnnotationSet(classAnnotations); printf(\u0026#34;Class Annotations End\\n\\n\u0026#34;); } 效果如下, 打印类注解及其包含的encoded_element内容\n域注解 DexFieldAnnotationsItem 定义如下\n1 2 3 4 struct DexFieldAnnotationsItem { u4 fieldIdx;\t/* 指向DexFieldId列表的索引值 */ u4 annotationsOff; /* DexAnnotationSetItem的文件偏移量 */ }; 由于指向DexAnnotationSetItem结构,故解析方式和类注解类似\n1 2 3 4 5 6 7 8 9 10 // 打印所有域注解 DexFieldAnnotationsItem void DexFile::printFieldAnnotations(DexFieldAnnotationsItem* pFieldAnnotations,u4 fieldsNum) { printf(\u0026#34;Field Annotations start at %#llx, contains %d entries\\n\u0026#34;,(uintptr_t)pFieldAnnotations-(uintptr_t)baseAddr,fieldsNum); for(int i=0;i\u0026lt;fieldsNum;i++) { std::string field=getFieldIdDataByIndex(pFieldAnnotations[i].fieldIdx); printf(\u0026#34;Field%d:\\t%s\\n\u0026#34;,i+1,field.c_str()); printAnnotationSet(*(DexAnnotationSetItem*)(baseAddr+pFieldAnnotations[i].annotationsOff)); } printf(\u0026#34;Field Annotations End\\n\\n\u0026#34;); } 效果如下\n方法注解 DexMethodAnnotationsItem 定义如下\n1 2 3 4 5 6 7 /* * Direct-mapped \u0026#34;method_annotations_item\u0026#34;. */ struct DexMethodAnnotationsItem { u4 methodIdx;\t/* 指向DexMethodId列表的索引值 */ u4 annotationsOff; /* DexAnnotationSetItem的文件偏移量 */ }; 解析方法类似\n1 2 3 4 5 6 7 8 9 10 // 打印方法注解 DexMethodAnnotationsItem void DexFile::printMethodAnnotations(DexMethodAnnotationsItem* pMethodAnnotations,u4 methodsNum) { printf(\u0026#34;Method Annotations start at %#llx, contains %d entries\\n\u0026#34;,(uintptr_t) pMethodAnnotations-(uintptr_t)baseAddr,methodsNum); for(int i=0;i\u0026lt;methodsNum;i++) { std::string method=getMethodIdDataByIndex(pMethodAnnotations[i].methodIdx); printf(\u0026#34;Method%d:\\t%s\\n\u0026#34;,i+1,method.c_str()); printAnnotationSet(*(DexAnnotationSetItem*)(baseAddr+ pMethodAnnotations[i].annotationsOff)); } printf(\u0026#34;Method Annotations End\\n\\n\u0026#34;); } 效果如下\n参数注解 DexParameterAnnotationsItem 定义如下\n1 2 3 4 5 6 7 /* * Direct-mapped \u0026#34;parameter_annotations_item\u0026#34;. */ struct DexParameterAnnotationsItem { u4 methodIdx;\t/* 指向DexMethodId列表的索引值 */ u4 annotationsOff; /* DexAnotationSetRefList的文件偏移量 */ }; DexAnotationSetRefList结构体定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* * Direct-mapped \u0026#34;annotation_set_ref_list\u0026#34;. */ struct DexAnnotationSetRefList { u4 size;\t/* 列表中元素个数，即DexAnnotationSetRefItem的个数 */ DexAnnotationSetRefItem list[1];\t/* 第一个DexAnnotationSetRefItem的内容，非偏移量 */ }; /* * Direct-mapped \u0026#34;annotation_set_ref_item\u0026#34;. */ struct DexAnnotationSetRefItem { u4 annotationsOff; /* DexAnnotationSetItem的偏移量 */ }; 解析方法略有不同,代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 打印DexAnnotationSetRefList void DexFile::printAnnotationSetRefList(DexAnnotationSetRefList\u0026amp; annotationSetRefList) { printf(\u0026#34;AnnotationSetRefList contains %d AnnotationSetItems\\n\u0026#34;,annotationSetRefList.size); // AnnotationSetRefList.list是AnnotationSetRefItem数组 DexAnnotationSetRefItem* pAnnotationSetRefItem=annotationSetRefList.list; for(int i=0;i\u0026lt;annotationSetRefList.size;i++) { if(!pAnnotationSetRefItem[i].annotationsOff) { printf(\u0026#34;No This Annotation Set!\\n\u0026#34;);//可能存在空项 continue; } //AnnotationSetRefItem.annotationsOff指向AnnotationSetItem结构 printAnnotationSet(*(DexAnnotationSetItem*)(baseAddr+pAnnotationSetRefItem[i].annotationsOff)); } printf(\u0026#34;AnnotationSetRefList End\\n\u0026#34;); } // 打印参数注解 DexParameterAnnotationsItem void DexFile::printParameterAnnotations(DexParameterAnnotationsItem* pParameterAnnotations,u4 parametersNum) { printf(\u0026#34;Parameter Annotations start at %#llx, contains %d entries\\n\u0026#34;,(uintptr_t) pParameterAnnotations-(uintptr_t)baseAddr,parametersNum); for(int i=0;i\u0026lt;parametersNum;i++) { std::string method=getMethodIdDataByIndex(pParameterAnnotations[i].methodIdx); printf(\u0026#34;Method%d:\\t%s\\n\u0026#34;,i+1,method.c_str()); // PatameterAnnotationsItem.annotationsOff指向DexAnnotationSetRefList结构,和其他三个不同 printAnnotationSetRefList(*(DexAnnotationSetRefList*)(baseAddr+pParameterAnnotations[i].annotationsOff)); printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;Parameter Annotations End\\n\\n\u0026#34;); } 效果如下\nDexClassData 定义在http://androidxref.com/2.3.7/xref/dalvik/libdex/DexClass.h中\n注意: DexClass.h定义的结构体中,u4类型实际类型为uleb128\n1 2 3 4 5 6 7 8 9 10 /* expanded form of class_data_item. Note: If a particular item is * absent (e.g., no static fields), then the corresponding pointer * is set to NULL. */ typedef struct DexClassData { DexClassDataHeader header; DexField* staticFields;\t//下面4个连续数组,如果对应长度存在才有效 DexField* instanceFields;\t//按顺序排列\tDexMethod* directMethods; DexMethod* virtualMethods; } DexClassData; 内部的结构体定义如下:\n注意u4均为uleb128,所以这些结构大小不固定,无法通过sizeof计算,需要手动计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* expanded form of a class_data_item header */ typedef struct DexClassDataHeader { u4 staticFieldsSize; u4 instanceFieldsSize; u4 directMethodsSize; u4 virtualMethodsSize; } DexClassDataHeader; /* expanded form of encoded_field */ typedef struct DexField { u4 fieldIdx; /* index to a field_id_item */ u4 accessFlags; } DexField; /* expanded form of encoded_method */ typedef struct DexMethod { u4 methodIdx; /* index to a method_id_item */ u4 accessFlags; u4 codeOff; /* file offset to a code_item */ } DexMethod; 其中codeOff指向DexCode结构,定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* * Direct-mapped \u0026#34;code_item\u0026#34;. * * The \u0026#34;catches\u0026#34; table is used when throwing an exception, * \u0026#34;debugInfo\u0026#34; is used when displaying an exception stack trace or * debugging. An offset of zero indicates that there are no entries. */ struct DexCode { u2 registersSize;\t/* 使用的寄存器个数 */ u2 insSize;\t/* 参数个数 */ u2 outsSize;\t/* 调用其他方法时使用的寄存器个数 */ u2 triesSize;\t/* try_item的个数 */ u4 debugInfoOff; /* 指向调试信息的文件偏移量 */ u4 insnsSize; /* 指令集个数，以2字节为单位 */ u2 insns[1];\t/* 指令集，insns 数组中的代码格式由随附文档 Dalvik 字节码指定 */ /* 如果 triesSize 不为零，下面存在*/ /* 两字节填充，使下面的try_item实现4字节对齐 */ /* followed by try_item[triesSize]，用于表示代码中捕获异常的位置以及如何对异常进行处理的数组 */ /* followed by uleb128 handlersSize */ /* followed by catch_handler_item[handlersSize]，用于表示“捕获类型列表和关联处理程序地址”的列表的字节 */ }; 解析代码如下,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 // 打印DexCode Todo: 解析DexCode字段 void DexFile::printDexCode(DexCode\u0026amp; dexCode) { // 打印基本信息 printf(\u0026#34;DexCode:\\n\u0026#34;); printf(\u0026#34;RegsNum\\t\\tParamsNum\\tOutsNum\\t\\tTriesNum\\tDebugInfoOff\\tInsnsNum\\tInsnsOff\\n\u0026#34;); printf(\u0026#34;%08d\\t%08d\\t%08d\\t%08d\\t%08x\\t%08d\\t%08x\\n\u0026#34;,dexCode.registersSize,dexCode.insSize,dexCode.outsSize,dexCode.triesSize,dexCode.debugInfoOff,dexCode.insnsSize,(uintptr_t)dexCode.insns-(uintptr_t)baseAddr); // 打印 printf(\u0026#34;DexCode End\\n\u0026#34;); } // 打印DexClassData的DexField项目 返回对应数组结构的大小 unsigned int DexFile::printClassDataItem(DexField* pFields,u4 fieldsNum) { u4 prevFieldIndex=0,offset=0; for(int i=0;i\u0026lt;fieldsNum;i++) { DexField* pField=(DexField*)((uintptr_t)pFields+offset); // 注意由于内部元素为uleb128类型,所以DexField大小并不固定,需要计算 size_t fieldIndexSize=0,accessFlagsValueSize=0; u4 fieldIndex=myReadUnsignedLeb128((u1*)pField,\u0026amp;fieldIndexSize); u4 accessFlagsValue=myReadUnsignedLeb128((u1*)pField+fieldIndexSize,\u0026amp;accessFlagsValueSize); std::string fieldName=getFieldIdDataByIndex(prevFieldIndex+fieldIndex); std::string accessFlags=parseAccessFlags(accessFlagsValue); printf(\u0026#34;Field%d: %s\\n\u0026#34;,i+1,combineAccFlagsAndName(accessFlags,fieldName).c_str()); prevFieldIndex+=fieldIndex;// 更新前一个filedIndex offset+=fieldIndexSize+accessFlagsValueSize;//当前数组结构的偏移 } return offset;//返回当前数组大小 } // 打印DexClassData的DexMethod项目 返回对应数组结构的大小 unsigned int DexFile::printClassDataItem(DexMethod* pMethods,u4 methodsNum) { u4 prevMethodIndex=0,offset=0; for(int i=0;i\u0026lt;methodsNum;i++) { DexMethod* pMethod=(DexMethod*)((uintptr_t)pMethods+offset); size_t methodIndexSize=0,accessFlagsValueSize=0,codeOffSize=0;// 相比DexField多了codeOff,指向DexCode结构 u4 methodIndex=myReadUnsignedLeb128((u1*)pMethod,\u0026amp;methodIndexSize); u4 accessFlagsValue=myReadUnsignedLeb128((u1*)pMethod+methodIndexSize,\u0026amp;accessFlagsValueSize); u4 codeOff=myReadUnsignedLeb128((u1*)pMethod+methodIndexSize+accessFlagsValueSize,\u0026amp;codeOffSize); std::string methodName=getMethodIdDataByIndex(prevMethodIndex+methodIndex); std::string accessFlags=parseAccessFlags(accessFlagsValue); printf(\u0026#34;Method%d: %s\\n\u0026#34;,i+1,combineAccFlagsAndName(accessFlags,methodName).c_str()); if(codeOff) { printf(\u0026#34;CodeOff: %08x\\n\u0026#34;,codeOff); printDexCode(*(DexCode*)(baseAddr+codeOff));//打印codeOff指向的DexCode } else printf(\u0026#34;No DexCode\\n\u0026#34;); prevMethodIndex+=methodIndex; offset+=methodIndexSize+accessFlagsValueSize+codeOffSize; } return offset; } // 打印DexClassData void DexFile::printClassDefClassData(DexClassData\u0026amp; classData) { printf(\u0026#34;ClassData:\\n\u0026#34;); // 1.解析DexClassDataHeader 获取各uleb128字段保存的长度 const u1* pClassDataHeader=(u1*)\u0026amp;classData.header; const u1** pPClassDataHeader=\u0026amp;pClassDataHeader; u4 staticFieldsNum=readUnsignedLeb128(pPClassDataHeader); u4 instanceFieldsNum=readUnsignedLeb128(pPClassDataHeader); u4 directMethodsNum=readUnsignedLeb128(pPClassDataHeader); u4 virtualMethodsNum=readUnsignedLeb128(pPClassDataHeader); // pointer指向DexClassDataHeader后方第一个字节(即4个数组的内容),用于后续计算 uintptr_t pointer=((uintptr_t)\u0026amp;classData+unsignedLeb128Size(staticFieldsNum) +unsignedLeb128Size(instanceFieldsNum) +unsignedLeb128Size(directMethodsNum) +unsignedLeb128Size(virtualMethodsNum)); // 2. 解析各个字段(判断是否存在对应字段) // 注意: // 1. fieldIdx和accessFlags均为uleb128类型 // 2. 数组首个fieldIndex和methodIndex是正确的,后续index是相对前一个index的偏移值(大部分为1) // 3. 由于各个结构大小不固定,但是四个数组是连续的,所以要使用offset记录前方数据的大小 unsigned int offset=0; if(staticFieldsNum) { printf(\u0026#34;ClassData contains %d Static Fields:\\n\u0026#34;,staticFieldsNum); offset+=printClassDataItem((DexField*)(pointer+offset),staticFieldsNum); printf(\u0026#34;Static Fields End\\n\u0026#34;); } else { printf(\u0026#34;No Static Field\\n\u0026#34;); } if(instanceFieldsNum) { printf(\u0026#34;ClassData contains %d Instance Fields:\\n\u0026#34;,instanceFieldsNum); offset+=printClassDataItem((DexField*)(pointer+offset),staticFieldsNum); printf(\u0026#34;Instance Fields End\\n\u0026#34;); } else { printf(\u0026#34;No Instance Field\\n\u0026#34;); } if(directMethodsNum) { printf(\u0026#34;ClassData contains %d Directed Methods:\\n\u0026#34;,directMethodsNum); offset+=printClassDataItem((DexMethod*)(pointer+offset),directMethodsNum); printf(\u0026#34;Directed Methods End\\n\u0026#34;); } else { printf(\u0026#34;No Directed Method\\n\u0026#34;); } if(virtualMethodsNum) { printf(\u0026#34;ClassData contains %d Virtual Methods:\\n\u0026#34;,virtualMethodsNum); offset+=printClassDataItem((DexMethod*)(pointer+offset),virtualMethodsNum); printf(\u0026#34;Virtual Methods End\\n\u0026#34;); } else { printf(\u0026#34;No Virtual Method\\n\u0026#34;); } printf(\u0026#34;ClassData End\\n\u0026#34;); } 效果如下\nDexEncodedArray 定义如下\n1 2 3 struct DexEncodedArray { u1 array[1];\t//encoded_array格式的数据 }; encoded_array格式定义如下：\n名称 格式 说明 size uleb128 表示数组中的元素数量 values encoded_value[size] 采用encoded_value编码的数据 解析代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 打印StaticValues 实际为DexEncodedArray结构 void DexFile::printClassDefStaticValues(DexEncodedArray\u0026amp; encodedArray) { size_t sizeLen=0; u4 size=myReadUnsignedLeb128((u1*)\u0026amp;encodedArray,\u0026amp;sizeLen); u1* pValues=(u1*)\u0026amp;encodedArray+sizeLen; printf(\u0026#34;StaticValues contains %d values\\n\u0026#34;,size); size_t offset=0,readSize=0;// offset保存前方已访问的结构大小,readSize为单次读取的大小 for(int i=0;i\u0026lt;size;i++) { printf(\u0026#34;%s\\n\u0026#34;,parseEncodedValue(pValues+offset,readSize).c_str()); offset+=readSize; } printf(\u0026#34;StaticValues End\\n\u0026#34;); } 效果如下\nAndroid系统可执行文件 从JVM到Dalvik再到ART JVM是java语言的虚拟机,运行.class文件\nDalvik是google设计的用于Android平台的虚拟机,运行.dex文件\nJVM基于栈,DVM基于寄存器,可以做到更好的提前优化,并且运行速度更快\nAndroid 4.4首次提出ART虚拟机,在Android 5.0后弃用Dalvik,默认使用ART,运行oat文件\nDVM应用运行时,字节码需要通过即时编译器JIT转换为机器码运行\nART则在应用第一次安装时,预先将字节码编译为机器码,该过程称之为预编译(AOT Ahead of time)\nDEX .java文件 经javac编译后生成 .class 文件 再通过dx/d8生成.dex文件\nDalvik虚拟机运行.dex文件,一个apk包内可能含有多个dex文件\nODEX Android5.0前,使用Dalvik虚拟机,ODEX是Dalvik对Dex文件优化后的产物, 通常存放在/data/dalvik-cache目录下\n运行程序时直接加载odex文件,避免重复验证和优化\nAndroid 5.0后,使用ART虚拟机, .odex实际上是OAT文件(ART定制的ELF文件)\nOAT OAT文件是Android4.4中引入的, Android5.0后,系统默认虚拟机为ART\nOAT文件即是ART虚拟机对Dex优化后的产物,是Android定制的ELF文件\nOAT文件结构随Android版本变化而变化,没有向后兼容性\nVDEX VDEX文件在Android 8.0后引入, 不是Android系统的可执行文件,\nAndroid 8.0后, dex2oat将class.dex优化生成2个文件: OAT文件(.odex)和VDEX文件(.vdex)\n.odex文件包含了本机代码的OAT文件 .vdex文件包含了原始的dex文件副本 vdex文件同oat文件一样,随系统版本变化,且没有向后兼容性 ART .art文件是一种ELF可执行文件 借助odex文件优化生成, 记录应用启动的热点函数相关地址,便于寻址加速\nart文件结构随android版本变化,无向后兼容性\nTodo 完善encoded_value剩余3个分支解析逻辑 绘制Dex文件结构图加深理解 整理代码架构 References Dalvik 可执行文件格式 Android官方文档\nDex文件格式\ndex文件格式解析\n从JVM到Dalivk再到ART（class,dex,odex,vdex,ELF）\nandroid的dex，odex，oat，vdex，art文件格式\n一图全览DEX文件格式\n","date":"2024-12-26T13:47:07+08:00","image":"https://example.com/p/dex%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90-readdex%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/1-dex%E6%96%87%E4%BB%B6%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84_hu3906483134663260330.png","permalink":"https://example.com/p/dex%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90-readdex%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E7%8E%B0/","title":"Dex文件结构解析 ReadDex解析器实现"},{"content":"前言 近期冲浪刷到大佬博客ELF文件格式, 心血来潮\n网上有不少ELF文件结构相关的文章,但大都介绍原理,具体的代码实现并不多(或许是因为有开源代码)\n然而阅读开源代码不是我的强项(看的头大), 于是依据当年学习PE文件结构的思路,学习ELF文件格式\n仿照 readelf 的输出结果编写解析器, 最后编写了简单的ELF加载器\n代码支持x86和x64的ELF文件:\n解析器针对x86/x64有两套实现, 支持解析x86和x64平台的ELF文件\n加载器依赖编译环境,只能加载对应平台的ELF文件,要分别编译x86和x64的加载器\n内容讲解演示主要以x86为主\n环境\u0026amp;工具:\nVMware pro 17.6.1 Kali Linux 2023.4 vmware amd64 gcc (Debian 14.2.0-8) 14.2.0 CLion 2024.2.3 010 Editor 13.0.1 IDA Pro 7.7 由于本人水平有限, 内容错误之处还望大佬多多包涵, 批评指正\nELF文件结构概述 ELF是UNIX系统实验室(USL)作为应用程序二进制接口(Application Binary Interface,ABI)而开发和发布的,也是Linux的主要可执行文件格式, 全称是Executable and Linking Format,这个名字相当关键,包含了ELF所需要支持的两个功能——执行和链接\nELF文件包含3大部分,ELF头,ELF节,ELF段:\n节头表指向节, 类似PE的节表, 描述各个节区的信息\n程序头表描述段信息,一个段可以包含多个节,指导ELF文件如何映射至文件\n在OBJ文件中,段是可选的,在可执行文件中,节是可选的,但NDK编译的ELF文件同时有段和节\nELF文件封装了部分数据类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;stdint.h\u0026gt; typedef uint16_t Elf32_Half; typedef uint16_t Elf64_Half; /* Types for signed and unsigned 32-bit quantities. */ typedef uint32_t Elf32_Word; typedef\tint32_t Elf32_Sword; typedef uint32_t Elf64_Word; typedef\tint32_t Elf64_Sword; /* Types for signed and unsigned 64-bit quantities. */ typedef uint64_t Elf32_Xword; typedef\tint64_t Elf32_Sxword; typedef uint64_t Elf64_Xword; typedef\tint64_t Elf64_Sxword; /* Type of addresses. */ typedef uint32_t Elf32_Addr; typedef uint64_t Elf64_Addr; /* Type of file offsets. */ typedef uint32_t Elf32_Off; typedef uint64_t Elf64_Off; /* Type for section indices, which are 16-bit quantities. */ typedef uint16_t Elf32_Section; typedef uint16_t Elf64_Section; /* Type for version symbol information. */ typedef Elf32_Half Elf32_Versym; typedef Elf64_Half Elf64_Versym; 可以发现,32和64位定义的数据结构仅有Addr和Off有位宽差距,我们可以定义对应的通用类型\nELF数据结构 原始类型 备注 Elfn_Half uint16_t Elfn_Word uint32_t Elfn_Sword int32_t Elfn_Xword uint64_t Elfn_Sxword int64_t Elf32_Addr uint32_t 地址 Elf64_Addr uint64_t Elf32_Off uint32_t 文件偏移 Elf64_Off uint64_t Elfn_Section uint16_t 节索引 Elfn_Versym uint16_t 使用gcc分别编译32/64位的elf可执行文件用于测试\n1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main(int argc, char* argv[]){ printf(\u0026#34;Hello ELF!\\n\u0026#34;); return 0; } 1 2 gcc -m32 -O0 main.c -o HelloELF32 gcc -m64 -O0 main.c -o HelloELF64 编写ELF解析器/加载器前,定义文件读取函数\n读取指定路径文件,返回字节指针和读取文件大小\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 读取文件,返回buffer和读取字节数 uint8_t* readFileToBytes(const char *fileName,size_t* readSize) { FILE *file = fopen(fileName, \u0026#34;rb\u0026#34;); if (file == NULL) { printf(\u0026#34;Error opening file\\n\u0026#34;); fclose(file); return NULL; } fseek(file, 0,SEEK_END); size_t fileSize = ftell(file); fseek(file, 0,SEEK_SET); uint8_t *buffer = (uint8_t *) malloc(fileSize); if (buffer == NULL) { printf(\u0026#34;Error allocating memory\\n\u0026#34;); fclose(file); return NULL; } size_t bytesRead = fread(buffer, 1, fileSize, file); if(bytesRead!=fileSize) { printf(\u0026#34;Read bytes not equal file size!\\n\u0026#34;); free(buffer); fclose(file); return NULL; } fclose(file); if(readSize) *readSize=bytesRead; return buffer; } ELF Header 定义在elf.h中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #define EI_NIDENT (16) typedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf32_Half e_type; /* Object file type */ Elf32_Half e_machine; /* Architecture */ Elf32_Word e_version; /* Object file version */ Elf32_Addr e_entry; /* Entry point virtual address */ Elf32_Off e_phoff; /* Program header table file offset */ Elf32_Off e_shoff; /* Section header table file offset */ Elf32_Word e_flags; /* Processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size in bytes */ Elf32_Half e_phentsize; /* Program header table entry size */ Elf32_Half e_phnum; /* Program header table entry count */ Elf32_Half e_shentsize; /* Section header table entry size */ Elf32_Half e_shnum; /* Section header table entry count */ Elf32_Half e_shstrndx; /* Section header string table index */ } Elf32_Ehdr; //64位 typedef struct { unsigned char\te_ident[EI_NIDENT];\t/* Magic number and other info */ Elf64_Half\te_type;\t/* Object file type */ Elf64_Half\te_machine;\t/* Architecture */ Elf64_Word\te_version;\t/* Object file version */ Elf64_Addr\te_entry;\t/* Entry point virtual address */ Elf64_Off\te_phoff;\t/* Program header table file offset */ Elf64_Off\te_shoff;\t/* Section header table file offset */ Elf64_Word\te_flags;\t/* Processor-specific flags */ Elf64_Half\te_ehsize;\t/* ELF header size in bytes */ Elf64_Half\te_phentsize;\t/* Program header table entry size */ Elf64_Half\te_phnum;\t/* Program header table entry count */ Elf64_Half\te_shentsize;\t/* Section header table entry size */ Elf64_Half\te_shnum;\t/* Section header table entry count */ Elf64_Half\te_shstrndx;\t/* Section header string table index */ } Elf64_Ehdr; 可以使用readelf查看\ne_ident 16字节ELF标识,前4字节是ELF文件标识\u0026quot;\\x7fELF\u0026quot;,不可修改\n010editor中解析如下\ne_ident[EI_CLASS]\n该字节指明了文件类型\nAndroid系统不检查该字节,通过判断指令集v7a/v8a确定是32或64位\nIDA检查该字节,如果修改了这个字节,IDA就无法反汇编\ne_ident[EI_DATA]\n该字节指明了目标文件的数据编码格式(大小端序)\nAndroid不检查该字节,默认小端序; IDA检查该字节,如果修改该字节则IDA无法正确反汇编\ne_ident[EI_VERSION]\nELF文件头的版本\ne_type 2字节,表明目标文件属于哪种类型\nAndroid5.0后,可执行文件全部为so,这个标志只能为03不可修改\n1 2 3 4 5 6 7 8 9 10 11 12 /* Legal values for e_type (object file type). */ #define ET_NONE\t0\t/* No file type */ #define ET_REL\t1\t/* Relocatable file */ #define ET_EXEC\t2\t/* Executable file */ #define ET_DYN\t3\t/* Shared object file */ #define ET_CORE\t4\t/* Core file */ #define\tET_NUM\t5\t/* Number of defined types */ #define ET_LOOS\t0xfe00\t/* OS-specific range start */ #define ET_HIOS\t0xfeff\t/* OS-specific range end */ #define ET_LOPROC\t0xff00\t/* Processor-specific range start */ #define ET_HIPROC\t0xffff\t/* Processor-specific range end */ e_machine 2字节,该字段用于指定ELF文件适用的处理器架构,部分定义如下, 对于intel,固定为EM_386\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #define EM_NONE\t0\t/* No machine */ #define EM_M32\t1\t/* AT\u0026amp;T WE 32100 */ #define EM_SPARC\t2\t/* SUN SPARC */ #define EM_386\t3\t/* Intel 80386 */ #define EM_68K\t4\t/* Motorola m68k family */ #define EM_88K\t5\t/* Motorola m88k family */ #define EM_IAMCU\t6\t/* Intel MCU */ #define EM_860\t7\t/* Intel 80860 */ #define EM_MIPS\t8\t/* MIPS R3000 big-endian */ #define EM_S370\t9\t/* IBM System/370 */ #define EM_MIPS_RS3_LE\t10\t/* MIPS R3000 little-endian */ /* reserved 11-14 */ #define EM_PARISC\t15\t/* HPPA */ /* reserved 16 */ e_version 4字节,指明目标文件版本\nAndroid不检查该字段,IDA检查,但对反汇编无影响\ne_entry 4或8字节,程序入口点(OEP) RVA, 如果e_type=2 即可执行程序, 则该字段为VA; 如果是so,则为0\ne_phoff 4或8字节,程序头表偏移FOA,如果没有程序头表则该字段为0\ne_shoff 4或8字节,节头表偏移FOA,如果没有节头表则该字段为0\nAndroid对抗中经常会删除节表\ne_flags 4字节标志,无用\ne_ehsize 2字节,ELF文件头大小\nAndroid不检查,默认ELF Header大小为52字节; IDA检查,修改该字段只会产生警告不影响反汇编\ne_phentsize 2字节,表示程序头表每一个表项的大小\ne_phnum 2字节,表示程序头表的表项数目\ne_shentsize 2字节,节头表表项大小\ne_shnum 2字节,节头表表项个数\ne_shstrndx 2字节,节头表中与节名表相对应表项的索引\n打印文件头 根据枚举值,定义对应的字符串数组以打印相关信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Print ELF Header char ELF_Class[3][6] = {\u0026#34;NONE\u0026#34;, \u0026#34;ELF32\u0026#34;, \u0026#34;ELF64\u0026#34;}; char ELF_Data[3][14] = {\u0026#34;NONE\u0026#34;, \u0026#34;Little Endian\u0026#34;, \u0026#34;Big Endian\u0026#34;}; char objectFileType[7][7] = {\u0026#34;NONE\u0026#34;, \u0026#34;REL\u0026#34;, \u0026#34;EXEC\u0026#34;, \u0026#34;DYN\u0026#34;, \u0026#34;CORE\u0026#34;, \u0026#34;LOPROC\u0026#34;, \u0026#34;HIPROC\u0026#34;}; void printELFHeader32(const Elf32_Ehdr* pElfHeader) { printf(\u0026#34;ELF Header:\\n\u0026#34;); printf(\u0026#34;\\tMagic:\\t\u0026#34;); for (int i = 0; i \u0026lt; EI_NIDENT; i++) { printf(\u0026#34;%02x \u0026#34;, pElfHeader[i].e_ident[i]); } printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;\\t%-36s%s\\n\u0026#34;, \u0026#34;Class:\u0026#34;, ELF_Class[pElfHeader-\u0026gt;e_ident[EI_CLASS]]); printf(\u0026#34;\\t%-36s%s\\n\u0026#34;, \u0026#34;Data:\u0026#34;, ELF_Data[pElfHeader-\u0026gt;e_ident[EI_DATA]]); printf(\u0026#34;\\t%-36s%#x\\n\u0026#34;, \u0026#34;Version:\u0026#34;, pElfHeader-\u0026gt;e_version); printf(\u0026#34;\\t%-36s%#x\\n\u0026#34;, \u0026#34;Machine:\u0026#34;, pElfHeader-\u0026gt;e_machine); printf(\u0026#34;\\t%-36s%s\\n\u0026#34;, \u0026#34;Type:\u0026#34;, objectFileType[pElfHeader-\u0026gt;e_type]); printf(\u0026#34;\\t%-36s%#x\\n\u0026#34;, \u0026#34;Size Of ELF Header:\u0026#34;, pElfHeader-\u0026gt;e_ehsize); printf(\u0026#34;\\t%-36s%#x\\n\u0026#34;, \u0026#34;Entry point:\u0026#34;, pElfHeader-\u0026gt;e_entry); printf(\u0026#34;\\t%-36s%#x\\n\u0026#34;, \u0026#34;Start Of Program Headers:\u0026#34;, pElfHeader-\u0026gt;e_phoff); printf(\u0026#34;\\t%-36s%#x\\n\u0026#34;, \u0026#34;Start Of Section Headers:\u0026#34;, pElfHeader-\u0026gt;e_shoff); printf(\u0026#34;\\t%-36s%#x\\n\u0026#34;, \u0026#34;Size Of Program Headers:\u0026#34;, pElfHeader-\u0026gt;e_phentsize); printf(\u0026#34;\\t%-36s%#x\\n\u0026#34;, \u0026#34;Number Of Program Headers:\u0026#34;, pElfHeader-\u0026gt;e_phnum); printf(\u0026#34;\\t%-36s%#x\\n\u0026#34;, \u0026#34;Size Of Section Headers:\u0026#34;, pElfHeader-\u0026gt;e_shentsize); printf(\u0026#34;\\t%-36s%#x\\n\u0026#34;, \u0026#34;Number Of Sections:\u0026#34;, pElfHeader-\u0026gt;e_shnum); printf(\u0026#34;\\t%-36s%d\\n\u0026#34;, \u0026#34;Section Header String Table Index:\u0026#34;, pElfHeader-\u0026gt;e_shstrndx); printf(\u0026#34;ELF Header End\\n\u0026#34;); } 打印效果如下\nSection Header 类似PE文件的节表(IMAGE_SECTION_HEADER)\n节表保存了节的基本属性,是ELF文件中除了文件头之外最重要的结构,编译器,链接器和装载器都依赖节表定位和访问各个节的属性\n节表数组第0个元素固定为SHN_UNDEF, 节表成员结构定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 typedef struct { Elf32_Word\tsh_name;\t/* Section name (string tbl index) */ Elf32_Word\tsh_type;\t/* Section type */ Elf32_Word\tsh_flags;\t/* Section flags */ Elf32_Addr\tsh_addr;\t/* Section virtual addr at execution */ Elf32_Off\tsh_offset;\t/* Section file offset */ Elf32_Word\tsh_size;\t/* Section size in bytes */ Elf32_Word\tsh_link;\t/* Link to another section */ Elf32_Word\tsh_info;\t/* Additional section information */ Elf32_Word\tsh_addralign;\t/* Section alignment */ Elf32_Word\tsh_entsize;\t/* Entry size if section holds table */ } Elf32_Shdr; typedef struct { Elf64_Word\tsh_name;\t/* Section name (string tbl index) */ Elf64_Word\tsh_type;\t/* Section type */ Elf64_Xword\tsh_flags;\t/* Section flags */ Elf64_Addr\tsh_addr;\t/* Section virtual addr at execution */ Elf64_Off\tsh_offset;\t/* Section file offset */ Elf64_Xword\tsh_size;\t/* Section size in bytes */ Elf64_Word\tsh_link;\t/* Link to another section */ Elf64_Word\tsh_info;\t/* Additional section information */ Elf64_Xword\tsh_addralign;\t/* Section alignment */ Elf64_Xword\tsh_entsize;\t/* Entry size if section holds table */ } Elf64_Shdr; readelf查看节表\nsh_name 4字节,偏移值,通过ELF File Header.e_shstrndx拿到节表中节名称表对应项的索引\n然后在节表中找到该项,找到sh_offset的文件偏移 sh_name+sh_offset即为该节名的字符串的FOA\nsh_type 4字节,指示节的类型, 定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* Legal values for sh_type (section type). */ #define SHT_NULL\t0\t/* Section header table entry unused */ #define SHT_PROGBITS\t1\t/* Program data */ #define SHT_SYMTAB\t2\t/* Symbol table */ #define SHT_STRTAB\t3\t/* String table */ #define SHT_RELA\t4\t/* Relocation entries with addends */ #define SHT_HASH\t5\t/* Symbol hash table */ #define SHT_DYNAMIC\t6\t/* Dynamic linking information */ #define SHT_NOTE\t7\t/* Notes */ #define SHT_NOBITS\t8\t/* Program space with no data (bss) */ #define SHT_REL\t9\t/* Relocation entries, no addends */ #define SHT_SHLIB\t10\t/* Reserved */ #define SHT_DYNSYM\t11\t/* Dynamic linker symbol table */ #define SHT_INIT_ARRAY\t14\t/* Array of constructors */ #define SHT_FINI_ARRAY\t15\t/* Array of destructors */ #define SHT_PREINIT_ARRAY 16\t/* Array of pre-constructors */ #define SHT_GROUP\t17\t/* Section group */ #define SHT_SYMTAB_SHNDX 18\t/* Extended section indices */ #define SHT_RELR\t19 /* RELR relative relocations */ #define\tSHT_NUM\t20\t/* Number of defined types. */ #define SHT_LOOS\t0x60000000\t/* Start OS-specific. */ #define SHT_GNU_ATTRIBUTES 0x6ffffff5\t/* Object attributes. */ #define SHT_GNU_HASH\t0x6ffffff6\t/* GNU-style hash table. */ #define SHT_GNU_LIBLIST\t0x6ffffff7\t/* Prelink library list */ #define SHT_CHECKSUM\t0x6ffffff8\t/* Checksum for DSO content. */ #define SHT_LOSUNW\t0x6ffffffa\t/* Sun-specific low bound. */ #define SHT_SUNW_move\t0x6ffffffa #define SHT_SUNW_COMDAT 0x6ffffffb #define SHT_SUNW_syminfo 0x6ffffffc #define SHT_GNU_verdef\t0x6ffffffd\t/* Version definition section. */ #define SHT_GNU_verneed\t0x6ffffffe\t/* Version needs section. */ #define SHT_GNU_versym\t0x6fffffff\t/* Version symbol table. */ #define SHT_HISUNW\t0x6fffffff\t/* Sun-specific high bound. */ #define SHT_HIOS\t0x6fffffff\t/* End OS-specific type */ #define SHT_LOPROC\t0x70000000\t/* Start of processor-specific */ #define SHT_HIPROC\t0x7fffffff\t/* End of processor-specific */ #define SHT_LOUSER\t0x80000000\t/* Start of application-specific */ #define SHT_HIUSER\t0x8fffffff\t/* End of application-specific */ 比较常见的节类型如下\n1 2 3 4 5 6 7 8 SHT_NULL //无效节 SHT_STRTAB //本节是字符串表 ELF文件可以有多个字符串表节 SHT_RELA //重定位节 SHT_HASH //表明本节包含一张哈希表 目前一个ELF文件最多只能有一张哈希表 SHT_DYNAMIC //表明本节包含动态链接信息 目前一个目标文件最多一个dynamic节 SHT_NOBITS //表明本节内容为空,不占用实际内存空间 SHT_REL //重定位节 SHT_DYNSYM //表明本节是符号表,同SHT_SYMTAB sh_flags 4字节,由一系列标志bit位组成\nSHF_WRITE 表示本节在进程中可写\nSHF_ALLOC 表示本节在运行中需要占用内存\n不是所有节都要占用实际内存,部分起控制作用的节在文件映射至内存时不需要占用\nSHF_EXECINSTR 表示本节的内容是指令代码\nSHF_MASKPROC 被该值覆盖的位都保留做特殊处理器扩展用\nsh_addr 4字节,节的内存虚拟地址\nsh_offset 4字节,节的FOA\nsh_size 4字节,段的大小\nsh_link 4字节,索引值\nsh_info 4字节,节的附加信息\n根据节类型不同,sh_info和sh_link有不同的含义\nsh_addralign 4字节,段地址对齐值,假如为0或者1表示该段没有对齐要求; 假如为3表示对齐2^3=8\n节的sh_addr必须能被sh_addralign整除,即sh_addr%sh_addralign=0\nsh_entsize 4字节,部分节的内容是一张表,每个表项的大小固定(例如符号表), 该字段指定其每个表项的大小\n为0则表示不是这些表\n打印节表头 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // Print ELF Section Headers char *getSectionTypeString(Elf_Word sectionType) { switch (sectionType) { case SHT_NULL: return \u0026#34;NULL\u0026#34;; case SHT_PROGBITS: return \u0026#34;PROGBITS\u0026#34;; case SHT_SYMTAB: return \u0026#34;SYMTAB\u0026#34;; case SHT_STRTAB: return \u0026#34;STRTAB\u0026#34;; case SHT_RELA: return \u0026#34;RELA\u0026#34;; case SHT_HASH: return \u0026#34;HASH\u0026#34;; case SHT_DYNAMIC: return \u0026#34;DYNAMIC\u0026#34;; case SHT_NOTE: return \u0026#34;NOTE\u0026#34;; case SHT_NOBITS: return \u0026#34;NOBITS\u0026#34;; case SHT_REL: return \u0026#34;REL\u0026#34;; case SHT_SHLIB: return \u0026#34;SHLIB\u0026#34;; case SHT_DYNSYM: return \u0026#34;DYNSYM\u0026#34;; case SHT_INIT_ARRAY: return \u0026#34;INIT_ARRAY\u0026#34;; case SHT_FINI_ARRAY: return \u0026#34;FINI_ARRAY\u0026#34;; case SHT_PREINIT_ARRAY: return \u0026#34;PREINIT_ARRAY\u0026#34;; case SHT_GROUP: return \u0026#34;GROUP\u0026#34;; case SHT_SYMTAB_SHNDX: return \u0026#34;SYMTAB_SHNDX\u0026#34;; case SHT_RELR: return \u0026#34;RELR\u0026#34;; case SHT_NUM: return \u0026#34;NUM\u0026#34;; case SHT_LOOS: return \u0026#34;LOOS\u0026#34;; case SHT_GNU_ATTRIBUTES: return \u0026#34;GNU_ATTRIBUTES\u0026#34;; case SHT_GNU_HASH: return \u0026#34;GNU_HASH\u0026#34;; case SHT_GNU_LIBLIST: return \u0026#34;GNU_LIBLIST\u0026#34;; case SHT_CHECKSUM: return \u0026#34;CHECKSUM\u0026#34;; case SHT_LOSUNW: return \u0026#34;LOSUNW\u0026#34;; case SHT_SUNW_COMDAT: return \u0026#34;SUNW_COMDAT\u0026#34;; case SHT_SUNW_syminfo: return \u0026#34;SUNW_syminfo\u0026#34;; case SHT_GNU_verdef: return \u0026#34;GNU_verdef\u0026#34;; case SHT_GNU_verneed: return \u0026#34;GNU_verneed\u0026#34;; case SHT_GNU_versym: return \u0026#34;GNU_versym\u0026#34;; case SHT_LOPROC: return \u0026#34;LOPROC\u0026#34;; case SHT_HIPROC: return \u0026#34;HIPROC\u0026#34;; case SHT_LOUSER: return \u0026#34;LOUSER\u0026#34;; case SHT_HIUSER: return \u0026#34;HIUSER\u0026#34;; default: return \u0026#34;UNKNOWN\u0026#34;; } } const char* getSectionFlagStr(Elf_Word flags) { switch (flags) { case SHF_ALLOC: return \u0026#34; A\u0026#34;; case SHF_WRITE: return \u0026#34; W\u0026#34;; case SHF_WRITE | SHF_ALLOC: return \u0026#34; WA\u0026#34;; case SHF_EXECINSTR: return \u0026#34; X\u0026#34;; case SHF_ALLOC | SHF_EXECINSTR: return \u0026#34; AX\u0026#34;; case SHF_MASKPROC: return \u0026#34;MKP\u0026#34;; default: return \u0026#34; \u0026#34;; } } void printElfSectionHeader32(const Elf32_Shdr* pSectionHeader,Elf_Half sectionNum,const char* pStringTable) { printf(\u0026#34;ELF Section Headers:\\n\u0026#34;); printf(\u0026#34;\\t[Nr] Name\\t\\t\\tType\\t\\t\\tAddr\\t\\tOffset\\t\\tSize\\t\\tEntSize\\tFlag\\tLink\\tInfo\\tAlign\\n\u0026#34;); for (int i = 0; i \u0026lt; sectionNum; i++) { printf(\u0026#34;\\t[%2d] %-20s\u0026#34;, i, (char *) \u0026amp;pStringTable[pSectionHeader[i].sh_name]); printf(\u0026#34;\\t%-16s\u0026#34;, getSectionTypeString(pSectionHeader[i].sh_type)); printf(\u0026#34;\\t%08x\u0026#34;, pSectionHeader[i].sh_addr); printf(\u0026#34;\\t%08x\u0026#34;, pSectionHeader[i].sh_offset); printf(\u0026#34;\\t%08x\u0026#34;, pSectionHeader[i].sh_size); printf(\u0026#34;\\t%x\u0026#34;, pSectionHeader[i].sh_entsize); printf(\u0026#34;\\t%s\u0026#34;, getSectionFlagStr(pSectionHeader[i].sh_flags)); printf(\u0026#34;\\t%x\u0026#34;, pSectionHeader[i].sh_link); printf(\u0026#34;\\t%x\u0026#34;, pSectionHeader[i].sh_info); printf(\u0026#34;\\t%x\\n\u0026#34;, pSectionHeader[i].sh_addralign); } printf(\u0026#34;ELF Section Headers End\\n\u0026#34;); } 打印结果如下\nProgram Header 程序头表用于描述ELF文件如何映射到内存中,用段(segment)表示\n定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 typedef struct { Elf32_Word\tp_type;\t/* Segment type */ Elf32_Off\tp_offset;\t/* Segment file offset */ Elf32_Addr\tp_vaddr;\t/* Segment virtual address */ Elf32_Addr\tp_paddr;\t/* Segment physical address */ Elf32_Word\tp_filesz;\t/* Segment size in file */ Elf32_Word\tp_memsz;\t/* Segment size in memory */ Elf32_Word\tp_flags;\t/* Segment flags */ Elf32_Word\tp_align;\t/* Segment alignment */ } Elf32_Phdr; typedef struct { Elf64_Word\tp_type;\t/* Segment type */ Elf64_Word\tp_flags;\t/* Segment flags */ Elf64_Off\tp_offset;\t/* Segment file offset */ Elf64_Addr\tp_vaddr;\t/* Segment virtual address */ Elf64_Addr\tp_paddr;\t/* Segment physical address */ Elf64_Xword\tp_filesz;\t/* Segment size in file */ Elf64_Xword\tp_memsz;\t/* Segment size in memory */ Elf64_Xword\tp_align;\t/* Segment alignment */ } Elf64_Phdr; p_type 指定了程序头描述的段类型(或如何解析本程序头的信息)\n段类型如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* Legal values for p_type (segment type). */ #define\tPT_NULL\t0\t/* Program header table entry unused */ #define PT_LOAD\t1\t/* Loadable program segment */ #define PT_DYNAMIC\t2\t/* Dynamic linking information */ #define PT_INTERP\t3\t/* Program interpreter */ #define PT_NOTE\t4\t/* Auxiliary information */ #define PT_SHLIB\t5\t/* Reserved */ #define PT_PHDR\t6\t/* Entry for header table itself */ #define PT_TLS\t7\t/* Thread-local storage segment */ #define\tPT_NUM\t8\t/* Number of defined types */ #define PT_LOOS\t0x60000000\t/* Start of OS-specific */ #define PT_GNU_EH_FRAME\t0x6474e550\t/* GCC .eh_frame_hdr segment */ #define PT_GNU_STACK\t0x6474e551\t/* Indicates stack executability */ #define PT_GNU_RELRO\t0x6474e552\t/* Read-only after relocation */ #define PT_GNU_PROPERTY\t0x6474e553\t/* GNU property */ #define PT_GNU_SFRAME\t0x6474e554\t/* SFrame segment. */ #define PT_LOSUNW\t0x6ffffffa #define PT_SUNWBSS\t0x6ffffffa\t/* Sun Specific segment */ #define PT_SUNWSTACK\t0x6ffffffb\t/* Stack segment */ #define PT_HISUNW\t0x6fffffff #define PT_HIOS\t0x6fffffff\t/* End of OS-specific */ #define PT_LOPROC\t0x70000000\t/* Start of processor-specific */ #define PT_HIPROC\t0x7fffffff\t/* End of processor-specific */ p_offset 段的文件偏移值\np_vaddr 段的内存虚拟地址\np_paddr 段的内存物理地址, 由于多数现代操作系统的设计不可预知段的物理地址,故该字段多数情况下保留\np_filesz 段的文件大小\np_memsz 段的内存大小\np_flags 段的属性\n1 2 3 4 5 6 7 /* Legal values for p_flags (segment flags). */ #define PF_X\t(1 \u0026lt;\u0026lt; 0)\t/* Segment is executable */ //可读 #define PF_W\t(1 \u0026lt;\u0026lt; 1)\t/* Segment is writable */\t//可写 #define PF_R\t(1 \u0026lt;\u0026lt; 2)\t/* Segment is readable */\t//可执行 #define PF_MASKOS\t0x0ff00000\t/* OS-specific */\t//系统指定 #define PF_MASKPROC\t0xf0000000\t/* Processor-specific */\t//进程指定 p_align 段的内存对齐值\n打印段表头 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 // Print ELF Program Headers const char *getSegmentTypeStr(Elf32_Word segmentType) { switch (segmentType) { case PT_NULL:return \u0026#34;NULL\u0026#34;; case PT_LOAD: return \u0026#34;LOAD\u0026#34;; case PT_DYNAMIC: return \u0026#34;DYNAMIC\u0026#34;; case PT_INTERP:return \u0026#34;INTERP\u0026#34;; case PT_NOTE: return \u0026#34;NOTE\u0026#34;; case PT_SHLIB:return \u0026#34;SHLIB\u0026#34;; case PT_PHDR: return \u0026#34;PHDR\u0026#34;; case PT_TLS:return \u0026#34;TLS\u0026#34;; case PT_NUM: return \u0026#34;PT_NUM\u0026#34;; case PT_LOOS:return \u0026#34;LOOS\u0026#34;; case PT_GNU_EH_FRAME: return \u0026#34;GNU_EH_FRAME\u0026#34;; case PT_GNU_STACK:return \u0026#34;GNU_STACK\u0026#34;; case PT_GNU_RELRO: return \u0026#34;GNU_RELRO\u0026#34;; case PT_GNU_PROPERTY: return \u0026#34;GNU_PROPERTY\u0026#34;; case PT_GNU_SFRAME: return \u0026#34;GNU_SFRAME\u0026#34;; case PT_SUNWBSS: return \u0026#34;SUNWBSS\u0026#34;; case PT_SUNWSTACK: return \u0026#34;SUNWSTACK\u0026#34;; case PT_HIOS: return \u0026#34;HIOS\u0026#34;; case PT_LOPROC: return \u0026#34;LOPROC\u0026#34;; case PT_HIPROC: return \u0026#34;HIPROC\u0026#34;; default: return \u0026#34;UNKNOWN\u0026#34;; } } const char* getSegmentFlagStr(Elf_Word segmentFlags) { static char segmentFlagStr[5] = \u0026#34; \u0026#34;; int count = 0; if (segmentFlags \u0026amp; PF_R) { segmentFlagStr[count++] = \u0026#39;R\u0026#39;; } if (segmentFlags \u0026amp; PF_W) { segmentFlagStr[count++] = \u0026#39;W\u0026#39;; } if (segmentFlags \u0026amp; PF_X) { segmentFlagStr[count++] = \u0026#39;X\u0026#39;; } return segmentFlagStr; } void printElfProgramHeader32(const Elf32_Phdr *pProgramHeader,Elf_Half segmentNum,const uint8_t* pFileBuffer) { printf(\u0026#34;ELF ProgramHeader:\\n\u0026#34;); printf(\u0026#34;\\t[Nr] Type\\t\\tFileOff\\t\\tVirAddr\\t\\tPhyAddr\\t\\tFileSize\\tMemSize\\t\\tFlag\\tAlign\\n\u0026#34;); for (int i = 0; i \u0026lt; segmentNum; i++) { printf(\u0026#34;\\t[%02d] %-16s\u0026#34;, i, getSegmentTypeStr(pProgramHeader[i].p_type)); printf(\u0026#34;\\t%08x\u0026#34;, pProgramHeader[i].p_offset); printf(\u0026#34;\\t%08x\u0026#34;, pProgramHeader[i].p_vaddr); printf(\u0026#34;\\t%08x\u0026#34;, pProgramHeader[i].p_paddr); printf(\u0026#34;\\t%08x\u0026#34;, pProgramHeader[i].p_filesz); printf(\u0026#34;\\t%08x\u0026#34;, pProgramHeader[i].p_memsz); printf(\u0026#34;\\t%#4s\u0026#34;, getSegmentFlagStr(pProgramHeader[i].p_flags)); printf(\u0026#34;\\t%#x\\n\u0026#34;, pProgramHeader[i].p_align); if (pProgramHeader[i].p_type == PT_INTERP) { printf(\u0026#34;\\t\\t [Request Program Interpreter Path: %s]\\n\u0026#34;,(char *) (pFileBuffer + pProgramHeader[i].p_offset)); } } printf(\u0026#34;ELF ProgramHeader End\\n\u0026#34;); } // print segment mapping void printSectionToSegmentMapping32(const Elf32_Phdr* pProgramHeader,const Elf32_Shdr* pSectionHeader,Elf_Half segmentNum,Elf_Half sectionNum,const char* pSectionHeaderStringTable) { printf(\u0026#34;Segtion to Segment Mapping:\\n\u0026#34;); printf(\u0026#34;\\tSegment\\tSections\\n\u0026#34;); //Traverse program headers for (int i = 0; i \u0026lt; segmentNum; i++) { Elf32_Addr segmentStartAddr = pProgramHeader[i].p_vaddr; Elf32_Addr segmentEndAddr = segmentStartAddr + pProgramHeader[i].p_memsz; printf(\u0026#34;\\t%02d\\t\\t\u0026#34;, i); //Traverse section headers for (int j = 0; j \u0026lt; sectionNum; j++) { Elf32_Addr sectionStartAddr = pSectionHeader[j].sh_addr; //Check whether the start addr of a section is in the segment addr if (sectionStartAddr \u0026gt;= segmentStartAddr \u0026amp;\u0026amp; sectionStartAddr \u0026lt; segmentEndAddr) { //SHF_ALLOC means need alloc memory, some control sections don\u0026#39;t need mapping to memory if (pSectionHeader[j].sh_flags \u0026amp; SHF_ALLOC) { printf(\u0026#34;%s \u0026#34;,(char *) pSectionHeaderStringTable + pSectionHeader[j].sh_name); } } } printf(\u0026#34;\\n\u0026#34;); } } 打印结果如下\n特殊节 ELF 文件中有一些特定的节是预定义好的，其内容是指令代码或者控制信息\n这些节专门为操作系统使用，对于不同的操作系统，这些节的类型和属性有所不同\n节名 作用 .text 代码段 .data 保存已经初始化的全局变量和局部静态变量 .bss 保存未初始化的全局变量和局部静态变量 .rodata 存放只读数据, 例如常量字符串 .comment 编译器版本信息 .debug 调试信息 .dynamic 动态链接信息, linker解析该段以加载elf文件 .hash 符号哈希表 (可查导入和导出符号) .gnu.hash GNU哈希表 (只可查导出符号,导出表) .line 调试行号表 即源代码行号与编译后指令的对应表 .note 额外的编译器信息 例如公司名,版本号 .rel.dyn 动态链接重定位表 存放全局变量重定位项 .rel.plt 动态链接函数跳转重定位表 存放plt重定位项 .symtab 符号表 .dynsym 动态链接符号表 .strtab 字符串表 .shstrtab 节名表 .dynstr 动态链接字符串表 .plt 动态链接跳转表 .got 动态链接全局偏移表 .init 程序初始化代码段(节) .fini 程序结束代码段(节) String Table ELF文件中有很多字符串,例如段名,变量名等, 由于字符串长度往往不固定,所以使用固定结构描述比较困难\n常见做法是将字符串集中起来存放到一张字符串表,然后通过索引查表来引用字符串\n常见的有:\n.strtab(字符串表,保存普通字符串)\n遍历section header, 查找type==SHT_STRTAB的即为字符串表 (包括段表字符串表)\n.shstrtab(段表字符串表,保存段表用到的字符串)\n获取该表可以通过ELF Header的e_shstrndx成员做索引,查找ELF Section Header Table\n即p_shstrtab=ELFSectionHeaderTable[ELFHeader.e_shstrndx]\n打印代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Print String Table void printStringTable32(const Elf32_Shdr* pSectionHeader,Elf_Half sectionNum,const char* pSectionHeaderStringTable,const uint8_t* pFileBuffer) { //Traverse the section header table then find string table printf(\u0026#34;ELF String Table:\\n\u0026#34;); for (int i = 0; i \u0026lt; sectionNum; i++) { //not only just one string table such as .dynstr .strtab if (pSectionHeader[i].sh_type == SHT_STRTAB) { printf(\u0026#34;\\t==========String Table %s==========\\n\u0026#34;,getSectionName(pSectionHeaderStringTable,pSectionHeader[i].sh_name)); char *pStringTable = (char *) (pFileBuffer + pSectionHeader[i].sh_offset); Elf32_Word stringTableSize = pSectionHeader[i].sh_size, pos = 0; //遍历字符串表, 遇到0时pos+1打印字符串, 非0时继续搜索 while (pos \u0026lt; stringTableSize) { if (pStringTable[pos] == 0) { pos += 1; printf(\u0026#34;\\t%s\\n\u0026#34;, pStringTable + pos); } else { //find zero while (pStringTable[pos] != 0) { pos++; } } } } } printf(\u0026#34;ELF String Table End\\n\u0026#34;); } Symbol Table 符号表的作用是描述导入和导出符号,这里的符号可以是全局变量,函数,外部引用等\n通过符号表和对应的字符串表可以得到符号名,符号大小,符号地址等信息\n1 2 3 4 5 .dynsym //动态链接符号表 .symtab //符号表 .dynstr //动态链接符号表的字符串表 .strtab //符号表的字符串表 符号表表项结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 typedef struct { Elf32_Word\tst_name;\t/* Symbol name (string tbl index) */ Elf32_Addr\tst_value;\t/* Symbol value */ Elf32_Word\tst_size;\t/* Symbol size */ unsigned char\tst_info;\t/* Symbol type and binding */ unsigned char\tst_other;\t/* Symbol visibility */ Elf32_Section\tst_shndx;\t/* Section index */ } Elf32_Sym; typedef struct { Elf64_Word\tst_name;\t/* Symbol name (string tbl index) */ unsigned char\tst_info;\t/* Symbol type and binding */ unsigned char st_other;\t/* Symbol visibility */ Elf64_Section\tst_shndx;\t/* Section index */ Elf64_Addr\tst_value;\t/* Symbol value */ Elf64_Xword\tst_size;\t/* Symbol size */ } Elf64_Sym; st_name 符号名, 字符串表的索引下标, 节表的sh_link说明了是在哪个字符串表中\nst_value 符号对应的值, 和符号有关, 可能是绝对值,也可能是一个地址, 不同符号的含义不同\nst_size 符号大小, 对于包含数据的符号, 是该数据类型的大小\n例如一个double型的符号占用8字节,如果该值为0表示符号大小为0或未知\nst_info 符号的类型和属性,高4bit标识了符号绑定(symbol binding), 低4bit标识了符号类型(symbol type),组成符号信息(symbol information)\n有3个宏分别读取这三个属性值\n1 2 3 4 5 /* How to extract and insert information held in the st_info field. */ #define ELF32_ST_BIND(val)\t(((unsigned char) (val)) \u0026gt;\u0026gt; 4) #define ELF32_ST_TYPE(val)\t((val) \u0026amp; 0xf) #define ELF32_ST_INFO(bind, type)\t(((bind) \u0026lt;\u0026lt; 4) + ((type) \u0026amp; 0xf)) Symbol Binding 符号绑定的合法属性如下\n1 2 3 4 5 6 7 8 9 10 11 /* Legal values for ST_BIND subfield of st_info (symbol binding). */ #define STB_LOCAL\t0\t/* Local symbol */ #define STB_GLOBAL\t1\t/* Global symbol */ #define STB_WEAK\t2\t/* Weak symbol */ #define\tSTB_NUM\t3\t/* Number of defined types. */ #define STB_LOOS\t10\t/* Start of OS-specific */ #define STB_GNU_UNIQUE\t10\t/* Unique symbol. */ #define STB_HIOS\t12\t/* End of OS-specific */ #define STB_LOPROC\t13\t/* Start of processor-specific */ #define STB_HIPROC\t15\t/* End of processor-specific */ 几个重要属性解释如下:\nSTB_LOCAL\n该符号是本地符号,只出现在本文件中,在其他文件中无效\n所以在不同文件中可以定义相同的符号名,不会互相影响\nSTB_GLOBAL\n该符号是全局符号,当有多个文件被链接在一起时,在所有文件中该符号都是可见的\n所以在一个文件中定义的全局符号,一定是在其他文件中需要被引用,否则无需定义为全局\nSTB_WEAK\n弱符号,类似于全局符号,但优先级比global更低\nSTB_LOPROC~STB_HIPROC\n为特殊处理器保留\nSymbol Type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* Legal values for ST_TYPE subfield of st_info (symbol type). */ #define STT_NOTYPE\t0\t/* Symbol type is unspecified */ #define STT_OBJECT\t1\t/* Symbol is a data object */ #define STT_FUNC\t2\t/* Symbol is a code object */ #define STT_SECTION\t3\t/* Symbol associated with a section */ #define STT_FILE\t4\t/* Symbol\u0026#39;s name is file name */ #define STT_COMMON\t5\t/* Symbol is a common data object */ #define STT_TLS\t6\t/* Symbol is thread-local data object*/ #define\tSTT_NUM\t7\t/* Number of defined types. */ #define STT_LOOS\t10\t/* Start of OS-specific */ #define STT_GNU_IFUNC\t10\t/* Symbol is indirect code object */ #define STT_HIOS\t12\t/* End of OS-specific */ #define STT_LOPROC\t13\t/* Start of processor-specific */ #define STT_HIPROC\t15\t/* End of processor-specific */ 几个重要符号解析如下\nSTT_NOTYPE\n该符号类型未指定\nSTT_OBJECT\n该符号是一个数据对象,例如变量,数组等\nSTT_FUNC\n该符号是一个函数,或者其他的可执行代码\nSTT_SECTION\n该符号和一个节相关联,用于重定位,通常具有STB_LOCAL属性\nSTT_FILE\n该符号是一个文件符号,具有STB_LOCAL属性\nSTT_LOPROC~STT_HIPROC\n为特殊处理器保留\nst_other 低2位保存了符号可见性\nst_shndx 符号所在的段\n打印符号表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 // Print Symbol Table const char *getSymbolBindingString(uint8_t symbolBinding) { switch (symbolBinding) { case STB_LOCAL: return \u0026#34;LOCAL\u0026#34;; case STB_GLOBAL: return \u0026#34;GLOBAL\u0026#34;; case STB_WEAK: return \u0026#34;WEAK\u0026#34;; case STB_NUM: return \u0026#34;STB_NUM\u0026#34;; case STB_GNU_UNIQUE: return \u0026#34;GNU_UNIQUE\u0026#34;; case STB_HIOS: return \u0026#34;STB_HIOS\u0026#34;; case STB_LOPROC: return \u0026#34;STB_LOPROC\u0026#34;; case STB_HIPROC: return \u0026#34;STB_HIPROC\u0026#34;; default: return \u0026#34;UNKNOWN\u0026#34;; } } const char *getSymbolTypeString(uint8_t symbolType) { switch (symbolType) { case STT_NOTYPE: return \u0026#34;NOTYPE\u0026#34;; case STT_OBJECT: return \u0026#34;OBJECT\u0026#34;; case STT_FUNC: return \u0026#34;FUNC\u0026#34;; case STT_SECTION: return \u0026#34;SECTION\u0026#34;; case STT_FILE: return \u0026#34;FILE\u0026#34;; case STT_COMMON: return \u0026#34;COMMON\u0026#34;; case STT_TLS: return \u0026#34;TLS\u0026#34;; case STT_NUM: return \u0026#34;STT_NUM\u0026#34;; case STT_GNU_IFUNC: return \u0026#34;GNU_IFUNC\u0026#34;; case STT_HIOS: return \u0026#34;HIOS\u0026#34;; case STT_LOPROC: return \u0026#34;LOPROC\u0026#34;; case STT_HIPROC: return \u0026#34;HIPROC\u0026#34;; default: return \u0026#34;UNKNOWN\u0026#34;; } } const char *getSymbolVisibility(uint8_t st_other) { unsigned char visibility = st_other \u0026amp; 0x03; switch (visibility) { case 0: return \u0026#34;DEFAULT\u0026#34;; case 1: return \u0026#34;INTERNAL\u0026#34;; case 2: return \u0026#34;HIDDEN\u0026#34;; case 3: return \u0026#34;PROTECTED\u0026#34;; default: return \u0026#34;UNKNOWN\u0026#34;; } } void printSymbolTable32(const Elf32_Shdr* pSectionHeader,Elf_Half sectionNum,const char* pSectionHeaderStringTable,const uint8_t* pFileBuffer) { printf(\u0026#34;ELF Symbol Tables:\\n\u0026#34;); for (int i = 0; i \u0026lt; sectionNum; i++) { //全局静态符号表和动态符号表 if (pSectionHeader[i].sh_type == SHT_SYMTAB || pSectionHeader[i].sh_type == SHT_DYNSYM) { Elf32_Word symbolNum = pSectionHeader[i].sh_size / pSectionHeader[i].sh_entsize; //获取符号表对应的字符串表,全局静态符号和动态符号表对应字符串表可能不同 sh_link is index of string table, fileBuffer+offset is real string table char* pSymbolNameTable =(char*) pFileBuffer + pSectionHeader[pSectionHeader[i].sh_link].sh_offset; printf(\u0026#34;\\tSymbol Table \u0026#39;%s\u0026#39; contains %#x entries:\\n\u0026#34;,(char*)getSectionName(pSectionHeaderStringTable,pSectionHeader[i].sh_name), symbolNum); printf(\u0026#34;\\tNum \\tValue\\t\\tSize\\t\\tType\\t\\tBind\\t\\tVisible\\t\\tIndex\\t\\tName\\n\u0026#34;); Elf32_Sym *pSymbolTable = (Elf32_Sym *) (pFileBuffer + pSectionHeader[i].sh_offset); for (int j = 0; j \u0026lt; symbolNum; j++) { printf(\u0026#34;\\t%04d\u0026#34;, j); printf(\u0026#34;\\t%08x\u0026#34;, pSymbolTable[j].st_value); printf(\u0026#34;\\t%08x\u0026#34;, pSymbolTable[j].st_size); //symbol type and binding printf(\u0026#34;\\t%s\\t\u0026#34;, getSymbolTypeString(ELF32_ST_TYPE(pSymbolTable[j].st_info))); printf(\u0026#34;\\t%s\\t\u0026#34;, getSymbolBindingString(ELF32_ST_BIND(pSymbolTable[j].st_info))); printf(\u0026#34;\\t%-10s\u0026#34;, getSymbolVisibility(pSymbolTable[j].st_other)); if (pSymbolTable[j].st_shndx == SHN_UNDEF) { printf(\u0026#34;\\t%4s\\t\u0026#34;, \u0026#34;UDEF\u0026#34;); } else if (pSymbolTable[j].st_shndx == SHN_ABS) { printf(\u0026#34;\\t%4s\\t\u0026#34;, \u0026#34;ABS\u0026#34;); } else { printf(\u0026#34;\\t%04x\\t\u0026#34;, pSymbolTable[j].st_shndx); } printf(\u0026#34;\\t%s\\n\u0026#34;, pSymbolNameTable + pSymbolTable[j].st_name); } printf(\u0026#34;\\n\u0026#34;); } } } Relocation Table 一般有两张重定位表:\n.rel.plt 修复外部函数地址\n.rel.dyn 修复全局变量地址\n重定位表有SHT_REL, SHT_RELA, SHT_RELR三种类型,对应表项定义如下\n注: Intel x86架构只使用REL重定位项, x64架构似乎只使用RELA重定位项, 在后续修复重定位表可以得知\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* Relocation table entry without addend (in section of type SHT_REL). */ typedef struct { Elf32_Addr\tr_offset;\t/* Address */ Elf32_Word\tr_info;\t/* Relocation type and symbol index */ } Elf32_Rel; typedef struct { Elf64_Addr\tr_offset;\t/* Address */ Elf64_Xword\tr_info;\t/* Relocation type and symbol index */ } Elf64_Rel; /* Relocation table entry with addend (in section of type SHT_RELA). */ typedef struct { Elf32_Addr\tr_offset;\t/* Address */ Elf32_Word\tr_info;\t/* Relocation type and symbol index */ Elf32_Sword\tr_addend;\t/* Addend */ } Elf32_Rela; typedef struct { Elf64_Addr\tr_offset;\t/* Address */ Elf64_Xword\tr_info;\t/* Relocation type and symbol index */ Elf64_Sxword\tr_addend;\t/* Addend */ } Elf64_Rela; /* RELR relocation table entry */ typedef Elf32_Word\tElf32_Relr; typedef Elf64_Xword\tElf64_Relr; r_offset 重定位的位置\n对于重定位文件而言,该值是待重定位单元在节中的偏移量\n对于可执行文件或链接库文件而言,该值是待重定位单元的虚拟地址\nr_info 给出了待重定位单元的符号表索引和重定位类型\n获取信息的宏\nSYM获取高24/32位, 是符号表索引, 指明符号\nTYPE获取低8/32位, 是重定位类型\n1 2 3 4 5 6 7 8 9 /* How to extract and insert information held in the r_info field. */ #define ELF32_R_SYM(val)\t((val) \u0026gt;\u0026gt; 8) #define ELF32_R_TYPE(val)\t((val) \u0026amp; 0xff) #define ELF32_R_INFO(sym, type)\t(((sym) \u0026lt;\u0026lt; 8) + ((type) \u0026amp; 0xff)) #define ELF64_R_SYM(i)\t((i) \u0026gt;\u0026gt; 32) #define ELF64_R_TYPE(i)\t((i) \u0026amp; 0xffffffff) #define ELF64_R_INFO(sym,type)\t((((Elf64_Xword) (sym)) \u0026lt;\u0026lt; 32) + (type)) r_addend 指定加数,用于计算需要重定位的域的值\nRela使用该字段显式地指出加数,Rel的加数隐含在被修改的位置中\n一个重定位节(Relocation Section)需要引用另外两个节: 符号表和待修复节\n重定位节节头的sh_info和sh_link分别指明了引用关系\n不同目标文件中,重定位项的r_offset成员含义略有不同\n重定位文件\nr_offset指向待修改节的重定位单元偏移地址\n可执行文件/共享目标文件\nr_offset指向待修改单元的虚拟地址\n重定位类型 重定位项用于描述如何修改以下的指令和数据域(被重定位域)\n定义以下几种运算符号便于描述\n常见重定位类型如下\nR_386_GOT_DAT 将指定的符号地址设置为一个GOT表项\n修复方法: elf加载后, 填入符号对应真实地址\nR_386_JMP_SLOT 用于动态链接的PLT表项\n修复方法: elf加载后, 修改跳转地址为符号地址\nR_386_RELATIVE 相对偏移地址重定位\n修复方法: 将offset指出的位置解引用,加上elf加载的基地址\n全部的intel x86架构重定位类型如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 /* Intel 80386 specific definitions. */ /* i386 relocs. */ #define R_386_NONE\t0\t/* No reloc */ #define R_386_32\t1\t/* Direct 32 bit */ #define R_386_PC32\t2\t/* PC relative 32 bit */ #define R_386_GOT32\t3\t/* 32 bit GOT entry */ #define R_386_PLT32\t4\t/* 32 bit PLT address */ #define R_386_COPY\t5\t/* Copy symbol at runtime */ #define R_386_GLOB_DAT\t6\t/* Create GOT entry */ #define R_386_JMP_SLOT\t7\t/* Create PLT entry */ #define R_386_RELATIVE\t8\t/* Adjust by program base */ #define R_386_GOTOFF\t9\t/* 32 bit offset to GOT */ #define R_386_GOTPC\t10\t/* 32 bit PC relative offset to GOT */ #define R_386_32PLT\t11 #define R_386_TLS_TPOFF\t14\t/* Offset in static TLS block */ #define R_386_TLS_IE\t15\t/* Address of GOT entry for static TLS block offset */ #define R_386_TLS_GOTIE\t16\t/* GOT entry for static TLS block offset */ #define R_386_TLS_LE\t17\t/* Offset relative to static TLS block */ #define R_386_TLS_GD\t18\t/* Direct 32 bit for GNU version of general dynamic thread local data */ #define R_386_TLS_LDM\t19\t/* Direct 32 bit for GNU version of local dynamic thread local data in LE code */ #define R_386_16\t20 #define R_386_PC16\t21 #define R_386_8\t22 #define R_386_PC8\t23 #define R_386_TLS_GD_32\t24\t/* Direct 32 bit for general dynamic thread local data */ #define R_386_TLS_GD_PUSH 25\t/* Tag for pushl in GD TLS code */ #define R_386_TLS_GD_CALL 26\t/* Relocation for call to __tls_get_addr() */ #define R_386_TLS_GD_POP 27\t/* Tag for popl in GD TLS code */ #define R_386_TLS_LDM_32 28\t/* Direct 32 bit for local dynamic thread local data in LE code */ #define R_386_TLS_LDM_PUSH 29\t/* Tag for pushl in LDM TLS code */ #define R_386_TLS_LDM_CALL 30\t/* Relocation for call to __tls_get_addr() in LDM code */ #define R_386_TLS_LDM_POP 31\t/* Tag for popl in LDM TLS code */ #define R_386_TLS_LDO_32 32\t/* Offset relative to TLS block */ #define R_386_TLS_IE_32\t33\t/* GOT entry for negated static TLS block offset */ #define R_386_TLS_LE_32\t34\t/* Negated offset relative to static TLS block */ #define R_386_TLS_DTPMOD32 35\t/* ID of module containing symbol */ #define R_386_TLS_DTPOFF32 36\t/* Offset in TLS block */ #define R_386_TLS_TPOFF32 37\t/* Negated offset in static TLS block */ #define R_386_SIZE32\t38 /* 32-bit symbol size */ #define R_386_TLS_GOTDESC 39\t/* GOT offset for TLS descriptor. */ #define R_386_TLS_DESC_CALL 40\t/* Marker of call through TLS descriptor for relaxation. */ #define R_386_TLS_DESC 41\t/* TLS descriptor containing pointer to code and to argument, returning the TLS offset for the symbol. */ #define R_386_IRELATIVE\t42\t/* Adjust indirectly by program base */ #define R_386_GOT32X\t43\t/* Load from 32 bit GOT entry, relaxable. */ /* Keep this the last entry. */ #define R_386_NUM\t44 x64重定位类型定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 /* AMD x86-64 relocations. */ #define R_X86_64_NONE\t0\t/* No reloc */ #define R_X86_64_64\t1\t/* Direct 64 bit */ #define R_X86_64_PC32\t2\t/* PC relative 32 bit signed */ #define R_X86_64_GOT32\t3\t/* 32 bit GOT entry */ #define R_X86_64_PLT32\t4\t/* 32 bit PLT address */ #define R_X86_64_COPY\t5\t/* Copy symbol at runtime */ #define R_X86_64_GLOB_DAT\t6\t/* Create GOT entry */ #define R_X86_64_JUMP_SLOT\t7\t/* Create PLT entry */ #define R_X86_64_RELATIVE\t8\t/* Adjust by program base */ #define R_X86_64_GOTPCREL\t9\t/* 32 bit signed PC relative offset to GOT */ #define R_X86_64_32\t10\t/* Direct 32 bit zero extended */ #define R_X86_64_32S\t11\t/* Direct 32 bit sign extended */ #define R_X86_64_16\t12\t/* Direct 16 bit zero extended */ #define R_X86_64_PC16\t13\t/* 16 bit sign extended pc relative */ #define R_X86_64_8\t14\t/* Direct 8 bit sign extended */ #define R_X86_64_PC8\t15\t/* 8 bit sign extended pc relative */ #define R_X86_64_DTPMOD64\t16\t/* ID of module containing symbol */ #define R_X86_64_DTPOFF64\t17\t/* Offset in module\u0026#39;s TLS block */ #define R_X86_64_TPOFF64\t18\t/* Offset in initial TLS block */ #define R_X86_64_TLSGD\t19\t/* 32 bit signed PC relative offset to two GOT entries for GD symbol */ #define R_X86_64_TLSLD\t20\t/* 32 bit signed PC relative offset to two GOT entries for LD symbol */ #define R_X86_64_DTPOFF32\t21\t/* Offset in TLS block */ #define R_X86_64_GOTTPOFF\t22\t/* 32 bit signed PC relative offset to GOT entry for IE symbol */ #define R_X86_64_TPOFF32\t23\t/* Offset in initial TLS block */ #define R_X86_64_PC64\t24\t/* PC relative 64 bit */ #define R_X86_64_GOTOFF64\t25\t/* 64 bit offset to GOT */ #define R_X86_64_GOTPC32\t26\t/* 32 bit signed pc relative offset to GOT */ #define R_X86_64_GOT64\t27\t/* 64-bit GOT entry offset */ #define R_X86_64_GOTPCREL64\t28\t/* 64-bit PC relative offset to GOT entry */ #define R_X86_64_GOTPC64\t29\t/* 64-bit PC relative offset to GOT */ #define R_X86_64_GOTPLT64\t30 /* like GOT64, says PLT entry needed */ #define R_X86_64_PLTOFF64\t31\t/* 64-bit GOT relative offset to PLT entry */ #define R_X86_64_SIZE32\t32\t/* Size of symbol plus 32-bit addend */ #define R_X86_64_SIZE64\t33\t/* Size of symbol plus 64-bit addend */ #define R_X86_64_GOTPC32_TLSDESC 34\t/* GOT offset for TLS descriptor. */ #define R_X86_64_TLSDESC_CALL 35\t/* Marker for call through TLS descriptor. */ #define R_X86_64_TLSDESC 36\t/* TLS descriptor. */ #define R_X86_64_IRELATIVE\t37\t/* Adjust indirectly by program base */ #define R_X86_64_RELATIVE64\t38\t/* 64-bit adjust by program base */ /* 39 Reserved was R_X86_64_PC32_BND */ /* 40 Reserved was R_X86_64_PLT32_BND */ #define R_X86_64_GOTPCRELX\t41\t/* Load from 32 bit signed pc relative offset to GOT entry without REX prefix, relaxable. */ #define R_X86_64_REX_GOTPCRELX\t42\t/* Load from 32 bit signed pc relative offset to GOT entry with REX prefix, relaxable. */ #define R_X86_64_NUM\t43 打印重定位表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // Print Relocation Table const char *getRelocationTypeString32(Elf_Word value) { switch (value) { case R_386_NONE: return \u0026#34;R_386_NONE\u0026#34;; case 1: return \u0026#34;R_386_32\u0026#34;; case 2: return \u0026#34;R_386_PC32\u0026#34;; case 3: return \u0026#34;R_386_GOT32\u0026#34;; case 4: return \u0026#34;R_386_PLT32\u0026#34;; case 5: return \u0026#34;R_386_COPY\u0026#34;; case 6: return \u0026#34;R_386_GLOB_DAT\u0026#34;; case 7: return \u0026#34;R_386_JMP_SLOT\u0026#34;; case 8: return \u0026#34;R_386_RELATIVE\u0026#34;; case 9: return \u0026#34;R_386_GOTOFF\u0026#34;; case 10: return \u0026#34;R_386_GOTPC\u0026#34;; case 11: return \u0026#34;R_386_32PLT\u0026#34;; case 14: return \u0026#34;R_386_TLS_TPOFF\u0026#34;; case 15: return \u0026#34;R_386_TLS_IE\u0026#34;; case 16: return \u0026#34;R_386_TLS_GOTIE\u0026#34;; case 17: return \u0026#34;R_386_TLS_LE\u0026#34;; case 18: return \u0026#34;R_386_TLS_GD\u0026#34;; case 19: return \u0026#34;R_386_TLS_LDM\u0026#34;; case 20: return \u0026#34;R_386_16\u0026#34;; case 21: return \u0026#34;R_386_PC16\u0026#34;; case 22: return \u0026#34;R_386_8\u0026#34;; case 23: return \u0026#34;R_386_PC8\u0026#34;; case 24: return \u0026#34;R_386_TLS_GD_32\u0026#34;; case 25: return \u0026#34;R_386_TLS_GD_PUSH\u0026#34;; case 26: return \u0026#34;R_386_TLS_GD_CALL\u0026#34;; case 27: return \u0026#34;R_386_TLS_GD_POP\u0026#34;; case 28: return \u0026#34;R_386_TLS_LDM_32\u0026#34;; case 29: return \u0026#34;R_386_TLS_LDM_PUSH\u0026#34;; case 30: return \u0026#34;R_386_TLS_LDM_CALL\u0026#34;; case 31: return \u0026#34;R_386_TLS_LDM_POP\u0026#34;; case 32: return \u0026#34;R_386_TLS_LDO_32\u0026#34;; case 33: return \u0026#34;R_386_TLS_IE_32\u0026#34;; case 34: return \u0026#34;R_386_TLS_LE_32\u0026#34;; case 35: return \u0026#34;R_386_TLS_DTPMOD32\u0026#34;; case 36: return \u0026#34;R_386_TLS_DTPOFF32\u0026#34;; case 37: return \u0026#34;R_386_TLS_TPOFF32\u0026#34;; case 38: return \u0026#34;R_386_SIZE32\u0026#34;; case 39: return \u0026#34;R_386_TLS_GOTDESC\u0026#34;; case 40: return \u0026#34;R_386_TLS_DESC_CALL\u0026#34;; case 41: return \u0026#34;R_386_TLS_DESC\u0026#34;; case 42: return \u0026#34;R_386_IRELATIVE\u0026#34;; case 43: return \u0026#34;R_386_GOT32X\u0026#34;; default: return \u0026#34;Unknown relocation type\u0026#34;; } } void printRelocationTable32(const Elf32_Shdr* pSectionHeader,Elf_Half sectionNum,uint8_t* pFileBuffer,const char* pSectionHeaderStringTable) { printf(\u0026#34;Relocation Tables:\\n\u0026#34;); for (int i = 0; i \u0026lt; sectionNum; i++) { if (pSectionHeader[i].sh_type == SHT_REL) { Elf32_Shdr *pRelocationTableHeader = \u0026amp;pSectionHeader[i]; Elf32_Rel *pRelocationTable = (Elf32_Rel *) (pFileBuffer + pRelocationTableHeader-\u0026gt;sh_offset); Elf32_Word relocItemNum = pRelocationTableHeader-\u0026gt;sh_size / pRelocationTableHeader-\u0026gt;sh_entsize; // relocation table sh_link is index of symbol table header Elf32_Shdr *pSymbolTableHeader = (Elf32_Shdr *) \u0026amp;pSectionHeader[pSectionHeader[i].sh_link]; //real symbol table Elf32_Sym *pSymbolTable = (Elf32_Sym *) (pFileBuffer + pSymbolTableHeader-\u0026gt;sh_offset); //string table for symbol name char *pSymbolTableStringTable = (char *) pFileBuffer + pSectionHeader[pSymbolTableHeader-\u0026gt;sh_link].sh_offset; printf(\u0026#34;Relocation Section \u0026#39;%s\u0026#39; at offset contains %d entries\\n\u0026#34;,(char*) pSectionHeaderStringTable + pSectionHeader[i].sh_name, relocItemNum); printf(\u0026#34;\\tOffset\\t\\tInfo\\t\\tType\\t\\t\\t\\tSym.value\\t\\tSym.name\\n\u0026#34;); for (int j = 0; j \u0026lt; relocItemNum; j++) { printf(\u0026#34;\\t%08x\u0026#34;, pRelocationTable[j].r_offset); printf(\u0026#34;\\t%08x\u0026#34;, pRelocationTable[j].r_info); printf(\u0026#34;\\t%s\\t\u0026#34;, getRelocationTypeString32(ELF32_R_TYPE(pRelocationTable[j].r_info))); printf(\u0026#34;\\t%08x\\t\u0026#34;, pSymbolTable[ELF32_R_SYM(pRelocationTable[j].r_info)].st_value); //R_SYM get the index of symbol in symbol table, st_name is index of symbol name in string table printf(\u0026#34;\\t%s\u0026#34;, \u0026amp;pSymbolTableStringTable[pSymbolTable[ELF32_R_SYM(pRelocationTable[j].r_info)].st_name]); printf(\u0026#34;\\n\u0026#34;); } } } } 修复重定位表 r_offset指定了待修复的地址,这是一个RVA, 需要将该地址存储的数据加上elf文件加载的基地址\n例如readelf读取的重定位表信息如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Relocation section \u0026#39;.rel.dyn\u0026#39; at offset 0x384 contains 8 entries: Offset Info Type Sym.Value Sym. Name 00003ee8 00000008 R_386_RELATIVE 00003eec 00000008 R_386_RELATIVE 00003fec 00000008 R_386_RELATIVE 0000400c 00000008 R_386_RELATIVE 00003fe0 00000206 R_386_GLOB_DAT 00000000 _ITM_deregisterTM[...] 00003fe4 00000306 R_386_GLOB_DAT 00000000 __cxa_finalize@GLIBC_2.1.3 00003fe8 00000506 R_386_GLOB_DAT 00000000 __gmon_start__ 00003ff0 00000606 R_386_GLOB_DAT 00000000 _ITM_registerTMCl[...] Relocation section \u0026#39;.rel.plt\u0026#39; at offset 0x3c4 contains 2 entries: Offset Info Type Sym.Value Sym. Name 00004000 00000107 R_386_JUMP_SLOT 00000000 __libc_start_main@GLIBC_2.34 00004004 00000407 R_386_JUMP_SLOT 00000000 puts@GLIBC_2.0 No processor specific unwind information to decode 3ee8和3eec分别在init_array和fini_array段,均为RELATIVE类型重定位项\n3fec, 3fe0,3fe4,3fe8,3ff0是GOT表项, 其中3fec (main_ptr) 是RELATIVE类型,其他均为GLOB_DAT类型\n表项填充的函数为虚拟extern段中函数的地址,该段在内存中实际不存在\n4000,4004是plt表项, 均为JUMP_SLOT类型, 400c是dso_handle, 为RELATIVE类型\ngot.plt表填充的也是外部函数地址,在虚拟extern段\n在elf文件末尾,ida自动追加extern段(该段在内存中不存在,仅供分析)\n综上所述,重定位有以下情况:\n将待重定位地址处的内容解引用并加上elf加载的基地址即可\n这种情况是针对elf文件内部变量绝对地址引用需要修复\n例如RELATIVE类型\n加载动态库,写入外部函数地址\n针对外部引用地址修复\n例如GLOB_DAT和JUMP_SLOT类型\nDynamic Segment 如果目标文件参与动态链接,必定包含一个类型为 PT_DYNAMIC 的Program表项, 对应节名为 .dynamic (type=SHT_DYNAMIC)\n动态段的作用是提供动态链接器所需要的信息,比如依赖哪些共享库文件,动态链接符号表的位置,动态链接重定位表的位置等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Dynamic section entry. */ typedef struct { Elf32_Sword\td_tag;\t/* Dynamic entry type */ union { Elf32_Word d_val;\t/* Integer value */ Elf32_Addr d_ptr;\t/* Address value */ } d_un; } Elf32_Dyn; typedef struct { Elf64_Sxword\td_tag;\t/* Dynamic entry type */ union { Elf64_Xword d_val;\t/* Integer value */ Elf64_Addr d_ptr;\t/* Address value */ } d_un; } Elf64_Dyn; d_tag d_tag决定了如何对d_un解析\n合法的d_tag值定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 /* Legal values for d_tag (dynamic entry type). */ #define DT_NULL\t0\t/* Marks end of dynamic section */ #define DT_NEEDED\t1\t/* Name of needed library */ #define DT_PLTRELSZ\t2\t/* Size in bytes of PLT relocs */ #define DT_PLTGOT\t3\t/* Processor defined value */ #define DT_HASH\t4\t/* Address of symbol hash table */ #define DT_STRTAB\t5\t/* Address of string table */ #define DT_SYMTAB\t6\t/* Address of symbol table */ #define DT_RELA\t7\t/* Address of Rela relocs */ #define DT_RELASZ\t8\t/* Total size of Rela relocs */ #define DT_RELAENT\t9\t/* Size of one Rela reloc */ #define DT_STRSZ\t10\t/* Size of string table */ #define DT_SYMENT\t11\t/* Size of one symbol table entry */ #define DT_INIT\t12\t/* Address of init function */ #define DT_FINI\t13\t/* Address of termination function */ #define DT_SONAME\t14\t/* Name of shared object */ #define DT_RPATH\t15\t/* Library search path (deprecated) */ #define DT_SYMBOLIC\t16\t/* Start symbol search here */ #define DT_REL\t17\t/* Address of Rel relocs */ #define DT_RELSZ\t18\t/* Total size of Rel relocs */ #define DT_RELENT\t19\t/* Size of one Rel reloc */ #define DT_PLTREL\t20\t/* Type of reloc in PLT */ #define DT_DEBUG\t21\t/* For debugging; unspecified */ #define DT_TEXTREL\t22\t/* Reloc might modify .text */ #define DT_JMPREL\t23\t/* Address of PLT relocs */ #define\tDT_BIND_NOW\t24\t/* Process relocations of object */ #define\tDT_INIT_ARRAY\t25\t/* Array with addresses of init fct */ #define\tDT_FINI_ARRAY\t26\t/* Array with addresses of fini fct */ #define\tDT_INIT_ARRAYSZ\t27\t/* Size in bytes of DT_INIT_ARRAY */ #define\tDT_FINI_ARRAYSZ\t28\t/* Size in bytes of DT_FINI_ARRAY */ #define DT_RUNPATH\t29\t/* Library search path */ #define DT_FLAGS\t30\t/* Flags for the object being loaded */ #define DT_ENCODING\t32\t/* Start of encoded range */ #define DT_PREINIT_ARRAY 32\t/* Array with addresses of preinit fct*/ #define DT_PREINIT_ARRAYSZ 33\t/* size in bytes of DT_PREINIT_ARRAY */ #define DT_SYMTAB_SHNDX\t34\t/* Address of SYMTAB_SHNDX section */ #define DT_RELRSZ\t35\t/* Total size of RELR relative relocations */ #define DT_RELR\t36\t/* Address of RELR relative relocations */ #define DT_RELRENT\t37\t/* Size of one RELR relative relocaction */ #define\tDT_NUM\t38\t/* Number used */ #define DT_LOOS\t0x6000000d\t/* Start of OS-specific */ #define DT_HIOS\t0x6ffff000\t/* End of OS-specific */ #define DT_LOPROC\t0x70000000\t/* Start of processor-specific */ #define DT_HIPROC\t0x7fffffff\t/* End of processor-specific */ #define\tDT_PROCNUM\tDT_MIPS_NUM\t/* Most used by any processor */ /* DT_* entries which fall between DT_VALRNGHI \u0026amp; DT_VALRNGLO use the Dyn.d_un.d_val field of the Elf*_Dyn structure. This follows Sun\u0026#39;s approach. */ #define DT_VALRNGLO\t0x6ffffd00 #define DT_GNU_PRELINKED 0x6ffffdf5\t/* Prelinking timestamp */ #define DT_GNU_CONFLICTSZ 0x6ffffdf6\t/* Size of conflict section */ #define DT_GNU_LIBLISTSZ 0x6ffffdf7\t/* Size of library list */ #define DT_CHECKSUM\t0x6ffffdf8 #define DT_PLTPADSZ\t0x6ffffdf9 #define DT_MOVEENT\t0x6ffffdfa #define DT_MOVESZ\t0x6ffffdfb #define DT_FEATURE_1\t0x6ffffdfc\t/* Feature selection (DTF_*). */ #define DT_POSFLAG_1\t0x6ffffdfd\t/* Flags for DT_* entries, effecting the following DT_* entry. */ #define DT_SYMINSZ\t0x6ffffdfe\t/* Size of syminfo table (in bytes) */ #define DT_SYMINENT\t0x6ffffdff\t/* Entry size of syminfo */ #define DT_VALRNGHI\t0x6ffffdff #define DT_VALTAGIDX(tag)\t(DT_VALRNGHI - (tag))\t/* Reverse order! */ #define DT_VALNUM 12 /* DT_* entries which fall between DT_ADDRRNGHI \u0026amp; DT_ADDRRNGLO use the Dyn.d_un.d_ptr field of the Elf*_Dyn structure. If any adjustment is made to the ELF object after it has been built these entries will need to be adjusted. */ #define DT_ADDRRNGLO\t0x6ffffe00 #define DT_GNU_HASH\t0x6ffffef5\t/* GNU-style hash table. */ #define DT_TLSDESC_PLT\t0x6ffffef6 #define DT_TLSDESC_GOT\t0x6ffffef7 #define DT_GNU_CONFLICT\t0x6ffffef8\t/* Start of conflict section */ #define DT_GNU_LIBLIST\t0x6ffffef9\t/* Library list */ #define DT_CONFIG\t0x6ffffefa\t/* Configuration information. */ #define DT_DEPAUDIT\t0x6ffffefb\t/* Dependency auditing. */ #define DT_AUDIT\t0x6ffffefc\t/* Object auditing. */ #define\tDT_PLTPAD\t0x6ffffefd\t/* PLT padding. */ #define\tDT_MOVETAB\t0x6ffffefe\t/* Move table. */ #define DT_SYMINFO\t0x6ffffeff\t/* Syminfo table. */ #define DT_ADDRRNGHI\t0x6ffffeff #define DT_ADDRTAGIDX(tag)\t(DT_ADDRRNGHI - (tag))\t/* Reverse order! */ #define DT_ADDRNUM 11 /* The versioning entry types. The next are defined as part of the GNU extension. */ #define DT_VERSYM\t0x6ffffff0 #define DT_RELACOUNT\t0x6ffffff9 #define DT_RELCOUNT\t0x6ffffffa /* These were chosen by Sun. */ #define DT_FLAGS_1\t0x6ffffffb\t/* State flags, see DF_1_* below. */ #define\tDT_VERDEF\t0x6ffffffc\t/* Address of version definition table */ #define\tDT_VERDEFNUM\t0x6ffffffd\t/* Number of version definitions */ #define\tDT_VERNEED\t0x6ffffffe\t/* Address of table with needed versions */ #define\tDT_VERNEEDNUM\t0x6fffffff\t/* Number of needed versions */ #define DT_VERSIONTAGIDX(tag)\t(DT_VERNEEDNUM - (tag))\t/* Reverse order! */ #define DT_VERSIONTAGNUM 16 /* Sun added these machine-independent extensions in the \u0026#34;processor-specific\u0026#34; range. Be compatible. */ #define DT_AUXILIARY 0x7ffffffd /* Shared object to load before self */ #define DT_FILTER 0x7fffffff /* Shared object to get values from */ #define DT_EXTRATAGIDX(tag)\t((Elf32_Word)-((Elf32_Sword) (tag) \u0026lt;\u0026lt;1\u0026gt;\u0026gt;1)-1) #define DT_EXTRANUM\t3 DT_NEEDED 该tag对应的即为elf文件依赖的动态库文件,使用d_val解析后得到索引值\n通过索引查找.dynstr即可得到链接库名\n动态段的sh_link字段是指向动态链接字符串表的索引值\n另外通过d_tag==DT_STRTAB解析对应的d_val可以得到.dynstr的文件偏移值\nd_un d_val 代表整数值\nd_ptr 代表进程空间的虚拟地址\n解析规则如下\n名称 值 d_un 可执行文件 共享目标文件 DT_NULL 0 忽略 必需 必需 DT_NEEDED 1 d_val 可选 可选 DT_PLTRELSZ 2 d_val 可选 可选 DT_PLTGOT 3 d_ptr 可选 可选 DT_HASH 4 d_ptr 必需 必需 DT_STRTAB 5 d_ptr 必需 必需 DT_SYMTAB 6 d_ptr 必需 必需 DT_RELA 7 d_ptr 必需 可选 DT_RELASZ 8 d_val 必需 可选 DT_RELAENT 9 d_val 必需 可选 DT_STRSZ 10 d_val 必需 必需 DT_SYMENT 11 d_val 必需 必需 DT_INIT 12 d_ptr 可选 可选 DT_FINI 13 d_ptr 可选 可选 DT_SONAME 14 d_val 忽略 可选 DT_RPATH 15 d_val 可选 忽略 DT_SYMBOLIC 16 忽略 忽略 可选 DT_REL 17 d_ptr 必需 可选 DT_RELSZ 18 d_val 必需 可选 DT_RELENT 19 d_val 必需 可选 DT_PLTREL 20 d_val 可选 可选 DT_DEBUG 21 d_ptr 可选 忽略 DT_TEXTREL 22 忽略 可选 可选 DT_JMPREL 23 d_ptr 可选 可选 DT_BIND_NOW 24 忽略 可选 可选 DT_LOPROC 0x70000000 未定义 未定义 未定义 DT_HIPROC 0x7fffffff 未定义 未定义 未定义 打印动态段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 // Print Dynamic Segment #define DT_VAL 0 #define DT_PTR 1 const char *getDynamicType(Elf_Xword value) { if (value \u0026gt;= DT_LOOS \u0026amp;\u0026amp; value \u0026lt;= DT_HIOS) return \u0026#34;OS-Specific\u0026#34;; if (value \u0026gt;= DT_LOPROC \u0026amp;\u0026amp; value \u0026lt;= DT_HIPROC) return \u0026#34;Processor-Specific\u0026#34;; switch (value) { case DT_NULL: return \u0026#34;NULL\u0026#34;; case DT_NEEDED: return \u0026#34;NEEDED\u0026#34;; case DT_PLTRELSZ: return \u0026#34;PLTRELSZ\u0026#34;; case DT_PLTGOT: return \u0026#34;PLTGOT\u0026#34;; case DT_HASH: return \u0026#34;HASH\u0026#34;; case DT_STRTAB: return \u0026#34;STRTAB\u0026#34;; case DT_SYMTAB: return \u0026#34;SYMTAB\u0026#34;; case DT_RELA: return \u0026#34;RELA\u0026#34;; case DT_RELASZ: return \u0026#34;RELASZ\u0026#34;; case DT_RELAENT: return \u0026#34;RELAENT\u0026#34;; case DT_STRSZ: return \u0026#34;STRSZ\u0026#34;; case DT_SYMENT: return \u0026#34;SYMENT\u0026#34;; case DT_INIT: return \u0026#34;INIT\u0026#34;; case DT_FINI: return \u0026#34;FINI\u0026#34;; case DT_SONAME: return \u0026#34;SONAME\u0026#34;; case DT_RPATH: return \u0026#34;RPATH\u0026#34;; case DT_SYMBOLIC: return \u0026#34;SYMBOLIC\u0026#34;; case DT_REL: return \u0026#34;REL\u0026#34;; case DT_RELSZ: return \u0026#34;RELSZ\u0026#34;; case DT_RELENT: return \u0026#34;RELENT\u0026#34;; case DT_PLTREL: return \u0026#34;PLTREL\u0026#34;; case DT_DEBUG: return \u0026#34;DEBUG\u0026#34;; case DT_TEXTREL: return \u0026#34;TEXTREL\u0026#34;; case DT_JMPREL: return \u0026#34;JMPREL\u0026#34;; case DT_BIND_NOW: return \u0026#34;BIND_NOW\u0026#34;; case DT_INIT_ARRAY: return \u0026#34;INIT_ARRAY\u0026#34;; case DT_FINI_ARRAY: return \u0026#34;FINI_ARRAY\u0026#34;; case DT_INIT_ARRAYSZ: return \u0026#34;INIT_ARRAYSZ\u0026#34;; case DT_FINI_ARRAYSZ: return \u0026#34;FINI_ARRAYSZ\u0026#34;; case DT_RUNPATH: return \u0026#34;RUNPATH\u0026#34;; case DT_FLAGS: return \u0026#34;FLAGS\u0026#34;; case DT_ENCODING: return \u0026#34;ENCODING\u0026#34;; case DT_SYMTAB_SHNDX: return \u0026#34;SYMTAB_SHNDX\u0026#34;; case DT_RELRSZ: return \u0026#34;RELRSZ\u0026#34;; case DT_RELR: return \u0026#34;RELR\u0026#34;; case DT_RELRENT: return \u0026#34;RELRENT\u0026#34;; case DT_NUM: return \u0026#34;NUM\u0026#34;; case DT_VALRNGLO: return \u0026#34;VALRNGLO\u0026#34;; case DT_GNU_PRELINKED: return \u0026#34;GNU_PRELINKED\u0026#34;; case DT_GNU_CONFLICTSZ: return \u0026#34;GNU_CONFLICTSZ\u0026#34;; case DT_GNU_LIBLISTSZ: return \u0026#34;GNU_LIBLISTSZ\u0026#34;; case DT_CHECKSUM: return \u0026#34;CHECKSUM\u0026#34;; case DT_PLTPADSZ: return \u0026#34;PLTPADSZ\u0026#34;; case DT_MOVEENT: return \u0026#34;MOVEENT\u0026#34;; case DT_MOVESZ: return \u0026#34;MOVESZ\u0026#34;; case DT_FEATURE_1: return \u0026#34;FEATURE_1\u0026#34;; case DT_POSFLAG_1: return \u0026#34;POSFLAG_1\u0026#34;; case DT_SYMINSZ: return \u0026#34;SYMINSZ\u0026#34;; case DT_SYMINENT: return \u0026#34;SYMINENT\u0026#34;; case DT_ADDRRNGLO: return \u0026#34;ADDRRNGLO\u0026#34;; case DT_GNU_HASH: return \u0026#34;GNU_HASH\u0026#34;; case DT_TLSDESC_PLT: return \u0026#34;TLSDESC_PLT\u0026#34;; case DT_TLSDESC_GOT: return \u0026#34;TLSDESC_GOT\u0026#34;; case DT_GNU_CONFLICT: return \u0026#34;GNU_CONFLICT\u0026#34;; case DT_GNU_LIBLIST: return \u0026#34;GNU_LIBLIST\u0026#34;; case DT_CONFIG: return \u0026#34;CONFIG\u0026#34;; case DT_DEPAUDIT: return \u0026#34;DEPAUDIT\u0026#34;; case DT_AUDIT: return \u0026#34;AUDIT\u0026#34;; case DT_PLTPAD: return \u0026#34;PLTPAD\u0026#34;; case DT_MOVETAB: return \u0026#34;MOVETAB\u0026#34;; case DT_SYMINFO: return \u0026#34;SYMINFO\u0026#34;; case DT_VERSYM: return \u0026#34;VERSYM\u0026#34;; case DT_RELACOUNT: return \u0026#34;RELACOUNT\u0026#34;; case DT_RELCOUNT: return \u0026#34;RELCOUNT\u0026#34;; case DT_FLAGS_1: return \u0026#34;FLAGS_1\u0026#34;; case DT_VERDEF: return \u0026#34;VERDEF\u0026#34;; case DT_VERDEFNUM: return \u0026#34;VERDEFNUM\u0026#34;; case DT_VERNEED: return \u0026#34;VERNEED\u0026#34;; case DT_VERNEEDNUM: return \u0026#34;VERNEEDNUM\u0026#34;; case DT_AUXILIARY: return \u0026#34;AUXILIARY\u0026#34;; case DT_FILTER: return \u0026#34;FILTER\u0026#34;; default: return \u0026#34;Unknown Type\u0026#34;; } } uint32_t getDynamicDunType(Elf_Xword value) { switch (value) { case DT_NULL: case DT_NEEDED: case DT_PLTRELSZ: case DT_RELASZ: case DT_RELAENT: case DT_STRSZ: case DT_SYMENT: case DT_SONAME: case DT_RPATH: case DT_SYMBOLIC: case DT_RELSZ: case DT_RELENT: case DT_PLTREL: case DT_TEXTREL: case DT_BIND_NOW: case DT_LOPROC: case DT_HIPROC: return DT_VAL; case DT_PLTGOT: case DT_HASH: case DT_STRTAB: case DT_SYMTAB: case DT_RELA: case DT_INIT: case DT_FINI: case DT_JMPREL: case DT_DEBUG: case DT_REL: return DT_PTR; default: return DT_VAL; } } void printDynamicSegment32(const Elf32_Shdr* pSectionHeader,Elf_Half sectionNum,uint8_t* pFileBuffer) { for (int i = 0; i \u0026lt; sectionNum; i++) { if (pSectionHeader[i].sh_type == SHT_DYNAMIC) { Elf32_Shdr *pDynamicSection = \u0026amp;pSectionHeader[i]; Elf32_Word dynamicItemNum = pDynamicSection-\u0026gt;sh_size / pDynamicSection-\u0026gt;sh_entsize; printf(\u0026#34;Dynamic Section At File Offset %#x Contains %d Entries:\\n\u0026#34;, pDynamicSection-\u0026gt;sh_offset,dynamicItemNum); printf(\u0026#34;\\tTag \\t\\tType\\t\\t\\t\\tName/Value\\n\u0026#34;); Elf32_Dyn *pDynamicTable = (Elf32_Dyn *) (pFileBuffer + pDynamicSection-\u0026gt;sh_offset); Elf32_Shdr *pDynamicStringTableHeader = \u0026amp;pSectionHeader[pDynamicSection-\u0026gt;sh_link]; // dynamic string table char *pDynamicStringTable = (char *) pFileBuffer + pDynamicStringTableHeader-\u0026gt;sh_offset; for (int j = 0; j \u0026lt; dynamicItemNum; j++) { printf(\u0026#34;\\t%08x\u0026#34;, pDynamicTable[j].d_tag); printf(\u0026#34;\\t%-16s\u0026#34;, getDynamicType(pDynamicTable[j].d_tag)); printf(\u0026#34;\\t%08x\\t\u0026#34;, pDynamicTable[j].d_un.d_val); if (getDynamicDunType(pDynamicTable[j].d_tag) == DT_PTR) //Some special item is ptr printf(\u0026#34;(PTR)\u0026#34;); //Index of shared library path in dynamic string table switch (pDynamicTable[j].d_tag) { case DT_NEEDED: printf(\u0026#34;[%s]\u0026#34;, pDynamicStringTable + pDynamicTable[j].d_un.d_val); break; case DT_SONAME: printf(\u0026#34;[%s]\u0026#34;, pDynamicStringTable + pDynamicTable[j].d_un.d_val); break; default: ; } printf(\u0026#34;\\n\u0026#34;); } } } } Hash Table (Export Table) 哈希表可用于查询导出函数, 有两种, 目前的elf文件主要是用GNU HASH表作为导出表\n1 2 .hash //旧版,可以查导入和导出函数 DT_HASH .gnu.hash //新版,只能查导出函数 DT_GNU_HASH ELF Hash Hash表定义如下\n1 2 3 4 5 6 struct ELFHash { uint32_t nbucket; //bucket的数目 uint32_t nchain; //chain的数目,和动态符号表的符号数相同 uint32_t buckets[]; //nbucket个项的数组 uint32_t chains[]; //nchain个项的数组 }; Linux原始Elf Hash算法如下\n1 2 3 4 5 6 7 8 9 10 11 12 uint32_t elf_hash(const unsigned char* name) { uint32_t h = 0, g; while (*name) { h = (h \u0026lt;\u0026lt; 4) + *name++; if (g = h \u0026amp; 0xf0000000) h ^= g \u0026gt;\u0026gt; 24; h \u0026amp;= ~g; } return h; } ELF Hash Table根据符号名查找符号地址的流程如下\n根据elfhash函数计算符号名的hash\nindex=buckets[hash%nbucket]\nindex即为符号在符号表中的索引\n如果index==SHT_UNDEF(0)则未找到符号,结束\n否则判断符号表中索引index的符号和目标符号是否相同\n如果符号名不同则根据index从chains表找下一个符号索引,继续第3步\nindex=chains[index] (如果chains[index]==0说明不存在该符号)\n代码表示如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 uint32_t findSymbolIndexByElfHash(const char* symbolName, uint32_t* pHashTable, Elf32_Sym* pSymbolTable, const char* pSymbolStringTable) { uint32_t nbucket=pHashTable[0],nchain=pHashTable[1]; uint32_t* buckets=\u0026amp;pHashTable[2],*chains=\u0026amp;pHashTable[2+nbucket]; uint32_t hash = elf_hash(symbolName); for (uint32_t index=buckets[hash % nbucket]; index; index = chains[index]) { if (strcmp(symbolName, \u0026amp;pSymbolStringTable[pSymbolTable[index].st_name]) == 0) { return index; } } return 0; } 手工查找流程示例:\n由于x86_64下gcc编译的elf程序默认只使用gnu.hash,以Android NDK得到的64位so为例\n找到.hash节,发现nbucket=nchain=0x36\n根据elfhash计算bucket下标, index=hash%nbucket =48\n由于bucket项大小为4字节,从0x960开始+48*4=0xA20\n得到动态符号表下标为0xE(14), 查找符号表正好对应dlopen函数\nAndroid Elf Hash Android的elfhash算法代码有所不同,但和原始elfhash等价\n参考 https://cs.android.com/android/platform/superproject/+/android-4.1.2_r2.1:bionic/linker/linker.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 static unsigned elfhash(const char *_name) { const unsigned char *name = (const unsigned char *) _name; unsigned h = 0, g; while(*name) { h = (h \u0026lt;\u0026lt; 4) + *name++; g = h \u0026amp; 0xf0000000; h ^= g; h ^= g \u0026gt;\u0026gt; 24; } return h; } static Elf32_Sym *_elf_lookup(soinfo *si, unsigned hash, const char *name) { Elf32_Sym *s; Elf32_Sym *symtab = si-\u0026gt;symtab; const char *strtab = si-\u0026gt;strtab; unsigned n; TRACE_TYPE(LOOKUP, \u0026#34;%5d SEARCH %s in %s@0x%08x %08x %d\\n\u0026#34;, pid, name, si-\u0026gt;name, si-\u0026gt;base, hash, hash % si-\u0026gt;nbucket); n = hash % si-\u0026gt;nbucket; for(n = si-\u0026gt;bucket[hash % si-\u0026gt;nbucket]; n != 0; n = si-\u0026gt;chain[n]){ s = symtab + n; if(strcmp(strtab + s-\u0026gt;st_name, name)) continue; /* only concern ourselves with global and weak symbol definitions */ switch(ELF32_ST_BIND(s-\u0026gt;st_info)){ case STB_GLOBAL: case STB_WEAK: /* no section == undefined */ if(s-\u0026gt;st_shndx == 0) continue; TRACE_TYPE(LOOKUP, \u0026#34;%5d FOUND %s in %s (%08x) %d\\n\u0026#34;, pid, name, si-\u0026gt;name, s-\u0026gt;st_value, s-\u0026gt;st_size); return s; } } return NULL; } Sysv Hash Elf Hash在Android又定义为为Sysv Hash,参考https://cs.android.com/android/platform/superproject/+/android14-qpr3-release:external/musl/ldso/dynlink.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static uint32_t sysv_hash(const char *s0) { const unsigned char *s = (void *)s0; uint_fast32_t h = 0; while (*s) { h = 16*h + *s++; h ^= h\u0026gt;\u0026gt;24 \u0026amp; 0xf0; } return h \u0026amp; 0xfffffff; } static Sym *sysv_lookup(const char *s, uint32_t h, struct dso *dso) { size_t i; Sym *syms = dso-\u0026gt;syms; Elf_Symndx *hashtab = dso-\u0026gt;hashtab; char *strings = dso-\u0026gt;strings; for (i=hashtab[2+h%hashtab[0]]; i; i=hashtab[2+hashtab[0]+i]) { if ((!dso-\u0026gt;versym || dso-\u0026gt;versym[i] \u0026gt;= 0) \u0026amp;\u0026amp; (!strcmp(s, strings+syms[i].st_name))) return syms+i; } return 0; } GNU Hash GNU Hash表项如下\n1 2 3 4 5 6 7 8 9 struct GnuHash { uint32_t nbucket; uint32_t symndx; //支持查找index\u0026gt;=symndx的符号, index\u0026lt;symndx的不能直接通过GNU Hash表查找 uint32_t bloomSize; // 布隆过滤器需要的3个数据,用于快速判断某个符号是否查不到 uint32_t bloomShift; // ElfW(Addr) blooms[];\t// bloomSize个项的数组 32/64位下, 元素大小分别为uint32_t/uint64_t uint32_t buckets[]; // nbucket个项的数组 uint32_t chains[]; // 和符号表索引一一对应, chain的大小等于导出函数个数 }; 可以发现,GNU Hash并没有给出nchain字段,如何计算?\nchains数组前面是连续的blooms和buckets数组,只要根据哈希表大小减去前面的成员大小即可 32位 nchain=GNUHashTable.sh_size/sizeof(uint32_t) - (4+bloomSize+nbucket) 64位 nchain=GNUHashTable.sh_size/sizeof(uint32_t) - (4+bloomSize*2+nbucket) 查找GNU Hash表的示意图如下:\nchain表的虚线部分并不存在\n除了导出符号之外的符号chain表并无必要保存,但chain表的索引和符号表要一一对应\n所以chain表的理论起始地址=buckets+nbucket-symndx\n但在文件的排列上,各项是连续的,chains有效内容仍然在buckets后方\nchain表每个表项保存符号的哈希值\n最低位为0时表示对应的符号有剩余哈希冲突项\n为1时表示没有剩余冲突项\n详细可参考ELF 通过 Sysv Hash \u0026amp; Gnu Hash 查找符号的实现及对比和ELF解析07_哈希表, 导出表\n参考https://cs.android.com/android/platform/superproject/+/android14-qpr3-release:external/musl/ldso/dynlink.c\nAndroid Linker的源码实现如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 uint32_t gnu_hash(const unsigned char* str) { uint_32 h = 5381;// 0x1505 while(*str != 0) { h += (h\u0026lt;\u0026lt;5) +*str++;// 33 * h + *str = h*33 + c = h + h * 32 + c = h + h \u0026lt;\u0026lt; 5 + c } return h; } static Sym *gnu_lookup(uint32_t h1, uint32_t *hashtab, struct dso *dso, const char *s) { uint32_t nbuckets = hashtab[0]; uint32_t *buckets = hashtab + 4 + hashtab[2]*(sizeof(size_t)/4); uint32_t i = buckets[h1 % nbuckets]; if (!i) return 0; uint32_t *hashval = buckets + nbuckets + (i - hashtab[1]); for (h1 |= 1; ; i++) { uint32_t h2 = *hashval++; if ((h1 == (h2|1)) \u0026amp;\u0026amp; (!dso-\u0026gt;versym || dso-\u0026gt;versym[i] \u0026gt;= 0) \u0026amp;\u0026amp; !strcmp(s, dso-\u0026gt;strings + dso-\u0026gt;syms[i].st_name)) return dso-\u0026gt;syms+i; if (h2 \u0026amp; 1) break; } return 0; } 打印哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 unsigned int elf_hash(const char* _name) { const unsigned char* name=(const unsigned char*)_name; unsigned int h = 0, g; while (*name) { h = (h \u0026lt;\u0026lt; 4) + *name++; if (g = h \u0026amp; 0xf0000000) h ^= g \u0026gt;\u0026gt; 24; h \u0026amp;= ~g; } return h; } void printHashTable32(Elf32_Shdr* pSectionHeader,Elf_Half sectionNum,uint8_t* pFileBuffer,const char* pSectionHeaderStringTable) { printf(\u0026#34;ELF Hash Tables:\\n\u0026#34;); for(int i=0;i\u0026lt;sectionNum;i++) { if(pSectionHeader[i].sh_type==SHT_HASH) { //SHT_HASH 可同时查询导入和导出函数,linux默认弃用,android保留该节 //对于SHT_HASH类型而言,index=buckets[elfhash(symbolName)%nbucket]作为符号表索引 //如果index==0则符号不存在,如果符号不等则index=chains[index]继续循环判断 Elf32_Shdr* pDynamicSymbolTableHeader=\u0026amp;pSectionHeader[pSectionHeader[i].sh_link]; Elf32_Sym* pDynamicSymbolTable=(Elf32_Sym*)(pDynamicSymbolTableHeader-\u0026gt;sh_offset+pFileBuffer); const char* pDynamicSymbolStringTable=(const char*)(pSectionHeader[pDynamicSymbolTableHeader-\u0026gt;sh_link].sh_offset+pFileBuffer); uint32_t* pHashTable=(uint32_t*)(pSectionHeader[i].sh_offset+pFileBuffer); uint32_t nbucket=pHashTable[0],nchain=pHashTable[1]; uint32_t* buckets=\u0026amp;pHashTable[2]; uint32_t* chains=\u0026amp;pHashTable[2+nbucket]; printf(\u0026#34;\\tHash Table \u0026#39;%s\u0026#39; contains %d entries\\n\u0026#34;,\u0026amp;pSectionHeaderStringTable[pSectionHeader[i].sh_name],nchain); printf(\u0026#34;\\t\\tNum\\t\\tHash \\% Nbucket\\t\\tIndex\\t\\t\\tValue\\t\\t\\tName\\n\u0026#34;); for(uint32_t j=0,count=0;j\u0026lt;nbucket;j++) { uint32_t index=buckets[j];//遍历buckets if(index) { //index!=0 说明存在对应符号,打印首个符号 printf(\u0026#34;\\t\\t%d\\t\\t%08x\\t\\t%08x\\t\\t%08x\\t\\t%s\\n\u0026#34;,++count,elf_hash(\u0026amp;pDynamicSymbolStringTable[pDynamicSymbolTable[index].st_name])%nbucket,index,pDynamicSymbolTable[index].st_value,\u0026amp;pDynamicSymbolStringTable[pDynamicSymbolTable[index].st_name]); } //判断是否存在chain,打印相同hash%nbucket的其余符号, while(chains[index]) { index=chains[index]; printf(\u0026#34;\\t\\t%d\\t\\t%08x\\t\\t%08x\\t\\t%08x\\t\\t%s\\n\u0026#34;,++count,elf_hash(\u0026amp;pDynamicSymbolStringTable[pDynamicSymbolTable[index].st_name])%nbucket,index,pDynamicSymbolTable[index].st_value,\u0026amp;pDynamicSymbolStringTable[pDynamicSymbolTable[index].st_name]); } } } if(pSectionHeader[i].sh_type==SHT_GNU_HASH) { //SHT_GNU_HASH 只能查询导出函数,作为elf的导出函数表 Elf32_Shdr* pDynamicSymbolTableHeader=\u0026amp;pSectionHeader[pSectionHeader[i].sh_link]; Elf32_Sym* pDynamicSymbolTable=(Elf32_Sym*)(pDynamicSymbolTableHeader-\u0026gt;sh_offset+pFileBuffer); const char* pDynamicSymbolStringTable=(const char*)(pSectionHeader[pDynamicSymbolTableHeader-\u0026gt;sh_link].sh_offset+pFileBuffer); uint32_t* pGNUHashTable=(uint32_t*)(pSectionHeader[i].sh_offset+pFileBuffer); uint32_t nbucket=pGNUHashTable[0]; uint32_t symndx=pGNUHashTable[1]; uint32_t bloomSize=pGNUHashTable[2]; uint32_t bloomShift=pGNUHashTable[3]; Elf32_Addr* blooms=(Elf32_Addr*)\u0026amp;pGNUHashTable[4]; uint32_t* buckets=pGNUHashTable+4+bloomSize; uint32_t* chains=buckets+nbucket-symndx; //chain的个数等于导出符号个数,但GNU HASH没有nchain,需要手动计算 uint32_t nchain=pSectionHeader[i].sh_size/sizeof(uint32_t)-(4+bloomSize+nbucket); printf(\u0026#34;\\tHash Table \u0026#39;%s\u0026#39; contains %d entries, nbucket: %d, symndx: %#x \\n\u0026#34;,\u0026amp;pSectionHeaderStringTable[pSectionHeader[i].sh_name],nchain,nbucket,symndx); printf(\u0026#34;\\t\\tNum\\t\\tIndex\\t\\t\\tValue\\t\\t\\tName\\n\u0026#34;); for(int j=0,count=0;j\u0026lt;nbucket;j++) { uint32_t index=buckets[j]; if(index) { printf(\u0026#34;\\t\\t%d\\t\\t%08x\\t\\t%08x\\t\\t%s\\n\u0026#34;,++count,index,pDynamicSymbolTable[index].st_value,\u0026amp;pDynamicSymbolStringTable[pDynamicSymbolTable[index].st_name]); } //chain最低位为0时表示有,为1时表示无 while((chains[index]\u0026amp;1)==0) { index++; printf(\u0026#34;\\t\\t%d\\t\\t%08x\\t\\t%08x\\t\\t%s\\n\u0026#34;,++count,index,pDynamicSymbolTable[index].st_value,\u0026amp;pDynamicSymbolStringTable[pDynamicSymbolTable[index].st_name]); } } } } } ELF Loader ELF Program Header描述了ELF文件的哪些段需要映射到内存,ELF程序的加载流程如下:\n将elf文件加载到内存中,成为filebuffer\n根据program header,映射filebuffer至imagebuffer\n这一步需要给予不同段正确的权限\n重定位,修复全局变量地址和外部引用地址\n根据elf加载的基地址修复全局变量地址\n外部引用地址需要加载并遍历needed libso,根据符号查找函数真实地址并修复\n跳转至入口点\n分别编译loadelf32/64以加载x86/x64的elf文件\n1 2 gcc -m32 main.c LoadELF.h LoadELF.c -o loadelf32 gcc -m64 main.c LoadELF.h LoadELF.c -o loadelf64 main.c\n1 2 3 4 5 6 7 8 9 10 11 // LoadELF #include \u0026#34;LoadELF.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { if (argc!= 2) { printf(\u0026#34;Usage: %s \u0026lt;filepath\u0026gt;\\n\u0026#34;, argv[0]); return 1; } LoadAndExecElf(argv[1]); return 0; } LoadELF.h\n1 2 3 4 5 6 7 #ifndef LOADELF_H #define LOADELF_H #include \u0026lt;stddef.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; uint8_t* readFileToBytes(const char *fileName,size_t* readSize); void LoadAndExecElf(const char* filePath); #endif //LOADELF_H LoadELF.c\n根据x86/x64不同环境,定义对应宏\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 #include \u0026#34;LoadELF.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;elf.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;dlfcn.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;link.h\u0026gt; #ifdef __x86_64__ #define Elf_Ehdr Elf64_Ehdr #define Elf_Phdr Elf64_Phdr #define Elf_Shdr Elf64_Shdr #define Elf_Addr Elf64_Addr #define Elf_Dyn Elf64_Dyn #define Elf_Rel Elf64_Rela #define Elf_Sym Elf64_Sym #define ELF_R_TYPE ELF64_R_TYPE #define ELF_R_SYM ELF64_R_SYM #define DT_REL_ITEM DT_RELA #define DT_REL_SZ DT_RELASZ #else #define Elf_Ehdr Elf32_Ehdr #define Elf_Phdr Elf32_Phdr #define Elf_Shdr Elf32_Shdr #define Elf_Addr Elf32_Addr #define Elf_Dyn Elf32_Dyn #define Elf_Rel Elf32_Rel #define Elf_Sym Elf32_Sym #define ELF_R_TYPE ELF32_R_TYPE #define ELF_R_SYM ELF32_R_SYM #define DT_REL_ITEM DT_REL #define DT_REL_SZ DT_RELSZ #endif uint8_t* readFileToBytes(const char *fileName,size_t* readSize) { FILE *file = fopen(fileName, \u0026#34;rb\u0026#34;); if (file == NULL) { printf(\u0026#34;Error opening file\\n\u0026#34;); fclose(file); return NULL; } fseek(file, 0,SEEK_END); size_t fileSize = ftell(file); fseek(file, 0,SEEK_SET); uint8_t *buffer = (uint8_t *) malloc(fileSize); if (buffer == NULL) { printf(\u0026#34;Error allocating memory\\n\u0026#34;); fclose(file); return NULL; } size_t bytesRead = fread(buffer, 1, fileSize, file); if(bytesRead!=fileSize) { printf(\u0026#34;Read bytes not equal file size!\\n\u0026#34;); free(buffer); fclose(file); return NULL; } fclose(file); if(readSize) *readSize=bytesRead; return buffer; } //以指定对齐值对齐 uint64_t alignValue(uint64_t value, uint64_t alignment) { return value % alignment ? (value / alignment + 1) * alignment : value; } size_t getElfMemorySize(Elf_Phdr* pProgramHeader,Elf_Half segmentNum) { size_t size = 0; //从后往前遍历段表,最后一个段的内存起始地址+大小对齐后即为镜像大小 for (int i = segmentNum - 1; i \u0026gt;= 0; i--) { if (pProgramHeader[i].p_type == PT_LOAD) { size = pProgramHeader[i].p_vaddr + pProgramHeader[i].p_memsz; break; } } return alignValue(size, 0x1000); } Elf_Word getDynamicTableValueByType(Elf_Dyn *dynamicTable, size_t dynamicTableSize, int type) { for (int i = 0; i \u0026lt; dynamicTableSize; i++) { if (dynamicTable[i].d_tag == type) { return dynamicTable[i].d_un.d_val; } } return 0; } const char** getNeededLibraryPath(uint8_t* pElfBuffer,Elf_Dyn *pDynamicTable, size_t dynamicTableSize,size_t* neededLibraryNum) { //Traverse dynamic segment find needed library char** buffer = NULL; int num=0; char* pImageStringTable=(char*)pElfBuffer+getDynamicTableValueByType(pDynamicTable,dynamicTableSize,DT_STRTAB); for (int i = 0; i \u0026lt; dynamicTableSize; i++) { if (pDynamicTable[i].d_tag == DT_NEEDED) { num++; buffer=(char**)realloc(buffer,num*sizeof(char*)); if(buffer==NULL) { printf(\u0026#34;Error reallocating memory\\n\u0026#34;); exit(-1); } buffer[num-1]=pImageStringTable+ pDynamicTable[i].d_un.d_val; } } *neededLibraryNum=num; return (const char**)buffer; } Elf_Addr getSymbolAddress(const char** neededLibrary, size_t neededLibraryNum, const char *symbolName) { //Load needed dynamic libraries,and traverse libraries, get symbol address for (int i = 0; i \u0026lt; neededLibraryNum; i++) { void *handle = dlopen(neededLibrary[i],RTLD_NOW); if (handle == NULL) { printf(\u0026#34;Error opening library %s\\n\u0026#34;, dlerror()); exit(1); } void *address = dlsym(handle, symbolName); if (address == NULL) { continue; } return (Elf_Addr)address; } printf(\u0026#34;Can\u0026#39;t find address of symbol: %s\\n\u0026#34;,symbolName); return 0; } void mapSegmentToMemory(uint8_t* pImageBuffer,uint8_t* pFileBuffer,Elf_Phdr* pProgramHeader,Elf_Half segmentNum) { for (int i = 0; i \u0026lt; segmentNum; i++) { if (pProgramHeader[i].p_type == PT_LOAD) { uint8_t *pImageAddr = pImageBuffer + pProgramHeader[i].p_vaddr;//根据内存地址和大小进行映射 size_t memorySize = pProgramHeader[i].p_memsz; Elf_Word segmentFlags = pProgramHeader[i].p_flags; int protection = 0; memcpy(pImageAddr, pFileBuffer + pProgramHeader[i].p_offset, pProgramHeader[i].p_filesz); if (segmentFlags \u0026amp; PF_R) { protection |= PROT_READ; } if (segmentFlags \u0026amp; PF_W) { protection |= PROT_WRITE; } if (segmentFlags \u0026amp; PF_X) { protection |= PROT_EXEC; } mprotect(pImageAddr, alignValue(memorySize, 0x1000), protection);//页面权限设置 } } } void fixRelocationItem(Elf_Rel* pRelocationTable,Elf_Word relocationItemNum,uint8_t* pImageBuffer,const char* pDynamicStringTable,Elf_Sym* pDynamicSymbolTable,const char** neededLibrary,size_t neededLibraryNum) { Elf_Addr* fixItem=NULL;//根据位数不同,修复项4/8字节 Elf_Addr baseAddr=(Elf_Addr)pImageBuffer; for(int i=0;i\u0026lt;relocationItemNum;i++) { switch (ELF_R_TYPE(pRelocationTable[i].r_info)) { //Relocate base address case R_386_RELATIVE: fixItem=(Elf_Addr*)(pImageBuffer+pRelocationTable[i].r_offset); *fixItem+=baseAddr; break; //Fix GOT and PLT case R_386_GLOB_DAT: case R_386_JMP_SLOT: // Get symbol name and real address const char* symbolName=\u0026amp;pDynamicStringTable[ pDynamicSymbolTable[ELF_R_SYM(pRelocationTable[i].r_info)].st_name ];//符号表表项的name属性是字符串表下标 fixItem=(Elf_Addr*)(pImageBuffer+pRelocationTable[i].r_offset); Elf_Addr symbolAddr=getSymbolAddress(neededLibrary,neededLibraryNum,symbolName); *fixItem=symbolAddr; break; } } } void LoadAndExecElf(const char* filePath) { //1. Read file to memory buffer size_t readFileSize=0; uint8_t* pFileBuffer=readFileToBytes(filePath,\u0026amp;readFileSize); if(pFileBuffer==NULL) { printf(\u0026#34;Error reading file\\n\u0026#34;); return; } Elf_Ehdr* pElfHeader=(Elf_Ehdr*)pFileBuffer; Elf_Phdr *pProgramHeader=(Elf_Phdr*)(pFileBuffer+pElfHeader-\u0026gt;e_phoff); Elf_Half segmentNum=pElfHeader-\u0026gt;e_phnum; uint8_t* pImageBuffer=NULL; //2. Mapping file buffer to image buffer size_t elfMemorySize = getElfMemorySize(pProgramHeader,segmentNum); if (elfMemorySize == 0) { printf(\u0026#34;ELF memory size is 0!\\n\u0026#34;); return; } posix_memalign((void*)\u0026amp;pImageBuffer, 0x1000, elfMemorySize); //Alloc align memory if (pImageBuffer == NULL) { printf(\u0026#34;Error allocating memory\\n\u0026#34;); return; } memset(pImageBuffer,0 ,elfMemorySize); // Mapping segments to memory and set protection mapSegmentToMemory(pImageBuffer,pFileBuffer,pProgramHeader,segmentNum); //3. Relocate Elf_Phdr *pDynamicTableHeader=NULL; Elf_Dyn *pDynamicTable=NULL; for (int i = 0; i \u0026lt; segmentNum; i++) { if (pProgramHeader[i].p_type == PT_DYNAMIC) { pDynamicTableHeader = \u0026amp;pProgramHeader[i]; break; } } pDynamicTable = (Elf_Dyn *) (pImageBuffer + pDynamicTableHeader-\u0026gt;p_vaddr); size_t dynamicItemNum = pDynamicTableHeader-\u0026gt;p_filesz / sizeof(Elf_Dyn); Elf_Rel *pRelocationTable =NULL; size_t relocationItemNum=0; Elf_Rel *pJmpRelocationTable = (Elf_Rel *) (pImageBuffer + getDynamicTableValueByType(pDynamicTable, dynamicItemNum,DT_JMPREL)); size_t jmpRelocationItemNum=0; Elf_Sym *pDynamicSymbolTable = NULL; char *pDynamicStringTable = NULL; for (int i = 0; i \u0026lt;dynamicItemNum; i++) { switch (pDynamicTable[i].d_tag) { case DT_REL_ITEM: pRelocationTable=(Elf_Rel*)(pImageBuffer+pDynamicTable[i].d_un.d_val); break; case DT_JMPREL: pJmpRelocationTable=(Elf_Rel*)(pImageBuffer+pDynamicTable[i].d_un.d_val); break; case DT_REL_SZ: relocationItemNum=pDynamicTable[i].d_un.d_val/sizeof(Elf_Rel); break; case DT_PLTRELSZ: jmpRelocationItemNum=pDynamicTable[i].d_un.d_val/sizeof(Elf_Rel); break; case DT_SYMTAB:pDynamicSymbolTable=(Elf_Sym*)(pImageBuffer+pDynamicTable[i].d_un.d_val);break; case DT_STRTAB:pDynamicStringTable=(char*)(pImageBuffer+pDynamicTable[i].d_un.d_val);break; } } size_t neededLibraryNum=0; const char** neededLibrary=getNeededLibraryPath(pImageBuffer,pDynamicTable,dynamicItemNum,\u0026amp;neededLibraryNum); fixRelocationItem(pRelocationTable,relocationItemNum,pImageBuffer,pDynamicStringTable,pDynamicSymbolTable,neededLibrary,neededLibraryNum); fixRelocationItem(pJmpRelocationTable,jmpRelocationItemNum,pImageBuffer,pDynamicStringTable,pDynamicSymbolTable,neededLibrary,neededLibraryNum); //4. Jump to entry point typedef void (*VoidFunctionPtr)(); VoidFunctionPtr entry=(VoidFunctionPtr)(pImageBuffer+pElfHeader-\u0026gt;e_entry); printf(\u0026#34;Load ELF success!Jump to entry point:%#lx\\n\u0026#34;,(unsigned long long)entry); entry(); printf(\u0026#34;Come back\\n\u0026#34;); } 效果如下\nReferences ELF文件格式\nELF文件格式解析\n《程序员的自我修养》\nELF加载器的原理与实现\n【内核】ELF 文件执行流程\n说一下Linux可执行文件的格式，ELF格式\nELF解析07_哈希表, 导出表\nELF 通过 Sysv Hash \u0026amp; Gnu Hash 查找符号的实现及对比\n[翻译]GNU Hash ELF Sections\n","date":"2024-11-24T16:56:01+08:00","image":"https://example.com/p/elf%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%B5%85%E6%9E%90-%E8%A7%A3%E6%9E%90%E5%99%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0/1-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F_hu14841608384229060202.png","permalink":"https://example.com/p/elf%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%B5%85%E6%9E%90-%E8%A7%A3%E6%9E%90%E5%99%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AE%9E%E7%8E%B0/","title":"ELF文件结构浅析-解析器和加载器实现"},{"content":"引言 找到一个8g老u盘,插电脑上不识别,突然识别成功了一次,推测是主控或驱动问题,win7虚拟机成功识别(u盘生产日期早于win10发布日期)\n解决办法\n使用aptool低格 使用umptool高格 修复过程 一.查询主控 使用ChipGenius查询,可以看到主控厂商为芯邦,型号为CBM2099A\n上网搜索该主控的量产工具\n二.APTool低格 版本为V7100(2019-03-04)\n注意到设置勾选上擦除量产信息\n三.UMPTool高格 版本为V7100(2018-01-19)\n默认即可,直接运行\n四.注意 实测aptool版本需要比umptool版本高,否则报错无代码文件(0018),报错时可以多尝试几个版本\n例如2021版aptool低格+2019版umptool高格\n参考资料 【忆梦】U盘修复详细教程，找不到量产信息解决方案 U盘量产，代码文件不存在问题，低格版本比高格版本新 扩容U盘芯邦CBM2098E二次量产工具识别修复教程 UMPTool下载地址 APTool下载地址 ","date":"2024-10-26T13:20:50+08:00","permalink":"https://example.com/p/u%E7%9B%98%E9%87%8F%E4%BA%A7%E4%BF%AE%E5%A4%8D/","title":"U盘量产修复"},{"content":"前言 拥有一台服务器可以搭建个人博客,minecraft服务器,跑爬虫脚本等\n最近阿里云推出学生优惠券减免300元,正好买服务器用于mc联机\n购买服务器 以阿里云ECS服务器为例\n相关活动:\n不定期推出学生优惠券可以减免300元高校学生通用权益\n服务器1年99元,配置为2核2G3M固定带宽,适合搭建博客等轻量化场景 云服务器ECS-99元/年优惠\n购买链接ECS自定义购买\n付费类型及地域 付费类型选择包年包月,地域根据需求选择,距离实例地域越近延迟越低\n其中乌兰察布比较便宜,南昌延迟约35~60ms,身处香港也能流畅mc联机\n实例规格 实例规格默认2核2G,如果搭建游戏服务器最低使用该配置,有条件建议内存4G+\n镜像 推荐Ubuntu 20.04 64位 系统支持稳定\n存储 系统盘默认40G,足够大部分场景,根据需求增减\n带宽 勾选分配公网IPv4地址,选择CDT计费,带宽峰值100Mbps\n固定带宽较贵,并且游戏场景吃带宽,太低会导致卡顿\nCDT按量计费每个月免费20G的大陆流量和180G海外流量,日常完全够用,带宽峰值拉高保证速度,超出部分0.8/GB\n密码 选择自定义密码,设置好即可\n0.86买2年 以上配置1年232.44,两年346.22\n如果存储降为28G两年只要300.86,叠加300优惠券直接0.86拿下\n","date":"2024-10-26T13:18:33+08:00","permalink":"https://example.com/p/buyalicouldserver/","title":"BuyAliCouldServer"},{"content":"一. Frida简介 官网https://frida.re\nfrida是一款常用的hook框架,支持android/ios/windows/macos等多种平台\n可以实现java层和native层的函数级hook,以及native层的指令级patch等操作\n一般在工作机上安装frida,编写脚本后使用命令行工具,启动frida并将脚本注入到靶机指定进程\n同时需要在靶机上安装相同版本的frida-server用于监听工作机传来的操作指令\n二. Frida环境配置 安装frida\n参考下方的frida对应关系表安装指定版本的frida和frida-tools\n建议使用anaconda的python虚拟环境,针对不同靶机可能需要多个版本frida\n不同版本的frida对python版本要求不同且不能共存\n1 2 3 4 pip install frida pip install frida-tools #可以通过frida=version的操作安装指定版本 #例如pip install frida=12.8.0 配置开发环境\n下载WebStorm https://www.jetbrains.com/zh-cn/webstorm/download js IDE\n下载Node.js https://nodejs.org/zh-cn/download/prebuilt-binaries js解释器\nfrida代码补全提示配置:\n创建项目后,在根目录打开cmd ,执行以下代码后安装代码补全包自动开启\n1 npm i @types/frida-gum frida对应关系表 Android版本 frida版本 frida-tools版本 python版本 objection版本 android5-6 frida12.3.6 python=3.7 andorid7-8 frida12.8.0 frida-tools=5.3.0 python=3.8 objection=1.8.4 andorid9-10 frida14.2.14 frida-tools=9.2.2 python=3.8 objection=1.11.0 andorid10-12 frida15.2.2 frida-tools=11.0.0 python=3.9/3.10 android10-12 frida15+ python=3.9/3.10 android12+ frida16.0.19 python=3.10/3.11 frida12 最好在\u0026lt;=安卓8.1的版本上用，最好别在\u0026gt;=安卓10上用 frida14 最好在\u0026gt;=安卓10的版本上用，别在\u0026lt;=8.1的版本上用\n三. Frida常用命令 frida命令参数 -U: 指定USB设备\n-D: 指定id设备\n-R: 远程frida-server\n-H: 指定远程frida-server地址 ip:port\n-f: swapn模式\n-p: attach的目标pid\n-n: attach的目标名称\n-F: attach模式(默认)\n-l: 加载脚本\n-o: 输出日志到指定文件\n\u0026ndash;no-pause: spawn启动app时不挂起,直接运行\n列出手机进程信息 1 frida-ps -Uai -U: 指定USB设备\n-a: 列出所有进程\n-i: 显示进程详细信息\nfrida注入进程 附加注入进程 直接注入后可使用控制台调用frida api进行交互\n1 frida -U \u0026lt;package_name\u0026gt; 附加注入进程并加载脚本\n1 frida -U \u0026lt;package_name\u0026gt; -l \u0026lt;script.js\u0026gt; swapn注入进程并加载脚本\n1 frida -U -f \u0026lt;package_name\u0026gt; -l \u0026lt;script.js\u0026gt; 四. Frida-labs 用于入门熟悉frida的基本hook操作,包括java和native层hook\n参考https://github.com/DERE-ad2001/Frida-labs和[原创]Frida-Hook-Java层操作大全\nlab1 Overload\u0026amp;Implement Method hook重载函数并实现\n1 2 3 4 5 6 7 8 9 10 function main(){ Java.perform(function (){ var mainActivity=Java.use(\u0026#34;com.ad2001.frida0x1.MainActivity\u0026#34;); mainActivity.check.overload(\u0026#34;int\u0026#34;,\u0026#34;int\u0026#34;).implementation=function (x,y){ console.log(\u0026#34;Origin i=\u0026#34;,x,\u0026#34;i2=\u0026#34;,y) this.check(2,8) } }) } setTimeout(main,500) lab2 CallStaticMethod MainActivity的静态方法get_flag(),当参数a==4919时getflag\n获取MainActivity类,主动调用get_flag()即可\n1 2 3 4 5 6 7 function main(){ Java.perform(function (){ var mainActivity=Java.use(\u0026#34;com.ad2001.frida0x2.MainActivity\u0026#34;); mainActivity.get_flag(4919) }) } setTimeout(main,500) lab3 ModifyStaticValue 当Checker.code==512时getflag\nChecker.code为静态变量\n获取Checker类,通过.value直接修改静态变量code的值即可\n1 2 3 4 5 6 7 8 function main(){ Java.perform(function (){ var Checker=Java.use(\u0026#34;com.ad2001.frida0x3.Checker\u0026#34;) console.log(Checker) Checker.code.value=512 }) } setTimeout(main,500) lab4 CallInstanceMethod MainActivity没有getflag逻辑,在Check类中有实例方法get_flag\n获取Check类并调用new方法创建实例,之后调用get_flag\n1 2 3 4 5 6 7 8 9 10 11 function main(){ Java.perform(function (){ var Check=Java.use(\u0026#34;com.ad2001.frida0x4.Check\u0026#34;) console.log(Check) var instance=Check.$new() console.log(instance) var flag=instance.get_flag(1337) console.log(flag) }) } setTimeout(main,500) lab5 FindInstance MainActivity的实例方法flag\n在app启动时会创建MainActivity实例,此时我们如果使用Java.use获取MainActivity类并调用new创建实例,会导致错误\n因为Android的UI组件依赖程序上下文运行,并且已经和MainActivity实例绑定,再次创建实例显然不行\n通过Java.choose搜索实例对象,之后通过onMatch()回调进行hook逻辑,onComplete()进行结束处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function main(){ Java.perform(function (){ Java.choose(\u0026#34;com.ad2001.frida0x5.MainActivity\u0026#34;,{ onMatch: function (instance){ console.log(instance); instance.flag(1337) }, onComplete: function (){ console.log(\u0026#34;unhook\u0026#34;) } }) }) } setTimeout(main,500) lab6 NewInstance MainActivity.get_flag()实例方法要求传入一个Checker实例对象\n当实例对象的num1==1234且num2==4321时获取flag\nChecker.num1/num2均为实例变量\n搜索MainActivity实例,之后创建Checker实例修改num变量,调用MainActivity.get_flag()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function getclass(className) { return Java.use(className); } function main(){ Java.perform(function (){ Java.choose(\u0026#34;com.ad2001.frida0x6.MainActivity\u0026#34;,{ onMatch: function (instance){ console.log(\u0026#34;hook success\u0026#34;) console.log(instance); var Checker=getclass(\u0026#34;com.ad2001.frida0x6.Checker\u0026#34;).$new() console.log(Checker) Checker.num1.value=1234 Checker.num2.value=4321 instance.get_flag(Checker) }, onComplete: function (){ console.log(\u0026#34;unhook\u0026#34;) } }) }) } setTimeout(main,500) lab7 HookConstructor MainActivity创建时生成Checker实例对象,通过构造函数传递123,321,调用flag方法\nChecker对象默认的构造函数如下\n显然默认情况下构造函数传参不满足getflag条件\nfrida中\u0026lt;class\u0026gt;.$init表示类的构造函数,我们可以hookChecker的构造函数,修改传入的a,b值\n1 2 3 4 5 6 7 8 9 function main(){ Java.perform(function (){ Java.use(\u0026#34;com.ad2001.frida0x7.Checker\u0026#34;).$init.implementation=function (a,b){ console.log(\u0026#34;Origin a=\u0026#34;,a,\u0026#34; b=\u0026#34;,b) this.$init(600,600) } }) } setImmediate(main) 注意需要以spawn模式启动(保证在MainActivity.onCreate执行前hook)\nlab8 HookNaticeFunc 关键函数cmpstr为Native函数,在libfrida0x8.so中定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function main(){ //获取libc的strcmp地址 var strcmp_addr=Module.findExportByName(\u0026#34;libc.so\u0026#34;,\u0026#34;strcmp\u0026#34;); Interceptor.attach(strcmp_addr ,{ onEnter: function (args){ var arg0=Memory.readUtf8String(args[0]);//strcmp(str1,str2) var flag=Memory.readUtf8String(args[1]); //判断参数1确认为点击submit提交输入时,防止输出其他调用处字符串干扰 if(arg0.includes(\u0026#34;hello\u0026#34;)){ console.log(\u0026#34;input: \u0026#34;,arg0,\u0026#34;\\nflag: \u0026#34;,flag) } }, onLeave:function(retval){ } }) } setImmediate(main) lab9 ReplaceNativeFuncRetval hook到check_flag函数后通过retval.replace修改返回地址即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 function main(){ var check_flag_addr= Module.findExportByName(\u0026#34;liba0x9.so\u0026#34;,\u0026#34;Java_com_ad2001_a0x9_MainActivity_check_1flag\u0026#34;) Interceptor.attach(check_flag_addr ,{ onEnter: function (){ console.log(\u0026#34;Hook check_flag success \u0026#34;); }, onLeave:function(retval){ console.log(\u0026#34;origin retval=\u0026#34;,retval); retval.replace(1337) } }) } setImmediate(main) lab10 CallNativeFunc MainActivity只能看到stringFromJNI,但跟进发现该函数只返回\u0026quot;Hello Hackers\u0026quot;\n搜索发现libfrida0xa.so存在一个导出的get_flag函数,没有被调用\n通过基址+偏移得到函数真实地址,再通过NativeFunction创建函数对象,之后直接调用即可再logcat看到flag\n1 2 3 4 5 6 7 8 9 10 function main(){ //lib加载基址+get_flag偏移=真实地址 //get_flag的Native名称为_Z8get_flagii var addr = Module.findBaseAddress(\u0026#34;libfrida0xa.so\u0026#34;).add(0x1dd60) var get_flag_ptr = new NativePointer(addr);//Native层指针 //获取Native函数对象 参数分别为函数指针,返回值类型,参数类型列表 const get_flag = new NativeFunction(get_flag_ptr, \u0026#39;void\u0026#39;, [\u0026#39;int\u0026#39;, \u0026#39;int\u0026#39;]); get_flag(1,2); } setTimeout(main,500) lab11 PatchNativeInstruction 调用Native函数getFlag\n此处为永假跳转,patch掉if跳转逻辑即可绕过\n获取到目标patch地址后,通过Memory.protect取消页面保护, 再创建对应架构的Writer,通过writer修改指令即可\n方法1 直接nop b.ne\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function main(){ var addr = Module.findBaseAddress(\u0026#34;libfrida0xb.so\u0026#34;).add(0x15248);//b.ne指令地址 Memory.protect(addr, 0x1000, \u0026#34;rwx\u0026#34;);//修改页面保护属性为可读可写可执行 var writer = new Arm64Writer(addr); // 创建Writer对象 try { writer.putNop()//直接nop b.ne跳转 注意arm64的nop=0xD503201F,长度为4,只需要调用一次即可 writer.flush();//刷新缓冲区,保证成功写入指令 console.log(`Nop instruction inserted at ${addr}`); } finally { writer.dispose(); } } setTimeout(main,500) 方法2 修改b.ne跳转地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function main(){ var addr = Module.findBaseAddress(\u0026#34;libfrida0xb.so\u0026#34;).add(0x15248);//b.ne指令地址 Memory.protect(addr, 0x1000, \u0026#34;rwx\u0026#34;);//修改页面保护属性为可读可写可执行 var writer = new Arm64Writer(addr); // 创建Writer对象 var target = Module.findBaseAddress(\u0026#34;libfrida0xb.so\u0026#34;).add(0x15250);//跳转的目标地址 try { writer.putBImm(target); //B target writer.flush();//刷新缓冲区,保证成功写入指令 console.log(`Branch instruction inserted at ${addr}`); } finally { writer.dispose(); } } setTimeout(main,500) 五. FridaHook进阶 Frida的数据结构 数组 frida会自动将js字符串转换为java字符串,但传递基本数据类型时,不会转换成封装类型,frida提供了api进行转换:\nJava.array(\u0026ldquo;Ljava.lang.Object;\u0026rdquo;\u0026hellip;)\n1 2 3 4 5 6 7 8 9 10 11 function main(){ Java.perform(function (){ var Integer=Java.use(\u0026#34;java.lang.Integer\u0026#34;); var Boolean=Java.use(\u0026#34;java.lang.Boolean\u0026#34;); var strarr=Java.array( \u0026#34;Ljava.lang.String;\u0026#34;, [\u0026#34;hello\u0026#34;,Boolean.$new(true),Integer.$new(666)] ) }) } setTimeout(main,500) 打印/枚举操作 Show StackTrace 1 2 3 4 5 6 7 8 9 10 function showStacks(){ console.log(\u0026#34;====================StackTraceStart====================\u0026#34;); console.log( Java.use(\u0026#34;android.util.Log\u0026#34;) .getStackTraceString( Java.use(\u0026#34;java.lang.Throwable\u0026#34;).$new() ) ); console.log(\u0026#34;=====================StackTraceEnd=====================\u0026#34;); } 枚举类的所有属性和方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function main(){ Java.perform(function (){ var mainActivity=Java.use(\u0026#34;com.ad2001.frida0x6.MainActivity\u0026#34;) //以下均为Java.class自带的方法 var methods=mainActivity.class.getDeclaredMethods(); //方法 var constructors=mainActivity.class.getDeclaredConstructors(); //构造函数 var fields=mainActivity.class.getDeclaredFields(); //字段 var classes=mainActivity.class.getDeclaredClasses(); //内部类 console.log(\u0026#34;\\n==========methods==========\u0026#34;); for(let i=0;i\u0026lt;methods.length;i++){ console.log(methods[i].getName()); } console.log(\u0026#34;\\n==========constructors==========\u0026#34;); for(let i=0;i\u0026lt;constructors.length;i++){ console.log(constructors[i].getName()); } console.log(\u0026#34;\\n==========fields==========\u0026#34;); for(let i=0;i\u0026lt;fields.length;i++){ console.log(fields[i].getName()); } console.log(\u0026#34;\\n==========classes==========\u0026#34;); for(let i=0;i\u0026lt;classes.length;i++){ console.log(classes[i].getName()); } }) } setTimeout(main,500) 打印类/实例的详细信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 function printClassMethods(Class){ var methods=Class.class.getDeclaredMethods(); //方法 console.log(\u0026#34;\\n==========methods==========\u0026#34;); for(var i=0;i\u0026lt;methods.length;i++){ var methodParams=methods[i].getParameterTypes() var methodReturnType=methods[i].getReturnType() var methodName=methods[i].getName(); console.log(methodReturnType+\u0026#34; \u0026#34;+methodName+\u0026#34;(\u0026#34;+methodParams+\u0026#34;)\u0026#34;); } } function printClassFields(Class){ var fields=Class.class.getDeclaredFields(); //字段 console.log(\u0026#34;\\n==========fields==========\u0026#34;); for(var i=0;i\u0026lt;fields.length;i++){ var fieldName=fields[i].getName(); var fieldType=fields[i].getType(); console.log(fieldType,fieldName); } } function printInstanceMethods(Instance){ printClassMethods(Instance) } function printInstanceFields(Instance){ var fields=Instance.class.getDeclaredFields(); //字段 console.log(\u0026#34;\\n==========fields==========\u0026#34;); for(var i=0;i\u0026lt;fields.length;i++){ var fieldName=fields[i].getName(); var fieldType=fields[i].getType(); var fieldValue=Instance[fieldName].value; console.log(fieldType,fieldName,\u0026#34;=\u0026#34;,fieldValue); } } //打印实例详细信息 function printInstance(Instance){ printInstanceFields(Instance) printInstanceMethods(Instance) } //打印类的详细信息 function printClass(Class){ printClassFields(Class) printClassMethods(Class) } 枚举所有已加载类 1 2 3 4 5 6 7 function main(){ Java.perform(function (){ var classes=Java.enumerateLoadedClassesSync()//string[]数组 console.log(classes.join(\u0026#34;\\n\u0026#34;))//每个元素添加换行打印 }) } setTimeout(main,500) Hook Java类/方法 hook内部类和匿名类 内部类通过$classname, 匿名类通过$classnum, classnum编号和匿名类的创建顺序有关,例如:\n1 2 3 4 5 6 7 function main(){ Java.perform(function (){ var innerClass=Java.use(\u0026#34;com.example.app.MainActivity$InnerClass\u0026#34;) var anonymousClass=Java.use(\u0026#34;com.example.app.MainActivity$6\u0026#34;) }) } setTimeout(main,500) hook类的所有方法 hook类的所有方法,包括方法的所有重载\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function main(){ Java.perform(function (){ function hookFunc(methodName){ console.log(\u0026#34;hook\u0026#34;+methodName); let overloadsArr=mainActivity[methodName].overloads;//获取指定方法的所有重载 for(let i=0;i\u0026lt;overloadsArr.length;i++){//hook所有重载 console.log(\u0026#34;Hook all overloads start\u0026#34;) overloadsArr[i].implementation=function(){ let params=\u0026#34;\u0026#34;; for(let j=0;j\u0026lt;arguments.length;j++){ params+=arguments[j]+\u0026#34; \u0026#34;//存储参数 } console.log(methodName+\u0026#34;is called!Params is:\u0026#34;+params); return this[methodName].apply(this, params);//针对不同重载返回所有参数 } } } var mainActivity=Java.use(\u0026#34;com.ad2001.frida0x6.MainActivity\u0026#34;) var methods=mainActivity.class.getDeclaredMethods(); //方法 for(let i=0;i\u0026lt;methods.length;i++){ let methodName=methods[i].getName(); hookFunc(methodName) } }) } setImmediate(main) 注册java类并调用 Java.registerClass\n参照官方文档\n使用JSON格式创建类,其中一般方法可以直接写代码,重载方法以数组形式分别编写implementation\n注册成功后便可以调用,该api适合简单场景,复杂场景适合注入dex\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 const MyWeirdTrustManager = Java.registerClass({ name: \u0026#39;com.example.MyWeirdTrustManager\u0026#39;, superClass: SomeBaseClass, implements: [X509TrustManager], fields: { description: \u0026#39;java.lang.String\u0026#39;, limit: \u0026#39;int\u0026#39;, }, methods: { $init() { console.log(\u0026#39;Constructor called\u0026#39;); }, checkClientTrusted(chain, authType) { console.log(\u0026#39;checkClientTrusted\u0026#39;); }, checkServerTrusted: [{ returnType: \u0026#39;void\u0026#39;, argumentTypes: [\u0026#39;[Ljava.security.cert.X509Certificate;\u0026#39;, \u0026#39;java.lang.String\u0026#39;], implementation(chain, authType) { console.log(\u0026#39;checkServerTrusted A\u0026#39;); } }, { returnType: \u0026#39;java.util.List\u0026#39;, argumentTypes: [\u0026#39;[Ljava.security.cert.X509Certificate;\u0026#39;, \u0026#39;java.lang.String\u0026#39;, \u0026#39;java.lang.String\u0026#39;], implementation(chain, authType, host) { console.log(\u0026#39;checkServerTrusted B\u0026#39;); return null; } }], getAcceptedIssuers() { console.log(\u0026#39;getAcceptedIssuers\u0026#39;); return []; }, } }); hook只在指定函数内生效 部分函数调用可能比较频繁,hook后可能导致崩溃,此时需要再制定范围内hook\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 function main(){ Java.perform(function (){ var mainActivity=Java.use(\u0026#34;com.xiaojianbang.app.MainActivity\u0026#34;); var stringBuilder=Java.use(\u0026#34;java.lang.StringBuilder\u0026#34;); mainActivity.generateAESKey.implementation=function (){ console.log(\u0026#34;Hook MainActivity generateAESKey Succeeded!\u0026#34;); //在执行generateAESKey时,对StringBuilder进行hook stringBuilder.toString.implementation=function (){ console.log(\u0026#34;Hook StringBuilder Succeeded!\u0026#34;) var result=this.toString() console.log(result)//打印原始数据 return result; } var result=this.generateAESKey.apply(this,arguments);//js function.apply(object,argArray) 调用函数 //结束后取消hook 注意一定要先apply调用hook后的generateAESKey //如果unhook stringBuilder 再执行result=this.generateAESKey.apply(this,arguments); //会导致内部对stringBuilder的hook失效,只执行第一行log stringBuilder.toString.implementation=null;//unhook return result; }; }) } setTimeout(main,500) 定位接口/抽象类的实现类 实现接口/抽象类的类,执行到覆写的方法时必定不走父类\n当我们希望定位某个接口/抽象类有哪些实现时,可以遍历所有已加载类\n获取对应class后调用getInterfaces()/getSuperclass()获取对应的实现接口数组/父类\n接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //寻找指定app中指定接口的所有实现 function findInterfaceImplementations(packageName,interfaceName){ var classes=Java.enumerateLoadedClassesSync();//遍历所有已加载的类 //console.log(\u0026#34;classes:\u0026#34;,classes.join(\u0026#34;\\n\u0026#34;)) for(var index in classes){ var className=classes[index];//js的for-in中,index为下标而非元素 if(className.indexOf(packageName)===-1)//不是目标app的类,继续搜索 continue; try{ var clazz=Java.use(className)//获取目标类,并获取所有实现的接口 var interfaces=clazz.class.getInterfaces(); if(interfaces.length===0)//实现的接口为0,跳过 continue; //有实现的接口,判断是否为目标接口 for(var i=0;i\u0026lt;interfaces.length;i++){ //包括目标接口名,打印所有接口数组信息 //注意interfaces为Class\u0026lt;?\u0026gt;[]类型,转换为字符串判断 if(interfaces[i].toString().indexOf(interfaceName)!==-1){ console.log(className,interfaces); } } }catch(e){ console.log(\u0026#34;Didn\u0026#39;t find class\u0026#34;,className); } } } function main(){ Java.perform(function (){ findInterfaceImplementations(\u0026#34;com.xiaojianbang.app\u0026#34;,\u0026#34;com.xiaojianbang.app.TestRegisterClass\u0026#34;); }) } setTimeout(main,500) 抽象类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function findAbstractClassImplementations(packageName,abstractClassName){ var classes=Java.enumerateLoadedClassesSync(); for(var index in classes){ var className=classes[index]; if(className.indexOf(packageName)===-1) continue; try { var superClass=Java.use(className).class.getSuperclass(); if(superClass==null) continue; //一个类只能继承一个父类,故抽象类无需遍历 if(superClass.toString().indexOf(abstractClassName)!==-1){ console.log(className,superClass) } }catch (e){ console.log(\u0026#34;Didn\u0026#39;t find class\u0026#34;,className); } } } function main(){ Java.perform(function (){ findAbstractClassImplementations(\u0026#34;com.xiaojianbang.app\u0026#34;,\u0026#34;com.xiaojianbang.app.TestAbstract\u0026#34;); }) } setTimeout(main,500) Dex操作 注入dex文件 用js写代码不方便,使用java编写类和方法后编译为dex文件并注入,方便调用\n1 2 3 4 5 6 7 8 9 function main(){ Java.perform(function (){ Java.openFile(\u0026#34;/data/local/tmp/patch.dex\u0026#34;).load()//加载dex文件 var MyClass=Java.use(\u0026#34;con.example.app.MyClass\u0026#34;)//获取类 var instance=MyClass.$new()//创建类实例 instance.hello()//调用方法 }) } setTimeout(main,500) hook动态加载的dex 当使用Java.enumerateLoadedClassesSync() 枚举已经加载的类,但反编译找不到该类时,说明该类可能是动态加载的,此时需要通过ClassLoader获取该类\nJava.enumerateClassLoaders() 枚举类加载器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function main(){ Java.perform(function (){ Java.enumerateClassLoaders({ onMatch: function (loader){ try{ Java.classFactory.loader=loader;//替换frida默认的classloader var dynamic=Java.use(\u0026#34;com.xiaojianbang.app.Dynamic\u0026#34;); console.log(\u0026#34;dynamic: \u0026#34;,dynamic); dynamic.sayHello.implementation=function (){ console.log(\u0026#34;Hook dynamic.sayHello Success!\u0026#34;); return \u0026#34;glass\u0026#34; } dynamic.$new().sayHello() } catch(e){ console.log(loader) } }, onComplete: function (){ //所有ClassLoader加载完毕时调用 } }) }) } setTimeout(main,500) hook成功\nHook Java数据结构(待完善) HashMap HashMap, LinkedHashMap, HashSet, LinkedHashSet, java.util.concurrent.ConcurrentHashMap\nhook put方法示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 function main(){ Java.perform(function (){ var hashMap=Java.use(\u0026#34;java.util.HashMap\u0026#34;); hashMap.put.implementation=function (key,value){ //注意String key为java类型 if(key.equals(\u0026#34;username\u0026#34;)){ console.log(\u0026#34;hashMap.put: \u0026#34;,key,value); } return this.put(key,value); } }) } setTimeout(main,500) ArrayList ArrayList, Vector, LinkList的add(), addAll(), set()等方法\nString getBytes() isEmpty() 构造函数java.lang.StringFactory\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function main(){ Java.perform(function (){ var string=Java.use(\u0026#34;java.lang.String\u0026#34;); string.getBytes.overload().implementation=function (){ showStacks() var result=this.getBytes(); var newStr=string.$new(result) console.log(\u0026#34;string.getBytes result:\u0026#34;,newStr); return result; } string.getBytes.overload(\u0026#34;java.lang.String\u0026#34;).implementation=function (str){ showStacks(); var result=this.getBytes(str); var newStr=string.$new(result,str) console.log(\u0026#34;string.getBytes result:\u0026#34;,newStr); return result; } }) } setTimeout(main,500) StringFactory String的构造函数实际上调用的是StringFactory\nStringBuilder Hook 标准加密库(待完善) 标准加密库算法\nHook Android组件(待完善) Toast 例如输入的账号密码错误时通过toast提示即可快速定位\nNative Hook 通过Interceptor.attach可以hooknative层函数,不过此时需要传递函数首地址\n1 2 3 4 5 6 7 8 Interceptor.attach(targetAddress, { onEnter: function (args) { // Modify or log arguments if needed }, onLeave: function (retval) { // Modify or log return value if needed } }); 相关API\nModule.enumerateExports(libname)\n遍历lib的导出表,获取导出函数相关信息\nModule.enumerateImports(libname)\n遍历lib的导入表,获取导入函数相关信息\nModule.getExportByName(libname,funcname)\n到指定lib查找指定函数地址,未找到返回异常\nModule.findExportByName(libname,funcname)\n到指定lib查找指定函数地址,未找到返回null\nModule.getBaseAddress(libname)\n获取lib的基址\n主动调用Native函数\n1 2 3 var native_adr = new NativePointer(\u0026lt;address_of_the_native_function\u0026gt;); const native_function = new NativeFunction(native_adr, \u0026#39;\u0026lt;return type\u0026gt;\u0026#39;, [\u0026#39;argument_data_type\u0026#39;]); native_function(\u0026lt;arguments\u0026gt;); 指令patch 使用Writer\nhttps://frida.re/docs/javascript-api/#arm64writer\n其他操作 frida写文件 frida只有写文件没有读文件\n1 2 3 4 5 6 7 8 9 10 function main(){ Java.perform(function (){ var ios=new File(\u0026#34;/sdcard/Download/helloworld.txt\u0026#34;,\u0026#34;w\u0026#34;)//注意路径权限的问题 ios.write(\u0026#34;Hello World!\u0026#34;) ios.flush() ios.close() }) } setTimeout(main,500) 六. FridaTools frida常用工具和插件的安装使用方法\nObjection 由于frida更新较快,需要保证objection版本的发布时间在frida之后\n最新的objection版本为1.11.0,对应的frida版本最大为14.2.14,frida-tools为9.2.2\nobjection注入成功后进入自带的shell页面-REPL\nobjection常用指令 注入目标进程(默认通过usb连接)\n1 2 objection -g com.android.settings explore # -g表示注入 explore表示自动搜索 指定ip和端口注入app\n1 objection -N -h ip -p port -g processName explore 启动前执行hook命令\n1 objection -g processName explore --startup-command \u0026#34;android hooking watch class \u0026lt;path.className\u0026gt;\u0026#34; REPL常用指令 jobs\n1 2 jobs list #查看hook了多少个类 jobs kill \u0026lt;jobId\u0026gt; # unhook Java Hook\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #列出所有已加载类 android hooking list classes #搜索包含关键字的类 android hooking search classes \u0026lt;keyword\u0026gt; #列举类的所有方法 android hooking list classes_methods \u0026lt;path.className\u0026gt; # 查看当前app的所有活动/广播接收器/内容提供器/服务 android hooking list activities/receivers/providers/services #hook类的所有方法(不包括构造方法) android hooking watch class \u0026lt;path.className\u0026gt; #hook类的构造方法 android hooking watch class_method \u0026lt;path.className.$init\u0026gt; #hook指定类方法的所有重载 android hooking watch class_method \u0026lt;path.className.methodName\u0026gt; #hook单个重载函数 android hooking watch class_method \u0026lt;path.className.methodName\u0026gt; \u0026#34;\u0026lt;argsType\u0026gt;\u0026#34; # hook方法的所有参数,返回值,调用栈 --dump-args --dump-return --dump-backtrace Native Hook\n1 2 3 4 5 6 7 8 # 搜索堆中的实例 android heap search instances \u0026lt;className\u0026gt; # 枚举内存中所有模块 memory list modules # 枚举模块的所有导出函数 memory list exports \u0026lt;libname.so\u0026gt; # 结果过多时可以导出到本地文件 memory list exports \u0026lt;libname.so\u0026gt; --json \u0026lt;path.fileName\u0026gt; 其他命令\n1 2 3 4 5 6 # 尝试跳转到对应activity android intent launch_activity #关闭ssl校验 android sslpinning disable #关闭root检测 android root disable WallBreaker 官网https://github.com/hluwa/Wallbreaker\nobjection加载插件\n1 plugin load pluginPath Wallbreaker 搜索类\n1 plugin wallbreaker classsearch \u0026lt;pattern\u0026gt; 搜索对象\n1 plugin wallbreaker objectsearch classdump输出类结构\n1 plugin wallbreaker classdump \u0026lt;classname\u0026gt; objectdump\n1 plugin wallbreaker objectdump \u0026lt;instance\u0026gt; frida-dexdump 七. Frida持久化 手机上使用termux终端运行frida-server\nfrida-inject\nfrida-gadget.so\n优点: 免root使用frida,frida-gadget比较稳定\n缺点: 需要重打包app.可以通过魔改系统,让系统帮忙注入so免去重打包\nfrida-inject 参数\n1 2 3 4 5 6 7 8 9 10 11 12 -D, --device=ID connect to device with the given ID -f, --file=FILE spawn FILE -p, --pid=PID attach to PID -n, --name=NAME attach to NAME -r, --realm=REALM attach in REALM -s, --script=JAVASCRIPT_FILENAME -R, --runtime=qjs|v8 Script runtime to use -P, --parameters=PARAMETERS_JSON Parameters as JSON, same as Gadget -e, --eternalize Eternalize script and exit -i, --interactive Interact with script through stdin --development Enable development mode --version Output version information and exit 推送js脚本到手机端后,使用frida-inject运行脚本注入指定app\n1 ./frida-inject-16.0.19-android-arm64 -n com.example.app -s script.js -e frida-gadget https://github.com/frida/frida/releases?page=4\nfrida-gadget需要将so文件打包到apk,无需root权限\nobjection patchapk 参数介绍\n1 2 3 4 5 -s 指定目标apk文件 -a 指定so的cpu平台 -V 指定gadget.so的版本 -D 反编译时跳过资源 -c 指定gadget的config文件路径 环境需求\naapt\njarsigner\napktool,adb\nAndroid系统对应so平台\n八. FridaPython 为什么需要使用frida的python库\njs的frida操作多用于手工调试,如果需要代码自动化处理则要其他语言接入\nfrida的算法转发和frida的rpc都需要使用python\n算法转发和rpc能使安卓逆向更加便捷\nfrida可以实时和python进行数据交互\npython的各种哭让代码编写更加简单\n注意: python中的js脚本无法实时更新,必须重新运行py脚本\npython连接设备 attach方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import frida,sys jsCode=\u0026#34;\u0026#34;\u0026#34; ...... \u0026#34;\u0026#34;\u0026#34; device = frida.get_usb_device() #获取usb设备 print(\u0026#34;device: \u0026#34;, device) # attach指定进程 注意进程名不一定等于包名,可使用frida-ps判断 process=device.attach(\u0026#34;Frida 0x6\u0026#34;) # process=device.attach(6666)# attach指定pid进程 print(\u0026#34;process: \u0026#34;,process) script=process.create_script(jsCode)# 创建并加载js脚本 script.load() sys.stdin.readline()# 防止命令行关闭 spawn方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import frida,sys jsCode=\u0026#34;\u0026#34;\u0026#34; ...... \u0026#34;\u0026#34;\u0026#34; device = frida.get_usb_device() #获取usb设备 print(\u0026#34;device: \u0026#34;, device) pid=device.spawn(\u0026#34;com.ad2001.frida0x6\u0026#34;)# spawn启动 print(\u0026#34;pid: \u0026#34;, pid) process=device.attach(pid) # 启动后需要附加 print(\u0026#34;process: \u0026#34;,process) device.resume(pid) #阻塞后恢复运行 script=process.create_script(jsCode)# 创建并执行js脚本 script.load() sys.stdin.readline()# 防止命令行关闭 连接非标准端口设备 手机端以非标准端口启动frida-server\n-l = \u0026ndash;listen 指定监听地址 0.0.0.0:8888表示任意ip的8888端口\n1 ./data/local/tmp/frida-server-16.0.19-android-arm64 -l 0.0.0.0:8888 通过device_manager添加远程设备\n1 2 3 manager=frida.get_device_manager() device=manager.add_remote_device(\u0026#34;192.168.189.179:8888\u0026#34;) process=device.attach(\u0026#34;Frida 0x6\u0026#34;) frida与python交互 send js脚本中使用send发送数据\npython中使用script.on(\u0026lsquo;message\u0026rsquo;, messageFunc)注册消息处理函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # -*- coding: UTF-8 -*- import frida, sys jsCode = \u0026#34;\u0026#34;\u0026#34; Java.perform(function(){ var RequestUtil = Java.use(\u0026#39;com.dodonew.online.http.RequestUtil\u0026#39;); RequestUtil.encodeDesMap.overload(\u0026#39;java.lang.String\u0026#39;, \u0026#39;java.lang.String\u0026#39;, \u0026#39;java.lang.String\u0026#39;).implementation = function(a, b, c){ console.log(\u0026#39;data: \u0026#39;, a); console.log(\u0026#39;desKey: \u0026#39;, b); console.log(\u0026#39;desIV: \u0026#39;, c); var retval = this.encodeDesMap(a, b, c); console.log(\u0026#39;retval: \u0026#39;, retval); return retval; } var Utils = Java.use(\u0026#39;com.dodonew.online.util.Utils\u0026#39;); Utils.md5.implementation = function(a){ console.log(\u0026#39;MD5 string: \u0026#39;, a); var retval = this.md5(a); send(retval); return retval; } }); \u0026#34;\u0026#34;\u0026#34; # 接收send发送来的数据用于处理 注意必须为2个参数 def messageFunc(message, data): # print(message) # 当type为send时打印 if message[\u0026#34;type\u0026#34;] == \u0026#39;send\u0026#39;: print(u\u0026#34;[*] {0}\u0026#34;.format(message[\u0026#39;payload\u0026#39;])) else: print(message) device = frida.get_usb_device() process = device.attach(\u0026#39;嘟嘟牛在线\u0026#39;) script = process.create_script(jsCode) script.on(\u0026#39;message\u0026#39;, messageFunc) #注册message事件,参数1不能改,参数2随意 script.load() print(\u0026#34;Run Script\u0026#34;) sys.stdin.read() 效果如下,成功接收消息并打印\nrecv python中使用script.post( {name : data} )发送数据\njs中使用recv(function(obj) { console.log(obj.data) } ).wait()等待接收并进行消息处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 # -*- coding: UTF-8 -*- import frida, sys import time jsCode = \u0026#34;\u0026#34;\u0026#34; Java.perform(function(){ var RequestUtil = Java.use(\u0026#39;com.dodonew.online.http.RequestUtil\u0026#39;); RequestUtil.encodeDesMap.overload(\u0026#39;java.lang.String\u0026#39;, \u0026#39;java.lang.String\u0026#39;, \u0026#39;java.lang.String\u0026#39;).implementation = function(a, b, c){ console.log(\u0026#39;data: \u0026#39;, a); console.log(\u0026#39;desKey: \u0026#39;, b); console.log(\u0026#39;desIV: \u0026#39;, c); var retval = this.encodeDesMap(a, b, c); console.log(\u0026#39;retval: \u0026#39;, retval); return retval; } var Utils = Java.use(\u0026#39;com.dodonew.online.util.Utils\u0026#39;); Utils.md5.implementation = function(a){ console.log(\u0026#39;MD5 string: \u0026#39;, a); var retval = this.md5(a); send(retval); //接收消息并处理 recv(function(obj){ console.log(JSON.stringify(obj)); console.log(\u0026#34;Python:\u0026#34;, obj.data); retval = obj.data; }).wait(); return retval; } }); \u0026#34;\u0026#34;\u0026#34; def messageFunc(message, data): print(message) if message[\u0026#34;type\u0026#34;] == \u0026#39;send\u0026#39;: print(u\u0026#34;[*] {0}\u0026#34;.format(message[\u0026#39;payload\u0026#39;])) time.sleep(10) # 发送数据给js 此处的script是process.create_script后的变量script script.post({\u0026#34;data\u0026#34;: \u0026#34;0e8315152843b943563031945032e957\u0026#34;}) else: print(message) process = frida.get_usb_device().attach(\u0026#39;嘟嘟牛在线\u0026#39;) script = process.create_script(jsCode) script.on(\u0026#39;message\u0026#39;, messageFunc) #注册消息事件 script.load() print(\u0026#34;Run Script\u0026#34;) sys.stdin.read() 效果如下\nfrida RPC RPC即远程调用\njs代码中使用rpc.exports={\n​\trpcfunc : jsfunc\n};\n导出rpc接口\npython代码中使用script.exports_sync.rpcfunc()调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 # -*- coding: UTF-8 -*- import frida, sys,time jsCode = \u0026#34;\u0026#34;\u0026#34; Java.perform(function(){ var RequestUtil = Java.use(\u0026#39;com.dodonew.online.http.RequestUtil\u0026#39;); RequestUtil.encodeDesMap.overload(\u0026#39;java.lang.String\u0026#39;, \u0026#39;java.lang.String\u0026#39;, \u0026#39;java.lang.String\u0026#39;).implementation = function(a, b, c){ console.log(\u0026#39;data: \u0026#39;, a); console.log(\u0026#39;desKey: \u0026#39;, b); console.log(\u0026#39;desIV: \u0026#39;, c); var retval = this.encodeDesMap(a, b, c); console.log(\u0026#39;retval: \u0026#39;, retval); return retval; } var Utils = Java.use(\u0026#39;com.dodonew.online.util.Utils\u0026#39;); Utils.md5.implementation = function(a){ console.log(\u0026#39;MD5 string: \u0026#39;, a); var retval = this.md5(a); console.log(\u0026#39;retval: \u0026#39;, retval); return retval; } }); //用于主动调用 function test(data){ var result = \u0026#34;\u0026#34;; Java.perform(function(){ result = Java.use(\u0026#39;com.dodonew.online.util.Utils\u0026#39;).md5(data); }); return result; } //通过rpc.exports导出接口rpcFunc rpc.exports = { rpcfunc: test //rpc接口和js函数映射 }; \u0026#34;\u0026#34;\u0026#34; # 注意js导出的rpcFunc在python中的写法为rpc_func,即大写字母前使用下划线 device = frida.get_usb_device() print(\u0026#34;device: \u0026#34;, device) pid = device.spawn(\u0026#34;com.dodonew.online\u0026#34;) # 以挂起方式创建进程 print(\u0026#34;pid: \u0026#34;, pid) process = device.attach(pid) print(\u0026#34;process: \u0026#34;, process) script = process.create_script(jsCode) script.load() device.resume(pid) # 加载完脚本, 恢复进程运行 time.sleep(1) # 休眠1秒,防止app未加载完毕就主动调用 # python主动调用rpc函数 通过script.exports_sync.rpcfunc() result = script.exports_sync.rpcfunc(\u0026#39;equtype=ANDROID\u0026amp;loginImei=Androidnull\u0026amp;timeStamp=1626790668522\u0026amp;userPwd=a12345678\u0026amp;username=15968079477\u0026amp;key=sdlkjsdljf0j2fsjk\u0026#39;) print(result) print(\u0026#34;Run Script\u0026#34;) sys.stdin.read() 效果如下\nfrida 算法转发 有时我们可能想用其他语言实现rpc，但是其他语言不一定有frida的rpc库，我们可以把python作为中间层，用python开启一个服务，封装并提供接口,这样就可以让别的语言访问\n首先需要两个库运行web服务\n1 2 pip install uvicorn pip install fastapi 代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import requests, json import frida import uvicorn import fastapi jsCode=\u0026#34;\u0026#34;\u0026#34; function hookTest(username, passward){ var result; Java.perform(function(){ var time = new Date().getTime(); var signData = \u0026#39;equtype=ANDROID\u0026amp;loginImei=Android352689082129358\u0026amp;timeStamp=\u0026#39; + time + \u0026#39;\u0026amp;userPwd=\u0026#39; + passward + \u0026#39;\u0026amp;username=\u0026#39; + username + \u0026#39;\u0026amp;key=sdlkjsdljf0j2fsjk\u0026#39;; var Utils = Java.use(\u0026#39;com.dodonew.online.util.Utils\u0026#39;); var sign = Utils.md5(signData).toUpperCase(); console.log(\u0026#39;sign: \u0026#39;, sign); var encryptData = \u0026#39;{\u0026#34;equtype\u0026#34;:\u0026#34;ANDROID\u0026#34;,\u0026#34;loginImei\u0026#34;:\u0026#34;Android352689082129358\u0026#34;,\u0026#34;sign\u0026#34;:\u0026#34;\u0026#39;+ sign +\u0026#39;\u0026#34;,\u0026#34;timeStamp\u0026#34;:\u0026#34;\u0026#39;+ time +\u0026#39;\u0026#34;,\u0026#34;userPwd\u0026#34;:\u0026#34;\u0026#39; + passward + \u0026#39;\u0026#34;,\u0026#34;username\u0026#34;:\u0026#34;\u0026#39; + username + \u0026#39;\u0026#34;}\u0026#39;; var RequestUtil = Java.use(\u0026#39;com.dodonew.online.http.RequestUtil\u0026#39;); var Encrypt = RequestUtil.encodeDesMap(encryptData, \u0026#39;65102933\u0026#39;, \u0026#39;32028092\u0026#39;); console.log(\u0026#39;Encrypt: \u0026#39;, Encrypt); result = Encrypt; }); return result; } rpc.exports = { rpcfunc: hookTest }; \u0026#34;\u0026#34;\u0026#34; process = frida.get_device_manager().add_remote_device(\u0026#39;192.168.189.179:27042\u0026#39;).attach(\u0026#34;嘟嘟牛在线\u0026#34;) script = process.create_script(jsCode) print(\u0026#39;[*] Running Script\u0026#39;) script.load() cipherText = script.exports_sync.rpcfunc(\u0026#39;12345678901\u0026#39;, \u0026#39;a123456789\u0026#39;)# 测试脚本是否成功运行 print(cipherText) # 开启web服务处理请求 app = fastapi.FastAPI()# 创建FastAPI实例 @app.get(\u0026#34;/get\u0026#34;)# 定义一个get请求的路由,收到get请求后执行下面的异步函数 async def getEchoApi(item_id, item_user, item_pass): result = script.exports_sync.rpcfunc(item_user, item_pass) # 处理用户名和密码后返回结果 return {\u0026#34;item_id\u0026#34;: item_id, \u0026#34;item_retval\u0026#34;: result} if __name__ == \u0026#39;__main__\u0026#39;: uvicorn.run(app, port = 8080)#使用uvicorn运行FastAPI引用,在8080端口监听等待http请求 效果如下\n成功开启服务\n发起正确的get请求即可收到返回结果\n九. Frida逆向实战 过vpn检测 课件 屿秋-检测代理和root.apk\n可以发现弹出通知提示网络异常以及Toast提示安全证书异常\n我们可以通过hook Toast定位异常检测点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function showStacks(){ console.log(\u0026#34;====================StackTraceStart====================\u0026#34;); console.log( Java.use(\u0026#34;android.util.Log\u0026#34;) .getStackTraceString( Java.use(\u0026#34;java.lang.Throwable\u0026#34;).$new() ) ); console.log(\u0026#34;=====================StackTraceEnd=====================\u0026#34;); } function main(){ Java.perform(function (){ var toast=Java.use(\u0026#34;android.widget.Toast\u0026#34;); toast.show.implementation=function(){ showStacks(); console.log(\u0026#34;Toast.show: \u0026#34;); return this.show(); } }) } setTimeout(main,500) Toast栈回溯信息如下\n不难看出可能和以下两个类有关\n1 2 com.jtxc.common.viewmodel.BaseViewModel.b com.jtxc.common.viewmodel.HomeViewModel$2.accept 但jadx静态分析时无法发现这两个类,说明可能有加壳,查壳发现是腾讯加固\n破解极简记账VIP 十. Frida API Java Bridge https://frida.re/docs/javascript-api/#java\nJava.androidVersion 返回Android版本\nJava.enumerateLoadedClasses(callbacks)\n遍历已经加载的类,callbacks如下\n1 2 3 4 callbacks{ onMatch(name,handle), //可用Java.cast()将handle转换为指定class onComplete() } Java.enumerateClassLoaders(callbacks)\n遍历java vm中的classloader,callback如下\n1 2 3 4 classback{ onMatch(loader), //java.lang.ClassLoader onComplete() } Java.enumerateMethods(query)\n查询匹配条件的方法\n用法如下\n1 2 3 4 5 6 7 8 function main(){ Java.perform(function (){ const groups=Java.enumerateMethods(\u0026#34;\u0026lt;class\u0026gt;!\u0026lt;method\u0026gt;/isu\u0026#34;); //such as query=\u0026#34;*youtube*!on*/is\u0026#34; console.log(JSON.stringify(groups,null,2)); }) } setTimeout(main,500) 支持通配符*用于关键字搜索\n/后跟参数\ni: 大小写不敏感\ns: 包括方法签名信息\nu: 忽略系统类\nJava.perform(function)\n确保在主线程中执行函数\nJava.use(className)\n获取Java类\nJava.openClassFile(filePath)\n打开.dex文件,返回类有load()和getClassNames()方法\nJava.choose(className, callbacks)\n遍历实例,callbacks={onMatch(instance),onComplete()}\nJava.cast(handle, klass)\n类型转换\nJava.array(type, elements)\n创建指定类型的数组\nJava.vm 对象\ngetEnv()获取JNIEnv\nperform(function)执行函数\nJava.isMainThread()\n检测是否运行在主线程\nMemory https://frida.re/docs/javascript-api/#memory\nMemory.scan(address, size, pattern, callbacks)\n在指定范围内扫描指定匹配串,callbacks{onMatch(address,size),onComplete()}\nMemory.alloc(size[, options])\n申请指定大小空间,返回NativePointer\nMemory.copy(dst, src, n)\nMemory.protect(address, size, protection)\n修改内存保护属性\nNativePointer https://frida.re/docs/javascript-api/#nativepointer\nnew NativePointer(str)\n创建指针指向str描述的地址处,可用简写形式ptr(str)\n.isNull()\n判断是否为空指针\nadd(rhs),sub(rhs),and(rhs),or(rhs),xor(rhs)\n对NativePointer执行对应运算并返回新的NativePointer\nrhs: 可以是数字或者NativePointer\nshr(n),shl(n)\n右移/左移指定bits\ntoString([radix = 16])\n转换为指定进制字符串(默认hex)\nreadPointer()/writePointer(ptr)\n向该指针指向的内存区域读/写一个指针\nreadS8(), readU8(), readS16(), readU16(), readS32(), readU32(), readShort(), readUShort(), readInt(), readUInt(), readFloat(), readDouble(), readS64(), readU64(), readLong(), readULong()\n读取指定类型的数据\nwriteS8(value), writeU8(value), writeS16(value), writeU16(value), writeS32(value), writeU32(value), writeShort(value), writeUShort(value), writeInt(value), writeUInt(value), writeFloat(value), writeDouble(value), writeS64(value), writeU64(value), writeLong(value), writeULong(value)\n写入指定类型数据\nreadByteArray(length)/writeByteArray(bytes)\n读/写字节数组\nreadCString([size = -1]), readUtf8String([size = -1]), readUtf16String([length = -1])\n读取字节流并转换为ASCII/UTF-8/UTF-16字符串\nwriteUtf8String(str), writeUtf16String(str)\n写入字符串\nModule https://frida.re/docs/javascript-api/#module\nenumerateImports(libname)\nenumerateExports(libname)\nenumerateSymbols(libname)\nenumerateRanges(protection)\nenumerateSections(libname)\nenumerateDependencies(libname)\nfindExportByName(exportName)\ngetExportByName(exportName)\nModule.load(path)\n加载指定模块\nModule.findBaseAddress(name)/Module.getBaseAddress(name)\n未找到时,find返回null,get返回exception\nModule.findExportByName(moduleName|null, exportName)\nModule.getExportByName(moduleName|null, exportName)\n返回指定模块导出函数的绝对地址\nDebug Symbol DebugSymbol.fromAddress(address)/DebugSymbol.fromName(name) 官网: DebugSymbol 功能: 查找address/name对应的调试信息并作为对象返回 该对象包含:\n1 2 3 4 5 address //该符号对应地址 作为NativePointer name //符号名称 moudleName //拥有该符号的模块名称 fileName //拥有该符号的文件名 lineNumber //行号 Common API https://frida.re/docs/javascript-api/#java\nhttps://frida.re/docs/javascript-api/#interceptor\nhttps://frida.re/docs/javascript-api/#instruction\nhttps://frida.re/docs/javascript-api/#arm64writer\nhttps://frida.re/docs/javascript-api/#kernel\nTable Of API Contents Runtime information Frida Script Process, Thread, Module and Memory Thread Process Module ModuleMap Memory MemoryAccessMonitor CModule ApiResolver DebugSymbol Kernel Data Types, Function and Callback Int64 UInt64 NativePointer ArrayBuffer NativeFunction NativeCallback SystemFunction Network Socket SocketListener SocketConnection File and Stream File IOStream InputStream OutputStream UnixInputStream UnixOutputStream Win32InputStream Win32OutputStream Database SqliteDatabase SqliteStatement Instrumentation Interceptor Stalker ObjC Java CPU Instruction Instruction X86Writer X86Relocator x86 enum types ArmWriter ArmRelocator ThumbWriter ThumbRelocator ARM enum types Arm64Writer Arm64Relocator AArch64 enum types MipsWriter MipsRelocator MIPS enum types Other Console Hexdump Shorthand Communication between host and injected process Timing events Garbage collection References Frida-Labs\n零基础一站式安卓逆向2022\n","date":"2024-09-19T14:00:04+08:00","permalink":"https://example.com/p/fridastudy/","title":"FridaStudy"},{"content":"第1章 启程 1.1 Andorid系统架构 Andorid大致可以分为四层架构: Linux内核层,系统运行库层,应用框架层和应用层\nLinux内核层\nAndroid系统是基于Linux内核开发的，这层为Android设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、WIFI驱动、电源驱动等。也就是通过底层代码去调用硬件设备。\n系统运行库层\n这一层主要是C/C++实现，为安卓系统提供一些特性支持。比如SQLite库提供了对数据库的支持，OpenGl｜ES库提供了对3D绘图的支持等。另外这一层还有一个安卓运行时库，是对上层Java的支持，上层Java最终会调用到该层的C/C++实现函数，其实也就是同一个功能函数的更底层版本。\n应用框架层\n提供了构建程序时使用的各种Java层API\n应用层\n所有安装在手机上的应用程序都属于这一层,例如系统自带的联系人,短信等程序\n1.2 Andorid应用开发特色 四大组件\nAndroid系统的四大组件分别是：\n活动(Activity)：在应用中能看到的东西都是放在活动中。\n服务(Service)：无法看到，它会一直在后台运行，即使用户退出了应用，服务可以继续运行。\n广播接收器(Broadcast Receiver)：允许应用接受来自各处的广播信息，比如电话、短信等。\n内容提供器(Content Provider)：为应用程序之间共享数据提供了可能，比如读取系统电话簿中的联系人。\n系统控件\nAndroid系统为开发者提供了丰富的系统控件,使得我们可以很轻松的编写出漂亮界面.当然,不满足系统控件自带的效果也可以定制属于自己的控件\nSQLite数据库\nAndroid系统自带轻量级、运算速度快的嵌入式关系型数据库，支持标准的SQL语法，还可以通过封装好的API进行操作\n多媒体\nAndroid系统提供了丰富的多媒体服务,如音乐,视频,录音,拍照,闹铃等等\n地理位置定位\n现在的安卓手机都内置GPS支持定位\n1.3 搭建开发环境 JDK Android SDK Android Studio 1.4 分析安卓程序 1.4.1 Project结构 .gradle和.idea：这两个目录下放置的都是Android Studio自动生成的一些文件，我们无须关心，也不要去手动编辑。\napp：项目中的代码、资源等内容几乎都是放置在这个目录下的，开发工作也基本都是在这个目录下进行的\nbuild：这个目录你也不需要过多关心，它主要包含了一些在编译时自动生成的文件。\ngradle：这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。Android Studio默认没有启用gradlewrapper的方式，如果需要打开，可以点击Android Studio导航栏→File→Settings→Build, Execution,Deployment→Gradle，进行配置更改。\n.gitignore这个文件是用来将指定的目录或文件排除在版本控制之外的\nbuild.gradle：这是项目全局的gradle构建脚本，通常这个文件中的内容是不需要修改的\ngradle.properties：这个文件是全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本\ngradlew和gradlew.bat：这两个文件是用来在命令行界面中执行gradle命令的，其中gradlew是在Linux或Mac系统中使用的，gradlew.bat是在Windows系统中使用的\nHelloWorld.iml：iml文件是所有IntelliJ IDEA项目都会自动生成的一个文件（Android Studio是基于IntelliJ IDEA开发的），用于标识这是一个IntelliJ IDEA项目，我们不需要修改这个文件中的任何内容\nlocal.properties：这个文件用于指定本机中的Android SDK路径，通常内容都是自动生成的，我们并不需要修改。除非你本机中的Android SDK位置发生了变化，那么就将这个文件中的路径改成新的位置即可\n.settings.gradle：这个文件用于指定项目中所有引入的模块。由于HelloWorld项目中就只有一个app模块，因此该文件中也就只引入了app这一个模块。通常情况下模块的引入都是自动完成的，需要我们手动去修改这个文件的场景可能比较少\n1.4.2 app目录 build：这个目录和外层的build目录类似，主要也是包含了一些在编译时自动生成的文件，不过它里面的内容会更多更杂，我们不需要过多关心\n如果你的项目中使用到了第三方jar包，就需要把这些jar包都放在libs目录下，放在这个目录下的jar包都会被自动添加到构建路径里去\nandroidTest：此处是用来编写Android Test测试用例的，可以对项目进行一些自动化测试\n毫无疑问，java目录是放置我们所有Java代码的地方，展开该目录，你将看到我们刚才创建的the_first_demo文件就在里面\nres：这个目录下的内容就有点多了。简单点说，就是你在项目中使用到的所有图片、布局、字符串等资源都要存放在这个目录下。当然这个目录下还有很多子目录，图片放在drawable目录下，布局放在layout目录下，字符串放在values目录下，所以你不用担心会把整个res目录弄得乱糟糟的\nAndroidManifest.xml：这是你整个Android项目的配置文件，你在程序中定义的所有四大组件都需要在这个文件里注册，另外还可以在这个文件中给应用程序添加权限声明\ntest：此处是用来编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式\ngitignore：这个文件用于将app模块内的指定的目录或文件排除在版本控制之外，作用和外层的.gitignore文件类似\nbuild.gradle：这是app模块的gradle构建脚本，这个文件中会指定很多项目构建相关的配置\nproguard-rules.pro：这个文件用于指定项目代码的混淆规则，当代码开发完成后打成安装包文件，如果不希望代码被别人破解，通常会将代码进行混淆，从而让破解者难以阅读\n1.5 Log Utils Android中的日志工具类是Log(android.util.Log),可以方便我们打印一些信息进行调试。这个类一共提供了5个方法供我们打印日志：\nLog.v()\n用于打印那些最为琐碎的、意义最小的日志信息。对应级别verbose，是Android日志里面级别最低的一种\nLog.d()\n用于打印一些调试信息，这些信息对你调试程序和分析问题应该是有帮助的。对应级别debug，比verbose高一级\nLog.i()\n用于打印一些比较重要的数据，这些数据应该是你非常想看到的、可以帮你分析用户行为数据。对应级别info，比debug高一级\nLog.w()\n用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修复一下这些出现警告的地方。对应级别warn，比info高一级\nLog.e()\n用于打印程序中的错误信息，比如程序进入到了catch语句当中。当有错误信息打印出来的时候，一般都代表你的程序出现严重问题了，必须尽快修复。对应级别error，比warn高一级\n第2章 探究活动 2.1手动创建主活动 创建项目时选择NoActivity即可创建空活动项目\n2.1.1 创建空白Activity 然后手动在app\u0026gt;src\u0026gt;main\u0026gt;java文件夹下新建一个空白Activity\nGenerate a Layout File的作用是自动创建布局文件\nLauncher Activity是将该Activity设置为主活动文件\n2.1.2 创建布局文件 创建活动对应的布局文件\n默认布局为ConstraintLayout 感觉比较复杂可以手动更换为LinearLayout\n注意添加andorid:orientation标签\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; \u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/Hello\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;HelloWorld\u0026#34; android:textAlignment=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 2.1.3 注册主活动 再到AndroidManifest.xml文件中注册主活动\n创建活动时会自动注册一些相关信息 添加下列两行代码注册为主活动\n1 2 3 4 \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; 最后通过setContentView方法将布局和活动绑定\n2.2 Intent跳转活动 2.2.1 显式跳转 使用Intent 类创建 第一个参数为当前活动this指针,第二个参数为跳转目标活动类\n最后启动活动即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main_layout); Context context=this;//环境 上下文 Toast.makeText(this,\u0026#34;Hello\u0026#34;,Toast.LENGTH_LONG).show(); Button button1=(Button)findViewById(R.id.Button1); button1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) {//显式intent 很明显可以看到跳转逻辑 Intent intent=new Intent(MainActivity.this,SecondActivity.class); startActivity(intent); } }); } } 布局\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;h5 android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:gravity=\u0026#34;center\u0026#34; \u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/Button1\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Jump to Second Activity\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 2.2.2 隐式跳转 隐式跳转首先要到AndoridManifest.xml文件中给活动设置intent-filter\n添加action和category 这里都可以自定义\n创建第二个活动,跳转到第一个活动中\n每个intent只能指定一个action,可以指定多个category\n必须当所有条件全部匹配时才能成功查找并跳转\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class SecondActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); Button button2=(Button)findViewById(R.id.Button2); button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { //每个intent只能指定一个action Intent intent=new Intent(\u0026#34;com.example.MainActivity.ACTION_START\u0026#34;); //可以指定多个category intent.addCategory(\u0026#34;android.intent.category.DEFAULT\u0026#34;); startActivity(intent); } }); } } 布局\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34; tools:context=\u0026#34;.SecondActivity\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/Button2\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Jump to first activity\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 2.2.3 更多隐式Intent的用法 跳转到网页\n假设我们的应用程序需要展示一个网页,此时并不需要自己实现浏览器,只需要调用系统浏览器打开网页即可\n1 2 3 4 5 public void onClick(View v) {//跳转到其他页面 Intent intent=new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(\u0026#34;https://www.baidu.com\u0026#34;)); startActivity(intent); } Intent.ACTION_VIEW是一个安卓系统内置动作\nUri.parse()方法将网址字符串解析成一个Uri对象\nsetData方法接收Uri对象并指定intent正在操作的数据\n我们也可以在intent-filter标签内设置data标签,用于指定当前活动能够响应什么数据\ndata中可以配置内容如下\n1 2 3 4 5 android:scheme\t//用于指定数据协议部分 android:host\t//指定数据主机部分 android:port\t//指定数据端口 android:path\t//指定主机和端口后 android:mimeType\t//指定可以处理的数据类型 只有data标签的内容和intent中携带的data完全一致时才可以响应,一般data中不会指定过多内容\n跳转到程序\n1 2 3 4 5 public void onClick(View v) {//跳转到其他页面 Intent intent=new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(\u0026#34;tel:10086\u0026#34;)); startActivity(intent); } 点击按钮后跳转到电话并且自动输入10086\n2.2.4 向下一个活动传递数据 Intent启动活动时还可以传递数据\n可以利用**intent.putExtra()**方法及其重载,将数据暂存在intent中,启动了另一个活动后只需要从intent中取出数据即可\n参数以键值对形式传递\n主活动,使用putExtra方法传递参数\n1 2 3 4 5 6 7 8 9 button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { String data=\u0026#34;HelloActivity2!\u0026#34;; Intent intent=new Intent(MainActivity.this,SecondActivity.class); intent.putExtra(\u0026#34;data\u0026#34;,data); startActivity(intent); } }); 目标活动\n首先要getIntent获取intent,再通过键名获取值\n1 2 3 4 5 6 7 8 9 protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); TextView text=(TextView) findViewById(R.id.text); Intent intent=getIntent();//获取intent String data=intent.getStringExtra(\u0026#34;data\u0026#34;); text.setText(data); Log.d(\u0026#34;MainActivityData=\u0026#34;,data); } 2.2.5 返回数据给上一个活动 startActivityForResult()方法启动活动时,会期待目标活动返回一个值回来,参数为intent和请求码,请求码必须是唯一值\n1 2 3 4 5 6 7 8 button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { String data=\u0026#34;HelloActivity2!\u0026#34;; Intent intent=new Intent(MainActivity.this,SecondActivity.class); startActivityForResult(intent,1); } }); 目标活动中创建intent用putExtra添加返回数据,再通过setResult()设置\n这个intent并没有任何跳转的意图,只是用于数据传递而已\n1 2 3 4 5 6 7 8 9 button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent=new Intent(); intent.putExtra(\u0026#34;returnData\u0026#34;,\u0026#34;This is return data\u0026#34;); setResult(RESULT_OK,intent); finish(); } }); 由于使用startActivityForResult启动目标活动,当目标活动被销毁时,会回调上一个活动的onActivityResult()方法\n所以需要在主活动中重写该方法以得到返回数据\n1 2 3 4 5 6 7 8 9 10 11 12 protected void onActicityResult(int requestCode,int resultCode,Intent data){ switch (requestCode){ case 1: if(resultCode==RESULT_OK){ String returnData=data.getStringExtra(\u0026#34;returnData\u0026#34;); Log.d(\u0026#34;SecondActivityRetData=\u0026#34;,returnData); } break; default: } } 2.3 活动的生命周期 2.3.1 返回栈 Android使用Task管理活动,一个Task就是一组放在返回栈(Back Stack)里的活动集合.\n默认情况下,我们启动一个新活动则该活动入栈,并处于栈顶.当按下back键或者调用finish()销毁活动时活动出栈.系统总是将栈顶活动显示给用户\n2.3.2 活动状态 每个活动在生命周期可能有四种状态\n状态 位置 是否可见 系统回收 备注 运行状态 栈顶 可见 一般不回收 暂停状态 栈中 可见 一般不回收 活动仍然存活可见 停止状态 栈中 不可见 可能回收 保留状态和成员变量 销毁状态 移出栈 不可见 倾向回收 2.3.3 活动生存期 Activity类定义了7个回调方法,覆盖活动生命周期各个环节\n方法 调用时机 备注 onCreate() 活动第一次创建时 完成初始化,加载布局,绑定事件等 onStart() 活动由不可见变为可见时 onResume() 活动准备好和用户进行交互时 此时活动必定位于栈顶且处于运行状态 onPause() 系统准备启动或恢复另一个活动时 在该方法中释放消耗CPU的资源,保存关键数据,防止影响新活动 onStop() 活动完全不可见时 如果新活动是对话框式,那么onPause()会执行而onStop不会执行 onRestart() 活动由停止变为运行前 活动重新启动时 onDestory() 活动被销毁前 之后活动变为销毁状态 活动可以分为3种生存期\n完整生存期\n活动在onCreate()和onDestroy()之间经历的,一般在onCreate()完成初始化,onDestroy释放内存\n可见生存期\nonStart()~onStop(),在此期间活动对于用户总是可见的,可能无法和用户交互,但可以管理对用户可见的资源.例如在onStart()加载资源,在onStop()释放资源,保证停止状态的活动不会占用过多内存\n前台生存期\nonResume()~onPause(),此期间活动总处于运行状态,并且可以和用户交互,这是平时看到和接触最多的活动状态\n示意图\n2.3.4 体验活动的生命周期 在MainActivity设置2个button,分别跳转到NormalActivity和DialogActivity,用于观察活动的生命周期\nAndroidManifest.xml 给DialogActivity添加属性指示该活动主题为Dialog类型android:theme=\u0026quot;@style/Theme.AppCompat.Dialog\u0026quot;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;application android:allowBackup=\u0026#34;true\u0026#34; android:dataExtractionRules=\u0026#34;@xml/data_extraction_rules\u0026#34; android:fullBackupContent=\u0026#34;@xml/backup_rules\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:roundIcon=\u0026#34;@mipmap/ic_launcher_round\u0026#34; android:supportsRtl=\u0026#34;true\u0026#34; android:theme=\u0026#34;@style/Theme.CreateActivity\u0026#34; tools:targetApi=\u0026#34;31\u0026#34;\u0026gt; \u0026lt;activity android:name=\u0026#34;.DialogActivity\u0026#34; android:theme=\u0026#34;@style/Theme.AppCompat.Dialog\u0026#34; /\u0026gt; \u0026lt;!-- android:theme=\u0026#34;@android:style/Theme.Dialog\u0026#34; 该标签兼容性有问题--\u0026gt; \u0026lt;activity android:name=\u0026#34;.NormalActivity\u0026#34; android:label=\u0026#34;@string/title_activity_normal\u0026#34; android:theme=\u0026#34;@style/Theme.CreateActivity\u0026#34; /\u0026gt; \u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- exported属性标识活动是否可被外部访问,默认true,入口活动必须设置为true--\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; layout_main.xml 设置2个button用于跳转\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; \u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/start_normal_activity\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Start NormalActivity\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/start_dialog_activity\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Start DialogActivity\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; layout_normal.xml (layout_dialog基本一致,text改动区分即可)\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;This is a normal activity\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 package com.example.createactivity; import android.content.Intent; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; public class MainActivity extends AppCompatActivity { public static String tag=\u0026#34;MainActivity\u0026#34;; // @Override // protected void onSaveInstanceState(@NonNull Bundle outState) { // super.onSaveInstanceState(outState); // String tmpData=\u0026#34;This is tmp data\u0026#34;; // outState.putString(\u0026#34;data_key\u0026#34;,tmpData); // } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.d(tag,\u0026#34;onCerate\u0026#34;); setContentView(R.layout.activity_main); // if(savedInstanceState!=null){ // String tmpData=savedInstanceState.getString(\u0026#34;data_key\u0026#34;); // Log.d(tag, \u0026#34;tmpdata: \u0026#34;+tmpData); // } Button startNormalActivity=findViewById(R.id.start_normal_activity); Button startDialogActivity=findViewById(R.id.start_dialog_activity); startNormalActivity.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Intent intent=new Intent(MainActivity.this, NormalActivity.class); startActivity(intent); } }); startDialogActivity.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Intent intent=new Intent(MainActivity.this,DialogActivity.class); startActivity(intent); } }); } @Override protected void onStart(){ super.onStart(); Log.d(tag,\u0026#34;onStart\u0026#34;); } @Override protected void onResume() { super.onResume(); Log.d(tag,\u0026#34;onResume\u0026#34;); } @Override protected void onPause() { super.onPause(); Log.d(tag, \u0026#34;onPause\u0026#34;); } @Override protected void onStop() { super.onStop(); Log.d(tag, \u0026#34;onStop\u0026#34;); } @Override protected void onDestroy() { super.onDestroy(); Log.d(tag, \u0026#34;onDestroy\u0026#34;); } @Override protected void onRestart() { super.onRestart(); Log.d(tag, \u0026#34;onRestart\u0026#34;); } } 效果如下:\n启动APP时,依次执行onCreate,onStart,onResume方法 跳转到NormalActivity时,执行onPause和onStop方法 返回MainActivity时,执行onRestart,onStart,onResume 跳转到DialogActivity时,执行onPause 返回MainActivity时,执行onResume 关闭APP时,执行onPause,onStop,onDestroy 2.3.5 活动被回收了怎么办 上文说过,当活动进入Stop状态时,可能会被系统回收,假设如下场景:\n有两个活动A,B,在活动A的基础上启动活动B,此时内存不足回收活动A,当用户返回A时会如何?活动A会正常显示,但此时不执行onRestart(),而是执行onCreate(),即此时重新创建活动A.但此时有一个重要问题: 活动A中的临时数据和状态因回收会全部丢失.\n例如在A的文本框中输入了一段文字,但A被回收后文字会消失,需要重新输入.这种情况严重影响用户体验,那么如何解决?可以使用onSaveInstanceState()回调方法,该方法参数为Bundle,在活动被回收前必定调用\n在MainActivity添加该函数,利用Bundle传递数据,类似Intent,需要键值对\n1 2 3 4 5 6 @Override protected void onSaveInstanceState(@NonNull Bundle outState) { super.onSaveInstanceState(outState);//保存实例状态 String tmpData=\u0026#34;This is tmp data\u0026#34;; outState.putString(\u0026#34;data_key\u0026#34;,tmpData); } 添加代码判断是否存在数据待获取\n1 2 3 4 5 6 7 8 9 10 protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.d(tag,\u0026#34;onCerate\u0026#34;); setContentView(R.layout.activity_main); if(savedInstanceState!=null){//已保存实例状态不为空,有数据待获取 String tmpData=savedInstanceState.getString(\u0026#34;data_key\u0026#34;); Log.d(tag, \u0026#34;tmpdata: \u0026#34;+tmpData); } ...... } 2.4 活动的启动模式 Android的活动启动模式有四种,可在AndroidManifest.xml中通过给\u0026lt;activity\u0026gt;标签指定android:launchMode进行选择\nModel 作用 备注 standard 启动活动时每次都创建新的活动实例放到栈顶 活动默认的启动模式 signleTop 检测栈顶是否存在该活动,存在直接使用,不存在则创建活动实例 检测栈顶,若活动在栈顶之外也会创建新实例 singleTask 检测栈中是否存在活动实例,若存在则使用,否则创建新实例 若该活动存在实例,则其之上的所有活动全部出栈 singleInstance 启用单独的返回栈管理该活动 用于多程序共享该活动时,共用同一返回栈 简单体验一下四种启动模式的效果:\nstandard\n添加log打印活动实例,修改MainActivity的按钮监听函数,使其跳转到MainActivity\n1 2 3 4 5 6 7 8 Log.d(tag, this.toString()); startNormalActivity.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Intent intent=new Intent(MainActivity.this, MainActivity.class); startActivity(intent); } }); 点击2次按钮,可以发现启动了2个新实例,需要3次back才能关闭app\n返回栈的情况如下,创建实例入栈,返回时销毁实例\nsingleTop\n在AndroidManifest.xml中为MainActivity添加属性android:launchMode=\u0026ldquo;singleTop\u0026rdquo;\n点击按钮返回MainActivity时:点击2次,点击时触发onPause,检测栈顶存在活动实例所以调用onResume继续运行\n1次back即可关闭app\n点击按钮返回NormalActivity,NormalActivity添加按钮点击返回MainActivity时:\n各点击1次,发现从NormalActivity返回MainActivity时,由于栈顶不存在实例,所以创建新实例,但没有销毁NormalActivity\n栈示意图\nsingleTask\nMainActivity跳转到NormalActivity再跳转回去\n当返回MainActivity时,由于栈中存在实例,所以直接运行实例,同时位于其上方的NormalActivity出栈销毁\n栈示意图\nsingleInstance\n该种情况下,创建单独的返回栈,无论是哪个应用程序访问该活动都是同一个栈\n假设在FirstActivity中启动SecondActivity,在SecondActivity中启动ThirdActivity\n由于只有SecondActivity是singleInstance模式,所以ThirdActivity和FirstActivity在同一栈中,并位于其上方\nback时,3返回到1再返回到2最后关闭app\n2.5 活动的最佳实践 2.5.1 了解当前界面对应活动 创建BaseActivity基类,添加log打印活动名,让其他类继承该基类\n1 2 3 4 5 6 7 8 9 10 11 12 13 package com.example.createactivity; import android.os.Bundle; import android.util.Log; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; public class BaseActivity extends AppCompatActivity { @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.d(\u0026#34;BaseActivity\u0026#34;,getClass().getName()); } } 2.5.2 随时随地退出程序 2.5.3 启动活动的最佳写法 通过添加actionStart方法,提供接口调用\n1 2 3 4 5 6 public static void actionStart(Context context, String data1, String data2) { Intent intent = new Intent(context, NormalActivity.class); intent.putExtra(\u0026#34;param1\u0026#34;, data1); intent.putExtra(\u0026#34;param2\u0026#34;, data2); context.startActivity(intent); } 这样其他活动希望启动该活动时,只需要直接调用即可\n1 2 3 4 5 6 button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { NormalActivity.actionStart(MainActivity.this,\u0026#34;data1\u0026#34;,\u0026#34;data2\u0026#34;); } }); 第3章 UI开发 3.1 常用控件的使用 3.2.0 Toast 简单的小型消息框,会在屏幕底部弹出\n1 Toast.makeText(this,\u0026#34;Hello\u0026#34;,Toast.LENGTH_LONG).show(); 3.2.1 TextView 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/text_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;This is a TestView!\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; android:textColor=\u0026#34;#00ff00\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 文本框,用于显示文本内容\n属性 作用 样例 android:text 设置文本内容 android:text=\u0026ldquo;Hello,World!\u0026rdquo; android:textSize 设置文本大小 android:textSize=\u0026ldquo;18sp\u0026rdquo; android:textColor 设置文本颜色 android:textColor=\u0026quot;#FF0000\u0026quot; android:gravity 设置文本对齐方式 android:gravity=\u0026ldquo;center\u0026rdquo; 方法 setText(String text) 设置文本内容 textView.setText(\u0026ldquo;Hello, World!\u0026rdquo;); getText() 获取文本内容 String text = textView.getText().toString(); setTextSize(float size) 设置文字大小 textView.setTextSize(18); setTextColor(int color) 设置文字颜色 textView.setTextColor(Color.RED); 3.2.2 Button Button是安卓开发中常用的控件之一，用于触发点击事件\n属性 作用 样例 android:text 设置Button上显示的文本内容 android:text=\u0026ldquo;Click Me\u0026rdquo; android:onClick 设置点击事件的处理方法，通过指定方法名来响应按钮点击事件。 android:onClick=\u0026ldquo;onClickButton\u0026rdquo; android:enabled 设置按钮是否可用 android:enabled=\u0026ldquo;true\u0026rdquo; 方法 setOnClickListener(View.OnClickListener listener) 设置点击事件的监听器，用于在按钮被点击时执行相应的逻辑。 button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // 按钮被点击时的处理逻辑 }}); setText(String text) 设置按钮上显示的文本内容。 button.setText(\u0026ldquo;Click Me\u0026rdquo;); setEnabled(boolean enabled) 设置按钮是否可用 button.setEnabled(true); 3.2.3 EditText EditText用于接收用户输入的文本\n属性 作用 样例 android:hint 设置提示文本 android:hint=\u0026ldquo;请输入用户名\u0026rdquo; android:inputType 设置期望的输入类型,如文本、数字、日期 android:inputType=\u0026ldquo;text\u0026rdquo; android:maxLines 设置最大行数 android:maxLines=\u0026ldquo;3\u0026rdquo; android:maxLength 设置最大字符数 android:maxLength=\u0026ldquo;10\u0026rdquo; 方法 getText() 获取文本内容 String text = editText.getText().toString(); setText(String text) 设置文本内容 editText.setText(\u0026ldquo;Hello, World!\u0026rdquo;); setSelection(int index) 设置文本的选中范围 editText.setSelection(2, 5); // 选中第2到第5个字符 addTextChangedListener(TextWatcher watcher) 添加文本变化监听器,监听EditText中文本的变化 editText.addTextChangedListener(new TextWatcher() { @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { // 文本变化前的处理逻辑 } @Override public void onTextChanged(CharSequence s, int start, int before, int count) { // 文本变化时的处理逻辑 } @Override public void afterTextChanged(Editable s) { // 文本变化后的处理逻辑 }}); 3.2.4 ImageView ImageView用于显示图像\n注:\n图像一般放在res/drawable/下,引用图片只需文件名,不用后缀,注意图片不要中文 adjustViewBounds设置为true后ImageView大小即为图像大小,否则仍然会填充父布局 属性 作用 样例 android:src 设置显示的图像 android:src=\u0026quot;@drawable/image\u0026quot; android:scaleType 设置图像缩放类型 android:scaleType=\u0026ldquo;centerCrop\u0026rdquo; android:adjustViewBounds 设置是否根据图像的宽高比调整边界 android:adjustViewBounds=\u0026ldquo;true\u0026rdquo; 方法 setImageResource(int resId) 设置显示的图像 imageView.setImageResource(R.drawable.image); setScaleType(ImageView.ScaleType scaleType) 设置图像缩放类型 imageView.setScaleType(ImageView.ScaleType.CENTER_CROP); setAdjustViewBounds(boolean adjust) 设置是否根据图像的宽高比调整边界 imageView.setAdjustViewBounds(true); 3.2.5 ProgressBar 常用属性：\nandroid:layout_width：设置组件的宽度。 android:layout_height：设置组件的高度。 android:id：为组件分配一个唯一的ID。 android:indeterminate：指定进度条是否为不确定模式。 android:max：设置进度条的最大值。 android:progress：设置进度条的当前进度值。 android:progressDrawable：设置进度条的自定义背景和进度绘制。 常用方法：\nsetMax(int max)：设置进度条的最大值。 setProgress(int progress)：设置进度条的当前进度值。 getProgress()：获取进度条的当前进度值。 setIndeterminate(boolean indeterminate)：设置进度条是否为不确定模式。 isIndeterminate()：检查进度条是否为不确定模式。 setVisibility(int visibility)：设置进度条的可见性。 setProgressDrawable(Drawable d)：设置进度条的自定义背景和进度绘制。 3.2.6 AlterDialog AlertDialog是一个常用的对话框类，用于显示一个警告或提示对话框，并与用户进行交互\n创建alertDialog:\n1 2 3 AlertDialog.Builder builder = new AlertDialog.Builder(context);//创建AlterDialog Builder用于设置 AlertDialog alertDialog = builder.create();//创建alertDialog实例 alertDialog.show();//显示 方法 作用 样例 setTitle(CharSequence title) 设置对话框的标题 builder.setTitle(\u0026ldquo;AlertDialog Title\u0026rdquo;); setMessage(CharSequence message) 设置对话框的消息内容 builder.setMessage(\u0026ldquo;AlertDialog Message\u0026rdquo;); setPositiveButton(CharSequence text, DialogInterface.OnClickListener listener) 设置对话框的积极按钮（通常表示确定或确认） builder.setPositiveButton(\u0026ldquo;OK\u0026rdquo;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // 点击积极按钮时的处理逻辑 }}); setNegativeButton(CharSequence text, DialogInterface.OnClickListener listener) 设置对话框的消极按钮（通常表示取消或拒绝） builder.setNegativeButton(\u0026ldquo;Cancel\u0026rdquo;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // 点击消极按钮时的处理逻辑 }}); setNeutralButton(CharSequence text, DialogInterface.OnClickListener listener) 设置对话框的中立按钮（通常表示中间选项） builder.setNeutralButton(\u0026ldquo;Skip\u0026rdquo;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // 点击中立按钮时的处理逻辑 }}); setCancelable(boolean cancelable) 设置对话框是否可以被取消 builder.setCancelable(true); // 对话框可以被取消\n如果为true 那么点击dialog框外或者点击物理返回键都会取消对话框如果为false 那么必须点击对话框的按钮才能关闭对话框,点击框外或者点击返回键都无法取消 create() 创建AlertDialog对象 AlertDialog alertDialog = builder.create(); show() 显示对话框 AlertDialog alertDialog = builder.create();alertDialog.show(); 示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package com.example.createactivity; import androidx.appcompat.app.AlertDialog; import androidx.appcompat.app.AppCompatActivity; import android.app.Dialog; import android.content.Context; import android.content.DialogInterface; import android.os.Bundle; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main_layout); Context context=this;//环境 上下文 AlertDialog.Builder dialog=new AlertDialog.Builder(context); dialog.setPositiveButton(\u0026#34;OK\u0026#34;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // } }); dialog.setNegativeButton(\u0026#34;Cancel\u0026#34;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // } }); dialog.setNeutralButton(\u0026#34;middle\u0026#34;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // } }); dialog.setCancelable(false);//必须点击警告框按钮进行处理 dialog.setTitle(\u0026#34;Alert\u0026#34;); dialog.setMessage(\u0026#34;This is a Test\u0026#34;); dialog.show(); } } 运行结果\n按钮没有设运行为,点击任意按钮即可关闭\n封装: 可以封装一个MessageBox方法,每次使用时给定参数直接调用即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public void MessageBox(String title,String message){ AlertDialog.Builder dialog=new AlertDialog.Builder(this); dialog.setTitle(title); dialog.setMessage(message); dialog.setPositiveButton(\u0026#34;OK\u0026#34;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // } }); dialog.setNegativeButton(\u0026#34;Cancel\u0026#34;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // } }); dialog.setNeutralButton(\u0026#34;middle\u0026#34;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // } }); dialog.setCancelable(false);//必须点击警告框按钮进行处理 dialog.show(); } 3.2.7 ProgressDialog 常用属性：\nsetMessage(CharSequence message)：设置对话框中显示的消息文本。 setProgressStyle(int style)：设置进度条的样式，如水平进度条或圆形进度条。 setCancelable(boolean cancelable)：设置对话框是否可以被取消。 setMax(int max)：设置进度条的最大值。 setProgress(int progress)：设置进度条的当前进度值。 常用方法：\nshow()：显示ProgressDialog对话框。 dismiss()：关闭ProgressDialog对话框。 setIndeterminate(boolean indeterminate)：设置进度条是否为不确定模式。 isIndeterminate()：检查进度条是否为不确定模式。 setCanceledOnTouchOutside(boolean cancel)：设置在点击对话框外部时是否取消对话框。 setOnCancelListener(DialogInterface.OnCancelListener listener)：设置对话框取消事件的监听器。 3.3 4种基本布局 3.3.1 LinearLayout 属性 作用 示例 备注 android:orientation 指定布局排列方向 android:orientation=\u0026ldquo;horizontal\u0026rdquo; (vertical) android:layout_gravity 指定控件对齐方式 android:layout_gravity=\u0026ldquo;top\u0026rdquo; (center_vertical bottom) layout_gravity有效方向和orientation垂直,该属性作用于控件 android:layout_weight 按比例指定控件大小 android:layout_weight=\u0026ldquo;1\u0026rdquo; 该属性作用于控件 注意:\n如果orientation=horizontal, 内部控件不能将宽度设为match_parent,否则单个控件会占满整个水平方向,vertical同理不能指定高度为match_parent layout_weight可用于按比例分配控件大小,系统将所有指定该属性控件的值求和,每个控件属性值/总和即为比例 示例\n3.3.2 RelativeLayout 属性 作用 示例 android:layout_alignParentTop 相对父布局定位 android:layout_alignParentTop=\u0026ldquo;true\u0026rdquo; android:layout_alignParentBottom android:layout_alignParentLeft android:layout_alignParentRight android:layout_centerInParent android:layout_above 相对其他组件定位 android:layout_below android:layout_toLeftOf android:layout_toRightOf 示例\n相对父布局定位\n相对其他组件定位\n此处以Button3为基准控件,其他控件相对该控件定位\n3.3.3 FrameLayout 帧布局,所有控件默认放在布局左上角,应用场景较少\n图片盖住文字是由于图片组件后添加\n可通过给组件指定对齐方式修改位置\n3.3.4 百分比布局 以上三种布局从Android1.0开始沿用至今,其中只有LinearLayout支持按比例指定控件大小,为此Android引入了百分比布局,扩展相对布局和帧布局的功能,可以直接通过百分比指定控件大小\n分别是PercentFrameLayout和PercentRelativeLayout\n属性 作用 示例 app:layout_widthPercent 指定相对于父布局的百分比宽度 app:layout_heightPercent 制定高度 使用百分比布局需要打开app.build.gradle,在dependencies添加如下内容\n1 2 3 4 5 6 dependencies { ... implementation libs.support.percent //新版gradle写法 //compile \u0026#39;com.android.support:percent:28.0.0\u0026#39; //老版本写法 ... } 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;android.support.percent.PercentFrameLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button1\u0026#34; android:text=\u0026#34;Button 1\u0026#34; android:layout_gravity=\u0026#34;left|top\u0026#34; app:layout_widthPercent=\u0026#34;50%\u0026#34; app:layout_heightPercent=\u0026#34;50%\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button2\u0026#34; android:text=\u0026#34;Button 2\u0026#34; android:layout_gravity=\u0026#34;right|top\u0026#34; app:layout_widthPercent=\u0026#34;50%\u0026#34; app:layout_heightPercent=\u0026#34;50%\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button3\u0026#34; android:text=\u0026#34;Button 3\u0026#34; android:layout_gravity=\u0026#34;left|bottom\u0026#34; app:layout_widthPercent=\u0026#34;50%\u0026#34; app:layout_heightPercent=\u0026#34;50%\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button4\u0026#34; android:text=\u0026#34;Button 4\u0026#34; android:layout_gravity=\u0026#34;right|bottom\u0026#34; app:layout_widthPercent=\u0026#34;50%\u0026#34; app:layout_heightPercent=\u0026#34;50%\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34;/\u0026gt; \u0026lt;/android.support.percent.PercentFrameLayout\u0026gt; 效果\n3.4 创建自定义控件 控件和容器均继承自View,我们可以利用继承自定义控件\n3.4.1 引入布局 某些布局可能需要在多个活动中使用,这时如果每个活动都编写一次布局会造成大量的代码重复,引入布局可以做到一个布局供多个活动使用\n首先编写title布局\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/title_back\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_margin=\u0026#34;5dp\u0026#34; android:text=\u0026#34;Back\u0026#34; android:textColor=\u0026#34;#fff\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/title_text\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;Title Text\u0026#34; android:textColor=\u0026#34;#f16\u0026#34; android:textSize=\u0026#34;24sp\u0026#34;/\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/title_edit\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_margin=\u0026#34;5dp\u0026#34; android:text=\u0026#34;Edit\u0026#34; android:textColor=\u0026#34;#fff\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 使用include标签引入布局即可\n3.4.2 自定义控件 引入布局可以解决重复编写布局代码的问题,但布局中如果有部分控件需要响应事件,例如标题栏的返回按钮,不管在哪个活动中该按钮的功能都是销毁当前活动,此时使用自定义控件可以省去重复代码的编写\n首先创建TitleLayout类继承LinearLayout类,动态加载title布局并给按钮添加事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package com.example.chapter3_uiwidgettest; import android.app.Activity; import android.util.AttributeSet; import android.view.LayoutInflater; import android.view.View; import android.widget.Button; import android.widget.LinearLayout; import android.content.Context; import android.widget.Toast; public class TitleLayout extends LinearLayout { public TitleLayout(Context context, AttributeSet attrs){ super(context,attrs);//LinearLayout构造函数 LayoutInflater.from(context).inflate(R.layout.title,this);//动态加载title布局 //给按钮添加事件 Button titleBack=(Button)findViewById(R.id.title_back); Button titleEdit=(Button)findViewById(R.id.title_edit); titleBack.setOnClickListener(new OnClickListener() { @Override public void onClick(View view) { ((Activity)getContext()).finish();//销毁活动 } }); titleEdit.setOnClickListener(new OnClickListener() { @Override public void onClick(View view) { Toast.makeText(getContext(),\u0026#34;You clicked Edit Button!\u0026#34;,Toast.LENGTH_SHORT).show(); } }); } } activity_main.xml\n使用完整包名.类名标签引入自定义控件\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; \u0026gt; \u0026lt;com.example.chapter3_uiwidgettest.TitleLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 效果如下,和include类似\n3.5 ListView 3.5.1 ListView的简单用法 首先在布局中添加ListView组件\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;ListView android:id=\u0026#34;@+id/list_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 再修改MainActivity\n数组的数据无法直接传递给ListView,必须通过适配器完成,ArrayAdapter可通过泛型适配多种数据类型\n另外这里使用了android.R.layout.simple_list_item_1,这是安卓内置的布局文件,里面只有一个TextView,可简单显示一段文本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class MainActivity extends AppCompatActivity { private ActivityMainBinding mainBinding; private String[] data={\u0026#34;Apple\u0026#34;,\u0026#34;Banana\u0026#34;,\u0026#34;Orange\u0026#34;,\u0026#34;Watermelon\u0026#34;,\u0026#34;Pear\u0026#34;,\u0026#34;Grape\u0026#34;,\u0026#34;Pineapple\u0026#34;, \u0026#34;Strawberry\u0026#34;,\u0026#34;Cherry\u0026#34;,\u0026#34;Mango\u0026#34;,\u0026#34;Apple\u0026#34;,\u0026#34;Banana\u0026#34;,\u0026#34;Orange\u0026#34;,\u0026#34;Watermelon\u0026#34;,\u0026#34;Pear\u0026#34;,\u0026#34;Grape\u0026#34;,\u0026#34;Pineapple\u0026#34;, \u0026#34;Strawberry\u0026#34;,\u0026#34;Cherry\u0026#34;,\u0026#34;Mango\u0026#34; }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mainBinding=ActivityMainBinding.inflate(getLayoutInflater()); setContentView(mainBinding.getRoot()); ArrayAdapter\u0026lt;String\u0026gt; adapter=new ArrayAdapter\u0026lt;String\u0026gt;(MainActivity.this,android.R.layout.simple_list_item_1,data); ListView listView=mainBinding.listView; listView.setAdapter(adapter); } } 效果如下,运行后可以上下翻页\n3.5.2 定制ListView的界面 上述ListView比较单调,我们可以对其界面进行定制\n首先创建Fruit类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Fruit{ private String name; private int imageId; public Fruit(String name,int id){ this.name=name; this.imageId=id; } public String getName(){ return name; } public int getImageId(){ return imageId; } } 再为ListView子项指定布局,新建fruit_item.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id =\u0026#34;@+id/fruit_image\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; android:id=\u0026#34;@+id/fruit_name\u0026#34; android:layout_marginLeft=\u0026#34;10dp\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 创建并重写适配器FruitAdapter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import android.content.Context; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ArrayAdapter; import android.widget.ImageView; import android.widget.TextView; import org.w3c.dom.Text; import java.util.List; public class FruitAdapter extends ArrayAdapter\u0026lt;Fruit\u0026gt; { private int resourceId;//保存传入的子项布局id，用于后续动态加载 public FruitAdapter(Context context, int textviewResourceId, List\u0026lt;Fruit\u0026gt; objects) { super(context, textviewResourceId, objects); resourceId = textviewResourceId; } //重写父类ArrayAdapter的getView public View getView(int position, View converView, ViewGroup parent) { //每个子项被滚动到屏幕内会被调用 Fruit fruit = getItem(position);//获取当前项的Fruit实例 View view= LayoutInflater.from(getContext()).inflate(resourceId,parent,false);// 为子项加载我们传入的布局 ImageView fruitImage=(ImageView) view.findViewById(R.id.fruit_image);//获取实例 TextView fruitname=(TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId());//为实例设置参数 fruitname.setText(fruit.getName()); return view; } } MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package com.example.chapter3_uiwidgettest; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.ArrayAdapter; import android.widget.ListView; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity { private List\u0026lt;Fruit\u0026gt; fruitList =new ArrayList\u0026lt;\u0026gt;(); private void initFruits(){ for (int i=0;i\u0026lt;2;i++){ Fruit apple =new Fruit(\u0026#34;Apple\u0026#34;,R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit(\u0026#34;Banana\u0026#34;,R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit(\u0026#34;Orange\u0026#34;,R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit(\u0026#34;Watermelon\u0026#34;,R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit(\u0026#34;Pear\u0026#34;,R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit(\u0026#34;Grape\u0026#34;,R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit(\u0026#34;Pineapple\u0026#34;,R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit(\u0026#34;Strawberry\u0026#34;,R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit(\u0026#34;Cherry\u0026#34;,R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit(\u0026#34;Mango\u0026#34;,R.drawable.mango_pic); fruitList.add(mango); } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); FruitAdapter adapter=new FruitAdapter(MainActivity.this,R.layout.fruit_item,fruitList); ListView listView =(ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); } } 效果如下\n3.5.3 提升ListView运行效率 \u0026hellip;\n3.5.4 ListView的点击事件 \u0026hellip;\n3.6 RecyclerView RecyclerView是增强版的ListView,可以实现横向滚动\n3.6.1 RecyclerView基本用法 该控件属于新增控件,为保持兼容性需要在gradle.build的dependencies中添加依赖\n1 implementation \u0026#39;androidx.recyclerview:recyclerview:1.2.1\u0026#39; activity_main 由于该控件不是系统内置sdk控件,所以要写完整包名\n1 2 3 4 5 6 7 8 9 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;androidx.recyclerview.widget.RecyclerView android:id=\u0026#34;@+id/recycler_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 重写FruitAdapter 继承RecyclerView.Adapter,指定泛型类型为FruitAdapter.ViewHolder自定义类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.example.chapter3_uiwidgettest; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.TextView; import androidx.recyclerview.widget.RecyclerView; import java.util.List; public class FruitAdapter extends RecyclerView.Adapter\u0026lt;FruitAdapter.ViewHolder\u0026gt;{ private List\u0026lt;Fruit\u0026gt; mFruitList; //继承并自定义类 static class ViewHolder extends RecyclerView.ViewHolder{ ImageView fruitImage; TextView fruitName; public ViewHolder(View view){ super(view); fruitImage =(ImageView) view.findViewById(R.id.fruit_image);//加载图片文字实例 fruitName =(TextView) view.findViewById(R.id.fruit_name); } } public FruitAdapter(List\u0026lt;Fruit\u0026gt; fruitList){ mFruitList=fruitList; } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType){ View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false); ViewHolder holder=new ViewHolder(view); return holder; } @Override public void onBindViewHolder(ViewHolder holder,int position){ Fruit fruit=mFruitList.get(position); holder.fruitImage.setImageResource(fruit.getImageId()); holder.fruitName.setText(fruit.getName()); } @Override public int getItemCount(){ return mFruitList.size(); } } MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package com.example.chapter3_uiwidgettest; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.RecyclerView; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.TextView; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity { private List\u0026lt;Fruit\u0026gt; fruitList=new ArrayList\u0026lt;\u0026gt;(); private void initFruits(){ for (int i=0;i\u0026lt;2;i++){ Fruit apple =new Fruit(\u0026#34;Apple\u0026#34;,R.drawable.apple_pic); fruitList.add(apple); Fruit banana = new Fruit(\u0026#34;Banana\u0026#34;,R.drawable.banana_pic); fruitList.add(banana); Fruit orange = new Fruit(\u0026#34;Orange\u0026#34;,R.drawable.orange_pic); fruitList.add(orange); Fruit watermelon = new Fruit(\u0026#34;Watermelon\u0026#34;,R.drawable.watermelon_pic); fruitList.add(watermelon); Fruit pear = new Fruit(\u0026#34;Pear\u0026#34;,R.drawable.pear_pic); fruitList.add(pear); Fruit grape = new Fruit(\u0026#34;Grape\u0026#34;,R.drawable.grape_pic); fruitList.add(grape); Fruit pineapple = new Fruit(\u0026#34;Pineapple\u0026#34;,R.drawable.pineapple_pic); fruitList.add(pineapple); Fruit strawberry = new Fruit(\u0026#34;Strawberry\u0026#34;,R.drawable.strawberry_pic); fruitList.add(strawberry); Fruit cherry = new Fruit(\u0026#34;Cherry\u0026#34;,R.drawable.cherry_pic); fruitList.add(cherry); Fruit mango = new Fruit(\u0026#34;Mango\u0026#34;,R.drawable.mango_pic); fruitList.add(mango); } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化所有的水果数据 initFruits(); //获取recycler_view实例 RecyclerView recyclerView=(RecyclerView) findViewById(R.id.recycler_view); //创建一个LinearLayoutManager 对象 LinearLayoutManager layoutManager=new LinearLayoutManager(this); //LayoutManager用于指定RecyclerView的布局方式 LinearLayoutManager是线性布局 recyclerView.setLayoutManager(layoutManager); //创建FruitAdapter的实例，传入水果数据 FruitAdapter adapter=new FruitAdapter(fruitList); //适配器设置 recyclerView.setAdapter(adapter); } } 效果同上\n3.6.2 实现横向滚动和瀑布流布局 3.6.3 RecyclerView的点击事件 3.7 编写界面的最佳实践 3.7.1 制作Nine-Patch图片 3.7.2 编写聊天界面 第4章 探究碎片 Android3.0引入了碎片(Fragment),可以使界面在平板上更好的显示\n4.1 碎片是什么 碎片(Fragment)是一种可以嵌入在活动中的UI片段,可以让程序更合理更充分的利用大屏幕空间,常在平板使用\n和活动非常相似,可以包含布局,拥有生命周期,可以理解为迷你型活动\n4.2 碎片的使用方式 首先创建一个平板模拟器\n4.2.1 碎片的简单用法 创建left_fragment.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/button\u0026#34; android:layout_gravity=\u0026#34;center_horizontal\u0026#34; android:text=\u0026#34;Button\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 创建right_fragment.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;#00ff00\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; \u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_horizontal\u0026#34; android:textSize=\u0026#34;20sp\u0026#34; android:text=\u0026#34;This is right fragment\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 编写LeftFragment类,继承Fragment类,重写onCreateView方法加载布局\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package com.example.chapter4_fragment; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import androidx.fragment.app.Fragment; public class LeftFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle saveInstanceState){ View view =inflater.inflate(R.layout.left_fragment,container,false);//加载布局 return view; } } 编写RightFragment类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package com.example.chapter4_fragment; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import androidx.fragment.app.Fragment; public class RightFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle saveInstanceState){ View view =inflater.inflate(R.layout.right_fragment,container,false);//加载布局 return view; } } 修改activity_main.xml\n添加两个fragment,并通过layout_weight设置为均分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;fragment android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:name=\u0026#34;com.example.chapter4_fragment.LeftFragment\u0026#34; android:id =\u0026#34;@+id/left_fragment\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;fragment android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:id=\u0026#34;@+id/right_fragment\u0026#34; android:name=\u0026#34;com.example.chapter4_fragment.RightFragment\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 效果如下,两个碎片平分了整个活动布局\n4.2.2 动态加载碎片 编写another_right_fragment.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;#ffff00\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; \u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_horizontal\u0026#34; android:textSize=\u0026#34;20sp\u0026#34; android:text=\u0026#34;This is another fragment\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 编写AnotherRigtFragment类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package com.example.chapter4_fragment; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import androidx.fragment.app.Fragment; public class AnotherRightFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View view=inflater.inflate(R.layout.another_right_fragment,container,false);//参数3用于设置父布局 return view; } } 修改activit_main.xml 将右侧碎片替换为FrameLayout\nFrameLayout所有控件默认摆放在左上角,此处只需要在布局放一个碎片不需要定位所以适合用该布局\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;fragment android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:name=\u0026#34;com.example.chapter4_fragment.LeftFragment\u0026#34; android:id =\u0026#34;@+id/left_fragment\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;FrameLayout android:id=\u0026#34;@+id/right_layout\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; \u0026gt; \u0026lt;/FrameLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 修改MainActivity,向FrameLayout添加碎片\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package com.example.chapter4_fragment; import android.os.Bundle; import android.view.View; import android.widget.Button; import androidx.appcompat.app.AppCompatActivity; import androidx.fragment.app.Fragment; import androidx.fragment.app.FragmentManager; import androidx.fragment.app.FragmentTransaction; import com.example.chapter4_fragment.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity implements View.OnClickListener { private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); Button button=findViewById(R.id.button); button.setOnClickListener(this); replaceFragment(new RightFragment()); } private void replaceFragment(Fragment fragment){ //1.获取FragmentManager FragmentManager fragmentManager=getSupportFragmentManager(); //2.通过beginTransaction()开启事物 FragmentTransaction transaction=fragmentManager.beginTransaction(); //3.向容器添加或替换碎片,一般用replace(),需传入容器id和待添加的碎片实例 transaction.replace(R.id.right_layout,fragment); //4.通过commit()提交事物 transaction.commit(); } @Override public void onClick(View v){ //给左侧碎片按钮添加点击事件,创建新的碎片实例替换右侧碎片 if(v.getId()==R.id.button) replaceFragment(new AnotherRightFragment());//0.创建碎片实例 } } 效果如下,启动时和上次示例相同,点击按钮后右侧碎片被替换\n4.3 碎片的生命周期 4.4 动态加载布局的技巧 4.5 碎片的最佳实践 第5章 广播机制 5.1 广播机制简介 Android程序可以对自己感兴趣的广播进行注册,这样只会接收到关心的广播内容,这些广播可以是来自于系统的,也可以是其他应用程序的\n发送广播的方式可以借助Intent,接收广播则需要广播接收器(Broadcast Receiver)\nAndroid的广播分为两种类型:\n标准广播(Normal broadcasts)\n异步执行,所有广播接收器几乎同时接收该广播,没有先后顺序\n效率高.但无法截断,工作示意图如下\n有序广播(Ordered broadcasts)\n同步执行,同一时刻只有一个广播接收器接收到该广播\n有先后顺序,优先级高的接收器先收到广播,并且可以截断\n5.2 接收系统广播 Android内置了很多系统级广播,可通过监听这些广播得到各种系统状态信息\n例如: 手机开机完成,电池电量变化,时间/时区发生改变等\n5.2.1 动态注册监听网络变化 广播接收器有两种注册方法:\n动态注册: 在代码中注册 静态注册: 在AndroidManifest.xml注册 创建广播接收器只需要新建一个类继承BroadcastReceiver,并重写onReceive()方法即可\n另外还需要创建IntentFilter并指定广播类型,之后注册广播接收器即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package com.example.chapter5_broadcast; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.net.ConnectivityManager; import android.net.NetworkInfo; import android.os.Bundle; import android.content.BroadcastReceiver; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; public class MainActivity extends AppCompatActivity { private IntentFilter intentFilter; private NetworkChangeReceiver networkChangeReceiver; class NetworkChangeReceiver extends BroadcastReceiver{ //每当网络变化时都会接收广播并执行该方法 @Override public void onReceive(Context context, Intent intent) { ConnectivityManager connectivityManager=(ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);//获取系统服务实例,该类用于管理网络连接 NetworkInfo networkInfo=connectivityManager.getActiveNetworkInfo();//获取网络信息实例 if(networkInfo!=null\u0026amp;\u0026amp;networkInfo.isAvailable())//判断是否有网络 { Toast.makeText(context,\u0026#34;network is available\u0026#34;,Toast.LENGTH_LONG).show(); }else { Toast.makeText(context,\u0026#34;network is unavailable\u0026#34;,Toast.LENGTH_LONG).show(); } } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); intentFilter=new IntentFilter(); intentFilter.addAction(\u0026#34;android.net.conn.CONNECTIVITY_CHANGE\u0026#34;);//网络变化时系统发出该种广播 networkChangeReceiver=new NetworkChangeReceiver(); registerReceiver(networkChangeReceiver,intentFilter);//注册接收器 传入网络接收器实例和过滤器 } @Override protected void onDestroy() { super.onDestroy(); unregisterReceiver(networkChangeReceiver);//动态注册的必须要卸载 } } 需要在AndroidManifest.xml中添加权限声明\n1 2 3 4 5 6 \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; ... \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34; /\u0026gt; ... \u0026lt;/manifest\u0026gt; 运行效果如下,每次网络变化时都会弹出提醒\n5.2.2 静态注册实现开机启动 动态注册的广播接收器很灵活,可以自由控制注册与注销,但是必须在程序启动后才能接收广播\n如果希望程序在未启动的情况下接收广播则需要静态注册,例如接收开机广播实现开机启动\n创建活动时选择New-\u0026gt;Other-\u0026gt;Broadcast Receiver即可创建接收器,修改代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 package com.example.chapter5_broadcast; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.widget.Toast; public class BootedReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context,\u0026#34;Boot Complete!\u0026#34;,Toast.LENGTH_LONG).show(); } } 打开AndroidManifest.xml,由于是快捷创建,所以会自动注册Receiver\n添加接收开机信息的权限声明,再添加intent-filter指定action\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.RECEIVE_BOOT_COMPLETED\u0026#34;/\u0026gt; \u0026lt;application ... \u0026lt;receiver android:name=\u0026#34;.BootedReceiver\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.BOOT_COMPLETED\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; ... \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 书上操作安装并重启手机即可看到通知,经过测试无法看到\n可能有以下原因:\nAndroid8.0对静态注册的隐式广播限制 权限问题,没有授权 系统启动后广播服务还在缓慢启动,故没有捕捉到特定接收的时机 注意: 当onReceive()方法运行较长时间没有结束时程序会报错\n不要在中添加过多逻辑或耗时操作,广播接收器中不允许开启线程\n更多的是用于打开程序其他组件,例如创建一个状态栏通知,启动一个服务等\n5.3 发送自定义广播 上面学习了如何通过广播接收器接收系统广播,现在学习如何在程序中发送自定义广播并体会两种广播的区别\n5.3.1 发送标准广播 新建一个广播接收器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example.chapter5_broadcast; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.widget.Toast; public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context,\u0026#34;Receiver my broadcast!\u0026#34;,Toast.LENGTH_LONG).show(); } } 修改Manifest,添加标签用于接收广播\n1 2 3 4 5 6 7 8 9 \u0026lt;receiver android:name=\u0026#34;.MyReceiver\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;com.example.chapter5_broadcast.MY_BROADCAST\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; 创建按钮用于发送广播\n1 2 3 4 5 6 \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/SendBroadcast\u0026#34; android:text=\u0026#34;Send Broadcast\u0026#34; /\u0026gt; MainActivity添加监听器\n1 2 3 4 5 6 7 8 9 10 11 Button button=findViewById(R.id.SendBroadcast); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Intent intent=new Intent(\u0026#34;com.example.chapter5_broadcast.MY_BROADCAST\u0026#34;); //Android8.0后静态注册的接收器无法隐式接收广播 //必须显式指定接收广播的组件 intent.setComponent(new ComponentName(\u0026#34;com.example.chapter5_broadcast\u0026#34;,\u0026#34;com.example.chapter5_broadcast.MyReceiver\u0026#34;)); sendBroadcast(intent); } }); 效果如下,点击后接收到广播\n广播可以跨进程通信,所以在应用程序内发送的广播其他程序也可以接收\n由于Android8.0后静态注册Receiver不支持隐式广播,书上实验不予实现(修改为动态注册Receiver则可以接收隐式广播)\n注意:\n参考【Android Broadcast】BroadcastReceiver\nandroid 8.0及以上版本对静态注册广播严格限制\nAndroid8.0以后,静态注册的Receiver无法隐式接收自定义广播,必须显示指定,官方说明:\nhttps://developer.android.google.cn/about/versions/oreo/background\n静态注册的只可以接收部分豁免的系统广播,名单如下:\nhttps://developer.android.google.cn/develop/background-work/background-tasks/broadcasts/broadcast-exceptions\n5.3.2 发送有序广播 书上使用的是静态注册的隐式广播,由于Android8.0的限制无法复现,于是修改为动态注册的隐式广播\n创建第二个项目BroadcastTest用于接收广播,动态注册Receiver\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package com.example.broadcasttest; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.os.Bundle; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; public class MainActivity extends AppCompatActivity { private AnotherBroadcastReceiver anotherBroadcastReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); IntentFilter intentFilter=new IntentFilter(); intentFilter.addAction(\u0026#34;com.example.chapter5_broadcast.MY_BROADCAST\u0026#34;); anotherBroadcastReceiver=new AnotherBroadcastReceiver(); registerReceiver(anotherBroadcastReceiver,intentFilter); } class AnotherBroadcastReceiver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context,\u0026#34;Another Receiver Received!\u0026#34;,Toast.LENGTH_LONG).show(); } } @Override protected void onDestroy() { super.onDestroy(); unregisterReceiver(anotherBroadcastReceiver); } } 在Chapter5_Broadcast项目中,添加按钮用于创建Receiver(另一个用于发送)\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/CreateReceiver\u0026#34; android:text=\u0026#34;Create Receiver\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/SendBroadcast\u0026#34; android:text=\u0026#34;Send Broadcast\u0026#34; /\u0026gt; MainActivity如下\n由于无法使用静态注册,所以通过intentFilter.setPriority()设置优先级,没有设置优先级时顺序不固定\n设置后固定本项目先收到广播,如果在onReceive()添加abortBroadcast()则可以截断广播,Test项目无法接收\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package com.example.chapter5_broadcast; import android.content.BroadcastReceiver; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; public class MainActivity extends AppCompatActivity { private MyReceiver myReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button createReceiver=findViewById(R.id.CreateReceiver); createReceiver.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View view) { myReceiver=new MyReceiver(); IntentFilter intentFilter=new IntentFilter(); intentFilter.addAction(\u0026#34;com.example.chapter5_broadcast.MY_BROADCAST\u0026#34;); intentFilter.setPriority(100);//设置优先级 registerReceiver(myReceiver,intentFilter); Toast.makeText(MainActivity.this,\u0026#34;Create Receiver Successed!\u0026#34;,Toast.LENGTH_SHORT).show(); } }); Button button=findViewById(R.id.SendBroadcast); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Intent intent=new Intent(\u0026#34;com.example.chapter5_broadcast.MY_BROADCAST\u0026#34;); sendOrderedBroadcast(intent,null); } }); } @Override protected void onDestroy() { super.onDestroy(); unregisterReceiver(myReceiver); } public class MyReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context,\u0026#34;Receiver my broadcast!\u0026#34;,Toast.LENGTH_LONG).show(); //abortBroadcast(); //截断广播 } } } 综上,有序广播的功能得以证明\n5.4 使用本地广播 上述广播都属于全局广播,这样容易引起安全性问题,例如我们发送的带关键性数据的广播可能被其他程序截获;或者其他程序不断向我们的接收器发送垃圾广播等\nAndroid引入了一套本地广播机制解决这些问题,通过LocalBroadcastManager对广播进行管理\n修改MainActivity如下，和使用隐式广播类似无需指定目标(只在内部广播),主要通过LocalBroadcastManager进行管理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.example.chapter5_broadcast; import android.content.BroadcastReceiver; import android.content.ComponentName; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.Toast; import androidx.appcompat.app.AppCompatActivity; import androidx.localbroadcastmanager.content.LocalBroadcastManager; public class MainActivity extends AppCompatActivity { private LocalReceiver localReciver; private LocalBroadcastManager localBroadcastManager; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); localBroadcastManager=LocalBroadcastManager.getInstance(this);//获取本地广播管理器实例 //注册本地广播监听器 IntentFilter intentFilter=new IntentFilter(); intentFilter.addAction(\u0026#34;com.example.chapter5_broadcast.LOCAL_BROADCAST\u0026#34;); localReciver=new LocalReceiver(); localBroadcastManager.registerReceiver(localReciver,intentFilter); //发送广播 Button button=findViewById(R.id.SendBroadcast); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Intent intent=new Intent(\u0026#34;com.example.chapter5_broadcast.LOCAL_BROADCAST\u0026#34;); localBroadcastManager.sendBroadcast(intent); } }); } public class LocalReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context,\u0026#34;Receive local broadcast!\u0026#34;,Toast.LENGTH_LONG).show(); } } @Override protected void onDestroy() { super.onDestroy(); localBroadcastManager.unregisterReceiver(localReciver); } } 值得注意的是本地广播无法通过静态注册接收器接收,必须动态注册,因为发送本地广播时app已经启动\n本地广播的优势:\n广播不会离开本程序,不用担心机密数据泄露 本地广播比全局广播高效 其他程序无法广播到本程序,无须担心安全漏洞 5.5 广播实现强制下线功能 以qq登录为例,强制下线思路: 弹出对话框,让用户无法进行任何操作,必须点击确定并返回登录界面.需要关闭所有活动再返回登录页面\n先创建一个ActivityCollector管理所有活动,实现一键强制下线所有活动的函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import android.app.Activity; import java.util.ArrayList; import java.util.List; public class ActivityCollector { public static List\u0026lt;Activity\u0026gt; activities =new ArrayList\u0026lt;\u0026gt;(); public static void addActivity(Activity activity){ activities.add(activity); } public static void removeActivity(Activity activity){ activities.remove(activity); } //结束所有活动 public static void finishAll(){ for (Activity activity:activities) { if (!activity.isFinishing()){ activity.finish(); } } } } 再创建BaseActivity作为所有活动的父类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import android.os.Bundle; import android.os.PersistableBundle; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; public class BaseActivity extends AppCompatActivity { @Override public void onCreate(@Nullable Bundle savedInstanceState, @Nullable PersistableBundle persistentState) { super.onCreate(savedInstanceState, persistentState); ActivityCollector.addActivity(this); } @Override protected void onDestroy() { super.onDestroy(); ActivityCollector.removeActivity(this); } } 创建LoginActivity\n布局如下,构建账号密码输入框和点击按钮\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;LinearLayout android:orientation=\u0026#34;horizontal\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;90dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:text=\u0026#34;Account:\u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/account\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:orientation=\u0026#34;horizontal\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;90dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:text=\u0026#34;Password\u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/password\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; android:inputType=\u0026#34;textPassword\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/login\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:text=\u0026#34;Login\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 代码如下,账号=admin,密码=123456时跳转至MainActivity并销毁本活动,否则提示错误\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package com.example.chapter5_broadcast; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.TextView; import android.widget.Toast; import androidx.annotation.Nullable; public class LoginActivity extends BaseActivity{ private EditText accountEdit; private EditText passwordEdit; private Button login; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); accountEdit=(EditText)findViewById(R.id.account); passwordEdit=(EditText)findViewById(R.id.password); login =(Button) findViewById(R.id.login); login.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { String account=accountEdit.getText().toString(); String password=passwordEdit.getText().toString(); if (account.equals(\u0026#34;admin\u0026#34;)\u0026amp;\u0026amp;password.equals(\u0026#34;123456\u0026#34;)){ Intent intent=new Intent(LoginActivity.this,MainActivity.class); startActivity(intent); finish(); }else { Toast.makeText(LoginActivity.this, \u0026#34;account or password is error!\u0026#34;, Toast.LENGTH_SHORT).show(); } } }); } } 修改activity_main,添加按钮用于强制下线\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/force_offline\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Send force offline broadcast\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 修改MainActivity,发送下线广播用于下线所有活动\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.chapter5_broadcast; import androidx.appcompat.app.AppCompatActivity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Button; public class MainActivity extends BaseActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button offline =(Button) findViewById(R.id.force_offline); offline.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Intent intent=new Intent(\u0026#34;com.example.chapter5_broadcast.FORCE_OFFLINE\u0026#34;); sendBroadcast(intent); } }); } } 那么如何接收下线广播呢?显然每个活动都添加接收器太过麻烦\n直接在BaseActivity添加下线广播接收器即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package com.example.chapter5_broadcast; import android.content.BroadcastReceiver; import android.content.Context; import android.content.DialogInterface; import android.content.Intent; import android.content.IntentFilter; import android.os.Bundle; import androidx.annotation.Nullable; import androidx.appcompat.app.AlertDialog; import androidx.appcompat.app.AppCompatActivity; public class BaseActivity extends AppCompatActivity { private ForeceOfflineReceiver receiver; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); ActivityCollector.addActivity(this);//添加本活动进活动管理器列表 } @Override protected void onResume() { super.onResume(); IntentFilter intentFilter=new IntentFilter();//每当面向用户运行时创建下线广播接收器 intentFilter.addAction(\u0026#34;com.example.chapter5_broadcast.FORCE_OFFLINE\u0026#34;); receiver=new ForeceOfflineReceiver(); registerReceiver(receiver,intentFilter); } @Override protected void onPause() { super.onPause(); if (receiver!=null){ unregisterReceiver(receiver);//暂停时停止接收广播 receiver=null; } } @Override protected void onDestroy() { super.onDestroy(); ActivityCollector.removeActivity(this); } //弹窗只允许点击ok并下线所有活动返回登录页 class ForceOfflineReceiver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { AlertDialog.Builder builder =new AlertDialog.Builder(context); builder.setTitle(\u0026#34;Warning\u0026#34;); builder.setMessage(\u0026#34;You are forced to be offline ,Pleasr try to login again\u0026#34;); builder.setCancelable(false);//不可取消,防止back builder.setPositiveButton(\u0026#34;OK\u0026#34;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { ActivityCollector.finishAll();//下线所有活动 Intent intent=new Intent(context,LoginActivity.class); context.startActivity(intent);//返回登录页面 } }); builder.show(); } } } 为什么要在onResume()和onPause()进行注册和卸载ForceOfflineReceiver呢?之前都是在onCreate()和onDestroy()进行\n这是因为我们需要保证始终只有处于栈顶的活动能接受到强制下线广播,非栈顶活动不应该也没必要接收该广播\n只需要栈顶活动能弹出强制下线弹窗即可,如果其他活动也弹窗效果会很不好,这样写可以保证活动不在栈顶时自动关闭广播接收器\n修改Manifest,设置登录活动为app入口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;application android:allowBackup=\u0026#34;true\u0026#34; android:dataExtractionRules=\u0026#34;@xml/data_extraction_rules\u0026#34; android:fullBackupContent=\u0026#34;@xml/backup_rules\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:roundIcon=\u0026#34;@mipmap/ic_launcher_round\u0026#34; android:supportsRtl=\u0026#34;true\u0026#34; android:theme=\u0026#34;@style/Theme.Chapter5_Broadcast\u0026#34; tools:targetApi=\u0026#34;31\u0026#34;\u0026gt; \u0026lt;activity android:name=\u0026#34;.LoginActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 效果如下,点击ok后返回登录页\n登录页,输错账号密码会提示,输对跳转到MainActivity\n第6章 持久化技术 6.1 持久化技术简介 数据持久化是指将内存中的瞬时数据保存到存储设备中,Android提供了3种简单的方式实现: 文件存储,SharedPreference存储,数据库存储\n除此之外也可以保存在SD卡中,但这种方式不太安全\n6.2 文件存储 文件存储是Android中最基本的数据存储方式,不对存储内容进行任何格式化处理,数据原封不动保存到文件中,比较适合存储简单的数据\n6.2.1 将数据存储到文件中 Context类提供了一个**openFileOutput()**方法用于存储数据到指定文件中,参数1是文件名,参数2是操作模式\n文件名不能包含路径,所有文件存储到/data/data/\u0026lt;package_name\u0026gt;/files/下\n操作模式可选择MODE_PRIVATE(默认)和MODE_APPEND\n前者覆写原文件,后者追加\n文件操作模式原来还有两种,MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE,表示允许其他程序对本程序的文件进行读写,但这两种模式过于危险于Android4.2被废弃\n编写代码测试\n创建项目,修改layout,添加button用于确认保存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/input\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;Please input data:\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Store data\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; MainActivity,使用点击按钮保存数据,不使用书上back销毁活动保存(没复现出来)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package com.example.chapter6_storage; import android.content.Context; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.EditText; import androidx.appcompat.app.AppCompatActivity; import java.io.BufferedWriter; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); EditText input=findViewById(R.id.input); Button button=findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { String data=input.getText().toString(); saveData(data); } }); } //使用java文件流读写 public void saveData(String data){ FileOutputStream out=null; BufferedWriter writer=null; try{ out=openFileOutput(\u0026#34;data\u0026#34;, Context.MODE_PRIVATE); writer=new BufferedWriter(new OutputStreamWriter(out)); writer.write(data); } catch (IOException e){ e.printStackTrace(); }finally { try{ if(writer!=null){ writer.close(); } }catch (IOException e){ e.printStackTrace(); } } } } 通过设备管理器查找文件双击即可(按ctrl+f可快捷搜索)\n效果如下,保存数据成功\n6.2.2 从文件中读取数据 Context类提供了**openFileInput()**方法用于从文件读取数据,该方法仅接收一个参数\u0026ndash;要读取的文件名\n自动到/data/data/\u0026lt;package_name\u0026gt;/files/下加载文件并返回FileInputStream类,之后通过java的io流读取即可\n修改MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.example.chapter6_storage; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.EditText; import androidx.appcompat.app.AppCompatActivity; import java.io.BufferedReader; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStreamReader; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); EditText input=findViewById(R.id.input); Button button=findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { String data=readData(\u0026#34;data\u0026#34;);//读取文件并设置input文本内容 input.setText(data); } }); } public String readData(String name){ FileInputStream fileInputStream=null; BufferedReader reader = null; StringBuilder content=new StringBuilder(); try { fileInputStream=openFileInput(name); reader = new BufferedReader(new InputStreamReader(fileInputStream)); String line=\u0026#34;\u0026#34;; while ((line=reader.readLine())!=null){ content.append(line); } }catch (IOException e){ e.printStackTrace(); }finally { if (reader!=null){ try { reader.close(); }catch (IOException e){ e.printStackTrace(); } } } return content.toString(); } } 文件存储的核心是使用Context类提供的openFileInput和openFileOutput方法,再利用Java的IO流进行读写操作\n只适用于保存简单数据,不适用于复杂数据\n6.3 SharedPreferences存储 SharedPreferences使用键值对方式存储数据,支持多种不同数据类型存储,比文件存储更加简单易用\n6.3.1 将数据存储到SharedPreferences 使用SharedPreferences存储数据首先需要获取SharedPreferences对象,Android提供了3种方法获取\nContext类的getSharedPreferences()方法\n接收2个参数,参数1指定SharedPreferences文件名称,若不存在则创建,该文件存放在/data/data/\u0026lt;package_name\u0026gt;/shared_prefs/下\n参数2指定操作模式,目前只有MODE_PRIVATE可选(默认模式,和传0效果相同),表示只有当前程序可对该文件读写,其他模式均被废弃\nActivity类的getPreferences()方法\n和上一个方法类似,不过只接收一个操作模式参数,该方法自动将当前活动类名作为文件名\nPreferenceManager类的getDefaultSharedPreferences()方法\n静态方法,接收一个Context参数,并自动使用当前程序包名作为前缀命名文件\n得到SharedPreferences对象后即可存储数据,分3步实现:\n调用SharedPreferences.edit()获取SharedPreferences.Editor对象 向SharedPreferences.Editor添加数据,使用putDataType()添加,例如String用putString(),布尔用putBoolean() 调用apply()方法提交添加的数据完成存储 修改activity_main\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/save_data\u0026#34; android:text=\u0026#34;Save data\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 修改MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.example.chapter6_storage; import androidx.appcompat.app.AppCompatActivity; import android.content.SharedPreferences; import android.os.Bundle; import android.preference.PreferenceManager; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button=findViewById(R.id.save_data); //this.getPreferences(MODE_PRIVATE); //Activity的方法 //PreferenceManager.getDefaultSharedPreferencesName(this); //PreferenceManager的方法 button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SharedPreferences.Editor editor =getSharedPreferences(\u0026#34;data\u0026#34;,MODE_PRIVATE).edit();//获取editor对象 editor.putString(\u0026#34;name\u0026#34;,\u0026#34;Tom\u0026#34;);//写入数据 editor.putBoolean(\u0026#34;married\u0026#34;,false); editor.putInt(\u0026#34;age\u0026#34;,28); editor.apply();//提交数据 } }); } } 运行效果,文件使用xml形式,以键值对方式存储,其中string类型直接存储,其他类型使用value存储\n6.3.2 从SharedPreferences读取数据 SharedPreferences对象提供了一系列的getDataType()方法读取数据,每个get方法和前文的put方法一一对应\n每个get方法都接收两个参数: 参数1是键,传入存储时使用的键即可得到对应值; 参数2是默认值,表示找不到对应值时返回什么默认值\n修改布局文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/save_data\u0026#34; android:text=\u0026#34;Save data\u0026#34;/\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/restore_data\u0026#34; android:text=\u0026#34;Restore data\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 修改MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.example.chapter6_storage; import androidx.appcompat.app.AppCompatActivity; import android.content.SharedPreferences; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button=findViewById(R.id.save_data); Button reStoreData=findViewById(R.id.restore_data); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SharedPreferences.Editor editor =getSharedPreferences(\u0026#34;data\u0026#34;,MODE_PRIVATE).edit(); editor.putString(\u0026#34;name\u0026#34;,\u0026#34;Tom\u0026#34;); editor.putBoolean(\u0026#34;married\u0026#34;,false); editor.putInt(\u0026#34;age\u0026#34;,28); editor.apply(); } }); reStoreData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SharedPreferences pref=getSharedPreferences(\u0026#34;data\u0026#34;,MODE_PRIVATE);//直接获取对象读取数据 String name=pref.getString(\u0026#34;name\u0026#34;,\u0026#34;\u0026#34;); int age=pref.getInt(\u0026#34;age\u0026#34;,0); boolean married=pref.getBoolean(\u0026#34;married\u0026#34;,false); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;name is \u0026#34;+name); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;age is \u0026#34;+age); Log.d(\u0026#34;Mainactivity\u0026#34;,\u0026#34;married is \u0026#34;+married); } }); } } 运行效果\n相比之下SharedPreferences存储确实比文本存储简单方便,应用场景也多了不少,例如很多程序的应用偏好设置就利用到了该技术\n6.3.3 实现记住密码功能 使用上一章广播强制下线的登录界面,略作修改\ncheckbox是复选框控件,可通过点击进行选中和取消,使用该控件确认是否需要记住密码\nactivity_login.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;LinearLayout android:orientation=\u0026#34;horizontal\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;90dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:text=\u0026#34;Account:\u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/account\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:orientation=\u0026#34;horizontal\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;90dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:text=\u0026#34;Password\u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/password\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; android:inputType=\u0026#34;textPassword\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;CheckBox android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/checkbox\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:text=\u0026#34;Remember password\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/login\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:text=\u0026#34;Login\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; LoginActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package com.example.chapter6_storage; import android.app.Activity; import android.content.Intent; import android.content.SharedPreferences; import android.os.Bundle; import android.preference.PreferenceManager; import android.view.View; import android.widget.Button; import android.widget.CheckBox; import android.widget.EditText; import android.widget.Toast; import androidx.annotation.Nullable; public class LoginActivity extends Activity { private EditText accountEdit; private EditText passwordEdit; private Button login; private SharedPreferences pref; private SharedPreferences.Editor editor; private CheckBox checkBox; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); pref= PreferenceManager.getDefaultSharedPreferences(this); accountEdit=(EditText)findViewById(R.id.account); passwordEdit=(EditText)findViewById(R.id.password); checkBox=(CheckBox)findViewById(R.id.remember_password); login =(Button) findViewById(R.id.login); boolean isRemember=pref.getBoolean(\u0026#34;remember_password\u0026#34;,false);//最初没有存储数据,所以默认应该是false if (isRemember){ //如果选择了记住密码则自动填写账号密码并勾选checkbox String account =pref.getString(\u0026#34;account\u0026#34;,\u0026#34;\u0026#34;); String password =pref.getString(\u0026#34;password\u0026#34;,\u0026#34;\u0026#34;); accountEdit.setText(account); passwordEdit.setText(password); checkBox.setChecked(true);//这一步是为了显示并保证继续勾选记住密码,防止下次失效 } login.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { //获取账密登录 String account=accountEdit.getText().toString(); String password=passwordEdit.getText().toString(); if (account.equals(\u0026#34;admin\u0026#34;)\u0026amp;\u0026amp;password.equals(\u0026#34;123456\u0026#34;)){ editor=pref.edit(); if (checkBox.isChecked()){ //检验复选框是否被选中,若选中则存储账密和记住密码选项 editor.putBoolean(\u0026#34;remember_pass\u0026#34;,true); editor.putString(\u0026#34;account\u0026#34;,account); editor.putString(\u0026#34;password\u0026#34;,password); }else { editor.clear(); //取消勾选则清除存储数据 } editor.apply(); //跳转MainActivity Intent intent=new Intent(LoginActivity.this,MainActivity.class); startActivity(intent); finish(); }else { Toast.makeText(LoginActivity.this, \u0026#34;account or password is error!\u0026#34;, Toast.LENGTH_SHORT).show(); } } }); } } 运行效果,包名_preferences存储文件\n勾选后第二次打开自动填充账密\n6.4 SQLite数据库存储 Android系统内置了SQLite数据库,它是一款轻量级的关系型数据库,运算速度快,占用资源少,不仅支持标准SQL语法,还遵循数据库的ACID事物.\n6.4.1 创建数据库 Android提供了一个SQLiteOpenHelper帮助类,借助该类可以简单的对数据库进行创建和升级\nSQLiteOpenHelper是一个抽象类，使用它需要创建自己的帮助类并继承它\nSQLiteOpenHelper有两个抽象方法，分别是onCreate()和onUpgrade()，必须在自己的帮助类里面重写这两个方法，然后分别在这两个方法中去实现创建、升级数据库的逻辑。\nSQLiteOpenHelper中还有两个非常重要的实例方法: getReadableDatabase()和getWritableDatabase()\n这两个方法都可以创建或打开一个现有的数据库(如果数据库已存在则直接打开，否则创建一个新的数据库), 并返回一个可对数据库进行读写操作的对象\n当数据库不可写入的时候(如磁盘空间已满), getReadableDatabase()方法返回的对象将以只读的方式去打开数据库，而getWritableDatabase()方法则将出现异常\nSQLiteOpenHelper中有两个构造方法可供重写，一般使用参数少的构造方法即可,该构造方法接收4个参数\n第1个参数是Context，必须要有它才能对数据库进行操作。\n第2个参数是数据库名，创建数据库时使用的就是这里指定的名称。\n第3个参数允许我们在查询数据的时候返回一个自定义的Cursor，一般都是传入null。\n第4个参数表示当前数据库的版本号，可用于对数据库进行升级操作。\n构建出SQLiteOpenHelper的实例后, 再调用getReadableDatabase()或getWritableDatabase()方法够创建数据库\n数据库文件存放在/data/data/\u0026lt;package_name\u0026gt;/databases/目录下。\n此时重写的onCreate()方法也会得到执行，所以通常会在这里去处理一些创建表的逻辑。\n下面用例子来体会SQLiteOpenHelper的用法,新建DataBaseTest项目\n创建一个名为BookStore.db的数据库，然后在数据库中新建一张Book表，表中有id（主键）、作者、价格、页数和书名等列\nSQLite的数据类型比较简单,integer整型,real浮点型,text文本型,blob二进制型\n1 2 3 4 5 6 7 create table Book ( //autoincrement表示id列自增长 id integer primary key autoincrement, author text, price real, pages integer, name text) 新建MyDatabaseHelper类继承SQLiteOpenHelper\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.example.chapter6_storage; import android.content.Context; import android.database.sqlite.SQLiteDatabase; import android.database.sqlite.SQLiteOpenHelper; import android.widget.Toast; public class MyDatabaseHelper extends SQLiteOpenHelper { public static final String CREATE_BOOK = \u0026#34;create table Book (\u0026#34; + \u0026#34; id integer primary key autoincrement,\u0026#34; + \u0026#34; author text,\u0026#34; + \u0026#34; price real,\u0026#34; + \u0026#34; pages integer,\u0026#34; + \u0026#34; name text)\u0026#34;; private Context mContext; //context,数据库名,cursor,数据库版本 public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory,int version){ super(context,name,factory,version); mContext=context; } @Override public void onCreate(SQLiteDatabase sqLiteDatabase) { sqLiteDatabase.execSQL(CREATE_BOOK);//创建时执行sql语句 Toast.makeText(mContext, \u0026#34;Create DataBase Succeeded!\u0026#34;, Toast.LENGTH_SHORT).show(); } @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) { } } 修改activity_main\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/create_database\u0026#34; android:text=\u0026#34;Create database\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 修改MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package com.example.chapter6_storage; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { private MyDatabaseHelper myDatabaseHelper; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button=(Button) findViewById(R.id.create_database); myDatabaseHelper=new MyDatabaseHelper(this,\u0026#34;BookStore.db\u0026#34;,null,1); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { myDatabaseHelper.getWritableDatabase(); } }); } } 点击按钮时调用getWriteableDatabase()获取可读写的SQLiteDatabase对象\n第一次点击Create database按钮时，检测到当前程序中没有BookStore.db数据库，于是创建该数据库调用MyDatabaseHelper的onCreate()方法,并创建Book表\n再次点击Create database按钮时，此时已经存在BookStore.db数据库，不会再次创建\n效果如下: 成功创建数据库,其中.db-journal是用于支持事物而产生的临时日志文件,通常大小为0\n我们如何知道创建了的数据库的内容呢?通过adb工具+sqlite工具查看\nadb用于提取文件到主机方便分析,sqlite工具可在https://www.sqlite.org/download.html下载\nsqlite3+数据库文件名即可加载数据库\n.table可查看已创建的表,其中android_metadata表每个数据库都自动生成\n.schema可查看建表语句\n.exit或.quit退出编辑\n6.4.2 升级数据库 SQLiteOpenHelper还有一个onUpgrade()方法用于对数据库升级\n现在数据有Book表存放书籍详细信息,如果在想添加一张Category表记录图书分类怎么做?\n假设建表语句如下\n1 2 3 4 create table Category ( id integer primary key autoincrement, category_name text, category_code integer) 添加到MyDatabaseHelper中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package com.example.chapter6_storage; import android.content.Context; import android.database.sqlite.SQLiteDatabase; import android.database.sqlite.SQLiteOpenHelper; import android.widget.Toast; public class MyDatabaseHelper extends SQLiteOpenHelper { public static final String CREATE_BOOK =\u0026#34;create table Book (\u0026#34; + \u0026#34; id integer primary key autoincrement,\u0026#34; + \u0026#34; author text,\u0026#34; + \u0026#34; price real,\u0026#34; + \u0026#34; pages integer,\u0026#34; + \u0026#34; name text)\u0026#34;; public static final String CREATE_CATEGORY =\u0026#34;create table Category (\u0026#34; + \u0026#34; id integer primary key autoincrement,\u0026#34; + \u0026#34; category_name text,\u0026#34; + \u0026#34; category_code integer)\u0026#34;; private Context mContext; public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory,int version){ super(context,name,factory,version); mContext=context; } @Override public void onCreate(SQLiteDatabase sqLiteDatabase) { sqLiteDatabase.execSQL(CREATE_BOOK); sqLiteDatabase.execSQL(CREATE_CATEGORY); Toast.makeText(mContext, \u0026#34;Create Succeeded!\u0026#34;, Toast.LENGTH_SHORT).show(); } @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) { } } 此时运行程序并点击按钮会发现创建Category表失败,因为已经存在了BookStore数据库,再次点击按钮也不会执行MyDatabaseHelper的onCreate()方法\n解决这个问题可以卸载程序并重新运行,这样会删除原数据库,但这么做未免太极端,只需要使用onUpgrade()方法即可\n此处我们添加drop语句,当存在原表时则删除,之后调用onCreate重新创建即可\n1 2 3 4 5 6 @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) { sqLiteDatabase.execSQL(\u0026#34;drop table if exists Book\u0026#34;); sqLiteDatabase.execSQL(\u0026#34;drop table if exists Category\u0026#34;); onCreate(sqLiteDatabase); } 那么如何让onUpgrade()方法执行呢?\n只需要修改SQLiteOpenHelper构造方法的第4个参数,保证版本号更新即可(之前传入的是1)\n修改MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package com.example.chapter6_storage; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { private MyDatabaseHelper myDatabaseHelper; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button=(Button) findViewById(R.id.create_database); myDatabaseHelper=new MyDatabaseHelper(this,\u0026#34;BookStore.db\u0026#34;,null,2); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { myDatabaseHelper.getWritableDatabase(); } }); } } MainActivity创建MyDatabaseHelper实例时,由于版本号更新自动调用onUpgrade方法删除已有表\n之后点击创建按钮时调用getWriteableDatabase方法,自动调用onCreate方法创建表\n成功创建Category表\n6.4.3 添加数据 上面掌握了创建和升级数据库的方法,接下来学习对表中数据操作的方法\n对数据无非4种操作CRUD, C(create),R(retrieve),U(updata),d(delete), 每种操作又各自对应一条SQL命令, 例如insert,select,update,delete, 而Android提供了一系列的辅助方法,使得无需编写SQL语句即可完成CRUD的各种操作\nSQLiteOpenHelper的getReadableDatabase()和getWriteableDatabase()会返回SQLiteDatabase对象,通过该对象即可操作数据\nSQLiteDatabase.insert()方法用于添加数据\n参数1是表名\n参数2是用于在未指定添加数据的情况下,给某些可为空的列自动赋null,一般用不到,传null即可\n参数3是ContentValues对象,提供了一系列put方法重载用于添加数据,只需将列名及相应数据传入即可\n修改activity_main,新增添加数据按钮\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/create_database\u0026#34; android:text=\u0026#34;Create database\u0026#34;/\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/add_data\u0026#34; android:text=\u0026#34;Add data\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 修改MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.example.chapter6_storage; import androidx.appcompat.app.AppCompatActivity; import android.content.ContentValues; import android.database.sqlite.SQLiteDatabase; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.Toast; public class MainActivity extends AppCompatActivity { private MyDatabaseHelper myDatabaseHelper; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button=(Button) findViewById(R.id.create_database); Button addButton =(Button)findViewById(R.id.add_data); addButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SQLiteDatabase db=myDatabaseHelper.getWritableDatabase();//获取数据库对象 ContentValues contentValues=new ContentValues();//创建实例用于增加数据 contentValues.put(\u0026#34;name\u0026#34;,\u0026#34;Tom\u0026#39;s Life\u0026#34;);//列名+数据 contentValues.put(\u0026#34;author\u0026#34;,\u0026#34;Jack\u0026#34;); contentValues.put(\u0026#34;pages\u0026#34;,454); contentValues.put(\u0026#34;price\u0026#34;,16.96); db.insert(\u0026#34;Book\u0026#34;,null,contentValues);//插入第一条数据 contentValues.clear();//清空记录 contentValues.put(\u0026#34;name\u0026#34;,\u0026#34;Nioooe\u0026#39;s Life\u0026#34;); contentValues.put(\u0026#34;author\u0026#34;,\u0026#34;Brown\u0026#34;); contentValues.put(\u0026#34;pages\u0026#34;,332); contentValues.put(\u0026#34;price\u0026#34;,20.66); db.insert(\u0026#34;Book\u0026#34;,null,contentValues);//插入第二条数据 Toast.makeText(MainActivity.this,\u0026#34;Add data succeed!\u0026#34;,Toast.LENGTH_SHORT).show(); } }); myDatabaseHelper=new MyDatabaseHelper(this,\u0026#34;BookStore.db\u0026#34;,null,2); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { myDatabaseHelper.getWritableDatabase(); } }); } } 添加数据成功,其中id列自动增长\n6.4.4 更新数据 SQLiteDatabase中也提供了一个非常好用的update()方法，用于对数据进行更新，这个方法接收4个参数:\n第1个参数表名, 指定更新哪张表的数据。\n第2个参数是ContentValues对象, 组装更新数据。\n第3,4个参数用于约束更新某一行或某几行中的数据，不指定则默认更新所有行。\n修改布局,新增更新按钮\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/create_database\u0026#34; android:text=\u0026#34;Create database\u0026#34;/\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/add_data\u0026#34; android:text=\u0026#34;Add data\u0026#34;/\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/update_data\u0026#34; android:text=\u0026#34;Update data\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 修改MainActivity,新增updateData\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package com.example.chapter6_storage; import androidx.appcompat.app.AppCompatActivity; import android.content.ContentValues; import android.database.sqlite.SQLiteDatabase; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.Toast; public class MainActivity extends AppCompatActivity { private MyDatabaseHelper myDatabaseHelper; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button=(Button) findViewById(R.id.create_database); Button addButton =(Button)findViewById(R.id.add_data); addButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SQLiteDatabase db=myDatabaseHelper.getWritableDatabase();//获取数据库对象 ContentValues contentValues=new ContentValues();//创建实例用于增加数据 contentValues.put(\u0026#34;name\u0026#34;,\u0026#34;Tom\u0026#39;s Life\u0026#34;);//列名+数据 contentValues.put(\u0026#34;author\u0026#34;,\u0026#34;Jack\u0026#34;); contentValues.put(\u0026#34;pages\u0026#34;,454); contentValues.put(\u0026#34;price\u0026#34;,16.96); db.insert(\u0026#34;Book\u0026#34;,null,contentValues);//插入第一条数据 contentValues.clear();//清空记录 contentValues.put(\u0026#34;name\u0026#34;,\u0026#34;Nioooe\u0026#39;s Life\u0026#34;); contentValues.put(\u0026#34;author\u0026#34;,\u0026#34;Brown\u0026#34;); contentValues.put(\u0026#34;pages\u0026#34;,332); contentValues.put(\u0026#34;price\u0026#34;,20.66); db.insert(\u0026#34;Book\u0026#34;,null,contentValues);//插入第二条数据 Toast.makeText(MainActivity.this,\u0026#34;Add data succeed!\u0026#34;,Toast.LENGTH_SHORT).show(); } }); Button updateData=(Button)findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SQLiteDatabase db =myDatabaseHelper.getWritableDatabase(); ContentValues contentValues=new ContentValues(); contentValues.put(\u0026#34;price\u0026#34;,9.99); db.update(\u0026#34;Book\u0026#34;,contentValues,\u0026#34;name = ?\u0026#34;,new String[]{\u0026#34;Tom\u0026#39;s Life\u0026#34;});//修改Tom\u0026#39;s Lite这本书的价格 //参数3对应SQL语句的where表示更新所有name=?的行 ? 是占位符 //参数4提供的字符串数组会替换参数3的每个对应占位符 } }); myDatabaseHelper=new MyDatabaseHelper(this,\u0026#34;BookStore.db\u0026#34;,null,2); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { myDatabaseHelper.getWritableDatabase(); } }); } } 效果如下,成功更新\n6.4.5 删除数据 SQLiteDatabase.delete()用于删除数据,接收3个参数\n参数1 表名\n参数2,3 约束某行或某几行数据,不指定则默认删除所有行\n修改布局,添加删除按钮\n1 2 3 4 5 \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/delete_data\u0026#34; android:text=\u0026#34;Delete data\u0026#34;/\u0026gt; 修改MainActivity,限制条件和update类似\n1 2 3 4 5 6 7 8 9 10 ... Button deleteData=(Button)findViewById(R.id.delete_data); deleteData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SQLiteDatabase db=myDatabaseHelper.getWritableDatabase(); db.delete(\u0026#34;Book\u0026#34;,\u0026#34;pages \u0026gt; ?\u0026#34;,new String[]{\u0026#34;400\u0026#34;}); } }); ... 成功删除pages\u0026gt;400的书\n6.4.6 查询数据 SQLiteDatabase.query()方法用于查询,该方法非常负责,最短的重载也需要7个参数\n调用该方法后返回Cursor对象,通过该对象取出查询数据\n添加query按钮\n1 2 3 4 5 \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/query_data\u0026#34; android:text=\u0026#34;Query data\u0026#34;/\u0026gt; 修改MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ...... Button queryData=(Button)findViewById(R.id.query_data); queryData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SQLiteDatabase db =myDatabaseHelper.getWritableDatabase(); //查询book所有数据 Cursor cursor=db.query(\u0026#34;Book\u0026#34;,null,null,null,null,null,null); //moveToFirst移动数据指针到第一行 if (cursor.moveToFirst()){ //遍历cursor,逐条打印数据 do { //cursor.getColumnIndex()获取某列在表中的索引 如第1列,第3列等 //再通过cursor.getDataType()方法重载获取具体数据 //@SuppressLint(\u0026#34;Range\u0026#34;)用于忽略数据范围 getColumnIndex可能返回-1 @SuppressLint(\u0026#34;Range\u0026#34;) String name=cursor.getString(cursor.getColumnIndex(\u0026#34;name\u0026#34;)); @SuppressLint(\u0026#34;Range\u0026#34;) String author =cursor.getString(cursor.getColumnIndex(\u0026#34;author\u0026#34;)); @SuppressLint(\u0026#34;Range\u0026#34;) int pages=cursor.getInt(cursor.getColumnIndex(\u0026#34;pages\u0026#34;)); @SuppressLint(\u0026#34;Range\u0026#34;) double price=cursor.getDouble(cursor.getColumnIndex(\u0026#34;price\u0026#34;)); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;book name is \u0026#34;+name); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;author name is \u0026#34;+author); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;book pages is \u0026#34; +pages); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;book price is \u0026#34;+price); }while (cursor.moveToNext()); } cursor.close();//关闭cursor对象 } }); ...... 查询结果如下,成功打印信息\n6.4.7 使用SQL操作数据库 Android提供了很多API操作数据库，也提供了一系列的方法支持通过SQL操作数据库\n除查询数据调用SQLiteDatabase.rawQuery()方法外, 其他操作调用execSQL()方法, 通过?占位符+字符串数组替换参数\n添加数据\n1 db.execSQL(\u0026#34;insert into Book(name,author,pages,price)values(?,?,?,?)\u0026#34;,new String[]{\u0026#34;Mike\u0026#39;Life\u0026#34;,\u0026#34;Tom\u0026#34;,\u0026#34;333\u0026#34;,\u0026#34;17.99\u0026#34;}); 更新数据\n1 db.execSQL(\u0026#34;update Book set price = ? where name = ? \u0026#34;,new String[]{\u0026#34;10.99\u0026#34;,\u0026#34;The Da Vinci Code\u0026#34; }); 删除数据\n1 db.execSQL(\u0026#34;delete from Book where pages \u0026gt; ? \u0026#34;,new String[] { \u0026#34;400\u0026#34; }); 查询数据\n1 2 db.rawQuery(\u0026#34;select * from Book\u0026#34;,null); db.rawQuery(\u0026#34;select ?,?,? from book\u0026#34;,new String[]{\u0026#34;author\u0026#34;,\u0026#34;name\u0026#34;,\u0026#34;price\u0026#34;}); 6.5 使用SQLite框架操作数据库 书中的LitePal已停止维护,框架的使用大同小异,学习了SQLite原生操作和数据库基础足以应付一般场景\n等有需求再学习使用其他框架,如Room、Realm、GreenDAO、ObjectBox和SQLDelight等\n第7章 内容提供器 在上一章我们学习了Android数据持久化技术，包括文件存储、SharedPreferences存储以及数据库存储, 这些技术保存的数据都只能在当前应用程序中访问。文件和SharedPreferences存储曾提供MODE_WORLD_READABLE和MODE_WORLD_WRITEABLE 操作模式，用于其他应用程序访问当前应用的数据，但这两种模式在Android 4.2后被废弃,Android官方推荐使用更加安全可靠的内容提供器(ContentProvider)\n为什么要将我们程序中的数据共享给其他程序？当然，这个要视情况而定，例如账号和密码之类的隐私数据显然不能共享给其他程序，而某些可供其他程序进行二次开发的基础性数据，可以选择将其共享。\n例如系统的电话簿程序，它的数据库中保存了很多的联系人信息，如果这些数据都不允许第三方的程序访问，很多应用的功能都要大打折扣。除电话簿外，还有短信、媒体库等程序都实现了跨程序数据共享的功能，使用的技术就是内容提供器，下面我们就来对这一技术进行深入的探讨\n7.1 ContentProvider简介 内容提供器（Content Provider）主要用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访数据的安全性。目前，使用内容提供器是Android实现跨程序共享数据的标准方式。\n不同于文件存储和SharedPreferences存储中的两种全局可读写操作模式，内容提供器可以选择只对哪一部分数据进行共享，从而保证我们程序中的隐私数据不会有泄漏的风险。\n在正式开始学习内容提供器之前，需要先掌握另外一个非常重要的知识——Android运行时权限, 不光是内容提供器, 以后我们的开发过程中也会经常使用到运行时权限, 所以先要了解下Android运行时权限。\n7.2 运行时权限 Android的权限机制，从系统的第一个版本开始就已经存在。但旧的Android的权限机制在保护用户安全和隐私等方面起到的作用比较有限，尤其是一些大家都离不开的常用软件，非常容易“店大欺客”。\n为此，Android开发团队在Android 6.0中引用了运行时权限功能，从而更好地保护用户的安全和隐私，那么本节我们就来详细学习一下这个6.0系统中引入的新特性。\n7.2.1 Android权限机制 回顾一下过去Android的权限机制是什么样的, 在第5章写BroadcastTest项目时第一次接触了Android权限相关的内容，当时为了访问系统的网络状态以及监听开机广播，在AndroidManifest.xml文件中添加了两句权限声明：\n1 2 3 4 5 6 7 8 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; package=\u0026#34;com.example.broadcasttest\u0026#34;\u0026gt; ... \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.RECEIVE_BOOT_COMPLETED\u0026#34; /\u0026gt; ... \u0026lt;/manifest\u0026gt; 因为访问系统的网络状态以及监听开机广播涉及了用户设备的安全性，所以必须在AndroidManifest.xml中加入权限声明，否则我们的程序就会崩溃。加入了权限声明后，对于用户来说到底有什么影响呢？为什么这样就可以保护用户设备的安全性了呢？其实用户主要在以下两个方面得到了保护:\n一方面，如果用户在低于6.0系统的设备上安装该程序，会在安装界面给出下图所示的提醒。这样用户就可以清楚地知晓该程序一共申请了哪些权限，从而决定是否要安装这个程序\n另一方面，用户可以随时在应用程序管理界面查看任意一个程序的权限申请情况，以此保证应用程序不会出现各种滥用权限的情况。\n这种权限机制的设计思路非常简单，用户如果认可你所申请的权限，那么就会安装你的程序，如果不认可你所申请的权限，那么拒绝安装就可以。但理想很美好，现实很残酷，因为我们很多常用软件普遍存在着滥用权限的情况，不管到底用不用得到，反正先把权限申请了再说。比如说微信所申请的权限列表如图所示\n这只是微信所申请的一半左右的权限，因为权限太多一屏截不下来。其中有一些权限, 例如微信为什么要读取手机的短信和彩信？但是我们不认可又能怎样，难道拒绝安装微信？\nAndroid团队意识到了这个问题，于是在6.0中加入了运行时权限功能。用户不需要在安装软件的时候一次性授权所有申请的权限，而是可以在软件的使用过程中再对某一项权限申请进行授权。比如一款相机应用在运行时申请了地理位置定位权限，就算拒绝了这个权限，但是仍然可以使用其他功能，而不是像之前那样直接无法安装。\nAndroid将所有权限分为两类(第三类特殊权限使用情况很少不予讨论):\n**普通权限：**不会直接威胁到用户的安全和隐私的权限，对于这部分权限申请，系统会自动帮我们进行授权，不需要用户手动操作，比如在BroadcastTest项目中申请的两个权限就是普通权限。 **危险权限：**可能会触及用户隐私或者对设备安全性造成影响的权限，如获取设备联系人信息、定位设备的地理位置等，对于这部分权限申请，必须要由用户手动点击授权才可以，否则程序就无法使用相应的功能。 除危险权限外, 其余为普通权限, 下表列出了Android所有的危险权限, 共是9组24个权限:\n当使用某个权限时可以查看是否属于该表权限,如果是则进行运行时权限处理,不是则只需在Manifest.xml添加权限声明\n注意: 表中每个危险权限都属于一个权限组,进行运行时权限处理使用的是权限名,用户一旦同意授权那么该权限组中所有其他权限也会被授权\nAndroid完整权限列表: https://developer.android.com/reference/android/Manifest.permission\n7.2.2 程序运行时申请权限 新建项目学习运行时权限使用方法,上表中所有权限都可以申请,简单起见使用CALL_PHONE示例\n该权限在编写拨打电话功能时需要声明,由于拨打电话涉及用户手机资费问题,所以被设置为危险权限,在Android6.0前,拨打电话功能实现非常简单\n布局文件如下,提供call按钮\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/make_call\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Make Call\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; MainActivity如下,点击按钮触发拨打电话逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package com.example.chapter7_contentprovider; import androidx.appcompat.app.AppCompatActivity; import android.content.Intent; import android.net.Uri; import android.os.Bundle; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button make_call=(Button) findViewById(R.id.make_call); make_call.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { try { Intent intent=new Intent(Intent.ACTION_CALL);//内置电话动作 intent.setData(Uri.parse(\u0026#34;tel:10086\u0026#34;));//指定协议tel和电话号码 startActivity(intent); }catch (SecurityException e){ e.printStackTrace(); } } }); } } Intent.ACTION_CALL是系统内置的一个打电话动作,data部分指定协议为tel,号码为10086\n之前使用过Intent.ACTION_DIAL表示打开拨号界面,该功能则无需声明权限\n修改AndroidManifest.xml,添加权限声明如下:\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;uses-feature android:name=\u0026#34;android.hardware.telephony\u0026#34; android:required=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.CALL_PHONE\u0026#34;/\u0026gt; \u0026lt;application\u0026gt; ... \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 其中uses-permission标签用于声明需要的权限,uses-feature标签用于声明应用使用的一项硬件或软件功能\nrequired=false表示无需该权限程序可以运行,设置为true表示必须拥有该权限才能运行\n如果不添加该标签编译也可以通过,但会报错\n1 Permission exists without corresponding hardware `\u0026lt;uses-feature android:name=\u0026#34;android.hardware.telephony\u0026#34; required=\u0026#34;false\u0026#34;\u0026gt;` tag 参考隐含功能要求的权限和\u0026lt;uses-feature\u0026gt;\nAndroid5.1可以正常运行并触发CALL_PHONE\nAndroid6.0以上无法正常运行,会遇到报错\n修改MainActivity如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 package com.example.chapter7_contentprovider; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.core.app.ActivityCompat; import androidx.core.content.ContextCompat; import android.content.Intent; import android.content.pm.PackageManager; import android.net.Uri; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.Toast; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button make_call=(Button) findViewById(R.id.make_call); make_call.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { //检测是否具有权限,没有则申请 if (ContextCompat.checkSelfPermission(MainActivity.this,android.Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED){ ActivityCompat.requestPermissions(MainActivity.this,new String[]{android.Manifest.permission.CALL_PHONE},1); }else { call(); } } }); } //调用requestPermissions()方法后必定运行onRequestPermissionsResult回调函数 @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); //此处requestCode和ActivityCompat.requestPermissions()的参数3对应 switch (requestCode){ case 1: //判断是否成功获取权限 if (grantResults.length\u0026gt;0 \u0026amp;\u0026amp;grantResults[0]==PackageManager.PERMISSION_GRANTED){ call(); }else { Toast.makeText(this, \u0026#34;You denied the permission\u0026#34;, Toast.LENGTH_SHORT).show(); } break; default: } } private void call(){ try { Intent intent=new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(\u0026#34;tel:10086\u0026#34;)); startActivity(intent); }catch (SecurityException e){ e.printStackTrace(); } } } **运行时权限的核心是在程序运行过程中由用户授权去执行某些危险操作，程序不可以擅自执行危险操作。**因此，第一步要判断是否已经获取用户授权, 借助ContextCompat.checkSelfPermission()方法判断\n该方法接收两个参数，参数1是Context，参数2是具体权限名, 比如打电话的权限名是android.Manifest.permission.CALL_PHONE，然后将方法的返回值和PackageManager. PERMISSION_GRANTED比较，相等则说明用户已授权, 不等表示没有授权。\n如果已经授权则比较简单，直接执行拨打电话的call()方法即可\n如果没有授权，则需要调用**ActivityCompat. requestPermissions()**方法向用户申请授权\n该方法接收3个参数, 参数1要求是Activity的实例，参数2是一个String数组，我们把要申请的权限名放在数组中即可，参数3是请求码，只要是唯一值就即可，这里传入1。\n调用完requestPermissions()方法后，系统弹出一个权限申请的对话框，然后用户可以选择同意或拒绝我们的权限申请，不论是哪种结果，最终都会回调到**onRequestPermissionsResult()**方法中\n授权的结果则会封装在grantResults参数当中。我们只需要判断最后的授权结果，如果用户同意的话就调用call()方法来拨打电话，如果用户拒绝的话我们只能放弃操作，并且弹出一条失败提示。\n请求权限\n授权后成功拨打电话\n7.3 访问其他程序中的数据 内容提供器的用法一般有两种：\n使用现有内容提供器来访问对应程序的数据 创建自己的内容提供器给我们程序的数据提供外部访问接口 如果一个应用程序通过内容提供器对其数据提供了外部访问接口，那么任何其他的应用程序就都可以对这部分数据进行访问。\nAndroid系统中自带的电话簿、短信、媒体库等程序都提供了类似的访问接口，这就使得第三方应用程序可以充分地利用这部分数据来实现更好的功能。下面我们就来看一看，内容提供器到底是如何使用的。\n7.3.1 ContentProvider基本用法 想要访问内容提供器中共享的数据，必须借助ContentResolver类，可通过Context的getContentResolver()方法获取到该类的实例。ContentResolver中提供了一系列的方法用于对数据进行CRUD操作: insert()方，update()，delete()，query()。不同于SQLiteDatabase, ContentResolver的增删改查方法不接收表名参数，而是使用一个Uri参数代替，这个参数被称为内容URI。\n内容URI给内容提供器中的数据建立了唯一标识符，它主要由两部分组成：authority和path。\nauthority是用于对不同的应用程序做区分的，为了避免冲突，一般采用程序包名命名\n比如某个程序的包名是com.example.app，那么该程序对应的authority就可以命名为com.example.app.provider。\npath则是用于对同一应用程序中不同的表做区分的，通常都会添加到authority的后面\n比如某个程序的数据库里存在两张表：table1和table2，这时就可以将path分别命名为/table1和/table2，然后把authority和path进行组合，内容URI就变成了com.example.app.provider/table1和com.example.app.provider/table2\n另外需要在字符串的头部加上协议声明, 内容URI的标准格式如下\n1 2 content://com.example.app.provider/table1 content://com.example.app.provider/table2 **内容URI可以非常清楚地表达出我们想要访问哪个程序中哪张表里的数据。**因此，ContentResolver中的增删改查方法才都接收Uri对象作为参数，如果使用表名，系统将无法得知我们期望访问的是哪个应用程序里的表。在得到了内容URI字符串之后，我们还需要将它解析成Uri对象才可以作为参数传入。解析的方法也相当简单，只需要调用Uri.parse()方法，就可以将内容URI字符串解析成Uri对象:\n1 Uri uri = Uri.parse(\u0026#34;content://com.example.app.provider/table1\u0026#34;) 现在我们可以使用该Uri对象查询table1表中的数据：\n1 2 3 4 5 6 Cursor cursor = getContentResolver().query( uri, projection, selection, selectionArgs, sortOrder); 这些参数和SQLiteDatabase中query()方法里的参数很像，但总体来说要简单一些，毕竟这是在访问其他程序中的数据，没必要构建过于复杂的查询语句。下表对使用到的这部分参数进行了详细的解释。\n查询完成后返回一个Cursor对象，可从Cursor对象中逐个读取数据, 读取思路仍是通过移动游标的位置遍历Cursor的所有行，然后再取出每一行中相应列的数据，代码如下所示：\n1 2 3 4 5 6 7 if (cursor != null) { while (cursor.moveToNext()) { String column1 = cursor.getString(cursor.getColumnIndex(\u0026#34;column1\u0026#34;)); int column2 = cursor.getInt(cursor.getColumnIndex(\u0026#34;column2\u0026#34;)); } cursor.close(); } 添加数据\n1 2 3 4 ContentValues values = new ContentValues(); values.put(\u0026#34;column1\u0026#34;,\u0026#34;text\u0026#34;); values.put(\u0026#34;column2\u0026#34;,1); getContentResolver().insert(uri,values); 更新数据\n1 2 3 ContentValues values = new ContentValues(); values.put(\u0026#34;column1\u0026#34;,\u0026#34;\u0026#34;); getContentResolver().update(uri,values,\u0026#34;column1 = ? and column2 = ? \u0026#34;,new String[] {\u0026#34;text\u0026#34;,\u0026#34;1\u0026#34;}); 删除数据\n1 2 getContentResolver().delete(uri,\u0026#34;column2 = ? \u0026#34;,new String[] {\u0026#34;1\u0026#34;}); language-java复制代码 到此为止，我们就把ContentResolver中的增删改查方法全部学完了。接下来，利用目前所学实现读取系统电话簿中的联系人信息。\n7.3.2 获取系统联系人 首先在测试机的通讯录创建联系人用于后续测试\n修改布局,添加ListView\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;ListView android:id=\u0026#34;@+id/contacts_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 修改MainActivity,基本逻辑如下:\n首先获取ListView控件的实例，并设置适配器，然后调用运行时权限处理逻辑，因为READ_CONTACTS权限是属于危险权限,这里在用户授权后调用readContacts()读取系统联系人信息\nreadContacts()方法使用了ContentResolver.query()方法查询系统的联系人数据\n传入的Uri参数没有调用Uri.parse()方法解析一个内容URI字符串？因为ContactsContract.CommonDataKinds.Phone类已经封装了一个CONTENT_URI常量，该常量就是Uri.parse()方法解析出的结果\n遍历Cursor对象，将联系人姓名和手机号这些数据逐个取出\n姓名列对应的常量是ContactsContract.CommonDataKinds. Phone.DISPLAY_NAME\n手机号列对应的常量是ContactsContract.CommonData-Kinds.Phone.NUMBER\n两个数据都取出之后，将它们进行拼接，并且在中间加上换行符，然后将拼接后的数据添加到ListView的数据源里，并通知刷新一下ListView。最后千万不要忘记将Cursor对象关闭掉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 package com.example.chapter7_contentprovider; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.core.app.ActivityCompat; import androidx.core.content.ContextCompat; import androidx.core.content.PackageManagerCompat; import android.annotation.SuppressLint; import android.content.pm.PackageManager; import android.database.Cursor; import android.os.Bundle; import android.provider.ContactsContract; import android.widget.ArrayAdapter; import android.widget.ListView; import android.widget.Toast; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity { ArrayAdapter\u0026lt;String\u0026gt; adapter; List\u0026lt;String\u0026gt; contactList=new ArrayList\u0026lt;\u0026gt;(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ListView contactView=(ListView) findViewById(R.id.contacts_view); adapter=new ArrayAdapter\u0026lt;String\u0026gt;(this, android.R.layout.simple_list_item_1,contactList); contactView.setAdapter(adapter);//初始化ListView的adapter //检查/申请权限 if (ContextCompat.checkSelfPermission(this,android.Manifest.permission.READ_CONTACTS)!= PackageManager.PERMISSION_GRANTED){ ActivityCompat.requestPermissions(this,new String[]{android.Manifest.permission.READ_CONTACTS},1); }else { readContacts();//如果有权限则直接读取联系人 } } private void readContacts(){ Cursor cursor = null; try { //查询联系人数据 //ContactsContract.CommonDataKinds.Phone.CONTENT_URI是封装好的uri类,已经是Uri.parse()解析的结果 cursor=getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI,null,null,null,null); if (cursor!=null){ while (cursor.moveToNext()){ //获取联系人姓名 对应ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME @SuppressLint(\u0026#34;Range\u0026#34;) String displayname=cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); //获取联系人手机号 对应ContactsContract.CommonDataKinds.Phone.NUMBER @SuppressLint(\u0026#34;Range\u0026#34;) String number=cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); contactList.add(displayname+\u0026#34;\\n\u0026#34;+number);//添加数据 } adapter.notifyDataSetChanged();//通知ListView更新UI数据 } }catch (Exception e){ e.printStackTrace(); }finally { if (cursor!=null){ cursor.close(); } } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); //执行requestPermissions后如果授权则读取联系人,否则弹提示 switch (requestCode) { case 1: if (grantResults.length \u0026gt; 0 \u0026amp;\u0026amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { readContacts(); } else { Toast.makeText(this,\u0026#34;You denied the permission\u0026#34;,Toast.LENGTH_SHORT).show(); } break; default: } } } 最后在Manifest添加权限声明\n1 2 3 4 5 6 7 8 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_CONTACTS\u0026#34;/\u0026gt; \u0026lt;application\u0026gt; ... \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 运行效果如下\n首先请求授权\n授权后输出联系人信息\n7.4 创建自定义ContentProvider 上一节当中的思路较为简单，只需要获取到目标应用程序的内容URI，再借助ContentResolver进行CRUD操作即可。那些提供外部访问接口的应用程序是如何实现这种功能的呢？它们又是怎样保证数据的安全性，隐私数据不会泄漏出去？下面进行学习\n7.4.1 创建ContentProvider的步骤 如果想要实现跨程序共享数据的功能，官方推荐的方式是使用内容提供器，可通过新建一个类并继承ContentProvider的方式来创建一个自己的内容提供器。ContentProvider类中有6个抽象方法，我们在使用子类继承它的时候，需要将这6个方法全部重写。\n方法 作用 备注 onCreate() 初始化内容提供器时调用, 通常在这里完成对数据库的创建和升级等操作 返回true表示内容提供器初始化成功，返回false则表示失败 query() 从内容提供器中查询数据,查询的结果存放在Cursor对象中返回 uri确定查询哪张表，projection确定查询哪些列，selection和selectionArgs用于约束查询哪些行，sortOrder用于对结果排序 insert() 向内容提供器中添加一条数据,返回一个用于表示这条新记录的URI 使用uri参数确定要添加到的表，待添加的数据保存在values参数中 update() 更新内容提供器中已有的数据,返回受影响的行数 使用uri参数来确定更新哪一张表中的数据，新数据保存在values参数中，selection和selectionArgs参数用于约束更新哪些行 delete() 从内容提供器中删除数据,返回被删除的行数 使用uri参数来确定删除哪一张表中的数据，selection和selectionArgs参数用于约束删除哪些行 getType() 根据传入的内容URI来返回相应的MIME类型 可以看到，几乎每一个方法都会带有Uri这个参数，这个参数也正是调用ContentResolver的增删改查方法时传递过来的。我们需要对传入的Uri参数进行解析，从中分析出调用方期望访问的表和数据。标准的内容URI写法如下：\n1 content://com.example.app.provider/table 表示调用方期望访问的是com.example.app应用的table表中的数据。除此之外，我们还可以在这个内容URI的后面加上一个id：\n1 content://com.example.app.provider/table/1 内容URI的格式主要就只有以上两种:\n以路径结尾就表示期望访问该表中所有的数据 (app.provider路径+具体表名)\n以id结尾就表示期望访问该表中拥有相应id的数据 (app.provider路径+具体表名/id)\n可以使用通配符分别匹配这两种格式的内容URI:\n星号（*） 匹配任意长度的任意字符\n所以能够匹配指定appprovider任意表的内容URI格式可以写成\n1 content://com.example.app.provider/* 井号（#） 匹配任意长度的数字\n所以能够匹配table表中任意一行数据的内容URI格式可以写成\n1 content://com.example.app.provider/table/# 接着，再借助UriMatcher这个类就可以实现匹配内容URI的功能。UriMatcher中提供了一个addURI()方法，这个方法接收3个参数，分别把authority、path和某个自定义代码传入\n当调用UriMatcher.match()方法时，传入一个Uri对象，返回某个能够匹配这个Uri对象所对应的自定义代码(上面addURI绑定的)，利用该代码，可以判断出调用方期望访问的是哪张表中的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 package com.example.chapter7_contentprovider; import android.content.ContentProvider; import android.content.ContentValues; import android.content.UriMatcher; import android.database.Cursor; import android.net.Uri; import androidx.annotation.NonNull; import androidx.annotation.Nullable; public class MyProvider extends ContentProvider { public static final int TABLE1_DIR = 0;//枚举常量code用于确定需要匹配哪张表 public static final int TABLE1_ITEM = 1; public static final int TABLE2_DIR = 2; public static final int TABLE2_ITEM = 3; private static UriMatcher uriMatcher; static { uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); //provider+表格内容与枚举常量code绑定 uriMatcher.addURI(\u0026#34;com.example.app.provider\u0026#34;, \u0026#34;table1\u0026#34;, TABLE1_DIR); uriMatcher.addURI(\u0026#34;com.example.app.provider\u0026#34;, \u0026#34;table1/#\u0026#34;, TABLE1_ITEM); uriMatcher.addURI(\u0026#34;com.example.app.provider\u0026#34;, \u0026#34;table2\u0026#34;, TABLE2_DIR); uriMatcher.addURI(\u0026#34;com.example.app.provider\u0026#34;, \u0026#34;table2/#\u0026#34;, TABLE2_ITEM); } @Override public boolean onCreate() { return false; } @Nullable @Override public Cursor query(@NonNull Uri uri, @Nullable String[] strings, @Nullable String s, @Nullable String[] strings1, @Nullable String s1) { //判断uri匹配,返回对应枚举常量code,根据不同code执行不同逻辑 switch (uriMatcher.match(uri)) { case TABLE1_DIR: //查询table1表中的所有数据 break; case TABLE1_ITEM: //查询table1表中的单条数据 break; case TABLE2_DIR: //查询table2表中的所有数据 break; case TABLE2_ITEM: //查询table2表中的单条数据 break; } return null; } @Nullable @Override public String getType(@NonNull Uri uri) { return \u0026#34;\u0026#34;; } @Nullable @Override public Uri insert(@NonNull Uri uri, @Nullable ContentValues contentValues) { return null; } @Override public int delete(@NonNull Uri uri, @Nullable String s, @Nullable String[] strings) { return 0; } @Override public int update(@NonNull Uri uri, @Nullable ContentValues contentValues, @Nullable String s, @Nullable String[] strings) { return 0; } } 可以看到，MyProvider中新增了4个整型常量:\nTABLE1_DIR表示访问table1表中的所有数据 TABLE1_ITEM表示访问table1表中的单条数据 TABLE2_DIR表示访问table2表中的所有数据 TABLE2_ITEM表示访问table2表中的单条数据 接着在静态代码块里我们创建了UriMatcher的实例，并调用addURI()方法，将期望匹配的内容URI格式传递进去，注意这里传入的路径参数是可以使用通配符的。然后，当query()方法被调用的时候，就会通过UriMatcher的match()方法对传入的Uri对象进行匹配，如果发现UriMatcher中某个内容URI格式成功匹配了该Uri对象，则会返回相应的自定义代码，然后我们就可以判断出调用方期望访问的到底是什么数据了。\n上述代码以query()方法为例，insert()、update()、delete()这几个方法的实现是类似的，它们都会携带Uri这个参数，然后同样利用UriMatcher.match()方法判断出调用方期望访问的是哪张表，再对该表中的数据进行相应的操作即可。\n对于getType()方法,它是所有的内容提供器都必须提供的一个方法，用于获取Uri对象所对应的MIME类型。\n一个内容URI所对应的MIME类型字符串由3部分组成，格式规定如下:\n以vnd.开头\n如果内容URI以路径结尾，则后接android.cursor.dir/，如果内容URI以id结尾，则后接android.cursor.item/\n最后接上vnd.\u0026lt;authority\u0026gt;.\u0026lt;path\u0026gt;\n所以，对于content://com.example.app.provider/table这个内容URI，它所对应的MIME类型就可以写成：\n1 vnd.android.cursor.dir/vnd.com.example.app.provider.table 对于content://com.example.app.provider/table/1这个内容URI，它所对应的MIME类型就可以写成：\n1 vnd.android.cursor.item/vnd.com.example.app.provider.table 继续完善MyProvider中的内容，实现getType()方法中的逻辑，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ...... @Nullable @Override public String getType(@NonNull Uri uri) { //根据uri不同匹配结果返回不同mime类型 switch (uriMatcher.match(uri)){ case TABLE1_DIR: return \u0026#34;vnd.android.cursor.dir/vnd.com.example.app.provider.table1\u0026#34;; case TABLE1_ITEM: return \u0026#34;vnd.android.cursor.item/vnd.com.example.app.provider.table1\u0026#34;; case TABLE2_DIR: return \u0026#34;vnd.android.cursor.dir/vnd.com.example.app.provider.table2\u0026#34;; case TABLE2_ITEM: return \u0026#34;vnd.android.cursor.item/vnd.com.example.app.provider.table2\u0026#34;; default: break; } return null; } ...... 到此为止，一个完整的内容提供器就创建完成了，现在任何一个应用程序都可以使用ContentResolver来访问我们程序中的数据。那么,如何才能保证隐私数据不会泄漏出去呢？\n内容提供器的良好机制使得这个问题在不知不觉中已经被解决了。因为所有的CRUD操作都一定要匹配到相应的内容URI格式才能进行，而我们不可能向UriMatcher中添加隐私数据的URI，所以这部分数据根本无法被外部程序访问到，安全问题也就不存在了。\n总结创建步骤如下:\n编写MyContentProvider继承自ContentProvider 确定常量代码和提供的URI绑定 实现ContentProvider的6个抽象方法 针对getType()单独处理,返回对应MIME类型格式 7.4.2 实现跨程序数据共享 实战一下，真正体验一回跨程序数据共享的功能。为简单起见,继续第6章的数据库项目开发,通过内容提供器为其加入外部访问接口.首先将MyDatabaseHelper使用Toast弹出创建数据库成功的提示去除,因为跨程序访问时不能直接使用Toast(与Context有关)\n右键com.example.chapter6_storage\u0026gt;new\u0026gt;other\u0026gt;Content Provider创建\nexported表示是否允许外部程序访问内容提供器\nenabled表示是否启用内容提供器\n修改代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 package com.example.chapter6_storage; import android.content.ContentProvider; import android.content.ContentValues; import android.content.UriMatcher; import android.database.Cursor; import android.database.sqlite.SQLiteDatabase; import android.net.Uri; public class DatabaseProvider extends ContentProvider { public static final int BOOK_DIR = 0;//Book表所有数据 public static final int BOOK_ITEM = 1;//Book表单条数据 public static final int CATEGORY_DIR = 2;//Category表所有数据 public static final int CATEGORY_ITEM = 3;//Category表单条数据 public static final String AUTHORITY = \u0026#34;com.example.chapter6_storage.provider\u0026#34;;//本提供器的Authority private static UriMatcher uriMatcher; private MyDatabaseHelper dbHelper; static { //初始化UriMacher,绑定URI和常量代码 uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(AUTHORITY,\u0026#34;book\u0026#34;,BOOK_DIR); uriMatcher.addURI(AUTHORITY,\u0026#34;book/#\u0026#34;,BOOK_ITEM); uriMatcher.addURI(AUTHORITY,\u0026#34;category\u0026#34;,CATEGORY_DIR); uriMatcher.addURI(AUTHORITY,\u0026#34;category/#\u0026#34;,CATEGORY_ITEM); } public DatabaseProvider() { } @Override public boolean onCreate() { //创建DataHelper实例,返回true表示创建成功,此时数据库完成创建/升级 dbHelper=new MyDatabaseHelper(getContext(),\u0026#34;BookStore.db\u0026#34;,null,2); return true; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { SQLiteDatabase db=dbHelper.getReadableDatabase();//获取数据库实例 Cursor cursor=null; //根据匹配情况进行对应查询,结果存到cursor返回 switch (uriMatcher.match(uri)){ case BOOK_DIR: cursor =db.query(\u0026#34;Book\u0026#34;,projection,selection,selectionArgs,null,null,sortOrder); break; case CATEGORY_DIR: cursor = db.query(\u0026#34;Category\u0026#34;,projection,selection,selectionArgs,null,null,sortOrder); break; case BOOK_ITEM: //uri.getPathSegments()方法将URI权限后的部分以/分割 故0号位置为path(表名) 1号位置为id String bookId = uri.getPathSegments().get(1);//获取id用于约束 cursor = db.query(\u0026#34;Book\u0026#34;,projection,\u0026#34;id = ?\u0026#34;,new String[]{ bookId },null,null,sortOrder); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); cursor = db.query(\u0026#34;Category\u0026#34;,projection,\u0026#34;id = ?\u0026#34;,new String[]{ categoryId },null,null,sortOrder); break; default: break; } return cursor; } @Override public Uri insert(Uri uri, ContentValues values) { SQLiteDatabase db = dbHelper.getWritableDatabase(); Uri uriReturn = null; switch (uriMatcher.match(uri)) { case BOOK_DIR: case CATEGORY_DIR: case BOOK_ITEM: long newBookId = db.insert(\u0026#34;Book\u0026#34;,null,values); //解析Content URI为Uri对象 uriReturn = Uri.parse(\u0026#34;content://\u0026#34; + AUTHORITY + \u0026#34;/book/\u0026#34; + newBookId); break; case CATEGORY_ITEM: long newCategoryId = db.insert(\u0026#34;Category\u0026#34;,null,values); uriReturn = Uri.parse(\u0026#34;content://\u0026#34; + AUTHORITY + \u0026#34;/category/\u0026#34; + newCategoryId); break; default: break; } return uriReturn;//insert方法要求返回能表示这条新增数据的URI } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { SQLiteDatabase db = dbHelper.getWritableDatabase(); int updateRows = 0;//返回被更新的行数 switch (uriMatcher.match(uri)) { case BOOK_DIR: //更新所有约束行 updateRows = db.update(\u0026#34;Book\u0026#34;,values,selection,selectionArgs); break; case BOOK_ITEM: //更新指定id行 String bookId = uri.getPathSegments().get(1); updateRows = db.update(\u0026#34;Book\u0026#34;,values,\u0026#34;id = ?\u0026#34;,new String[] { bookId }); break; case CATEGORY_DIR: updateRows = db.update(\u0026#34;Category\u0026#34;,values,selection,selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); updateRows = db.update(\u0026#34;Category\u0026#34;,values,\u0026#34;id = ?\u0026#34;,new String[] { categoryId }); break; default: break; } return updateRows; } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { SQLiteDatabase db=dbHelper.getWritableDatabase(); int deleteRows=0;//返回被删除的行数 switch (uriMatcher.match(uri)){ case BOOK_DIR: //删除所有约束行 deleteRows=db.delete(\u0026#34;book\u0026#34;,selection,selectionArgs); break; case BOOK_ITEM: //删除指定id行 String bookid=uri.getPathSegments().get(1); deleteRows=db.delete(\u0026#34;book\u0026#34;,\u0026#34;id = ?\u0026#34;,new String[]{bookid}); case CATEGORY_DIR: deleteRows=db.delete(\u0026#34;Category\u0026#34;,selection,selectionArgs); break; case CATEGORY_ITEM: String categoryid=uri.getPathSegments().get(1); deleteRows=db.delete(\u0026#34;Category\u0026#34;,\u0026#34;id = ?\u0026#34;,new String[]{categoryid}); break; } return deleteRows; } @Override public String getType(Uri uri) { switch (uriMatcher.match(uri)) { case BOOK_DIR: return \u0026#34;vnd.android.cursor.dir/vnd.com.example.chapter6_storage.provider.book\u0026#34;; case BOOK_ITEM: return \u0026#34;vnd.android.cursor.item/vnd.com.example.chapter6_storage.provider.book\u0026#34;; case CATEGORY_DIR: return \u0026#34;vnd.android.cursor.dir/vnd.com.example.chapter6_storage.provider.category\u0026#34;; case CATEGORY_ITEM: return \u0026#34;vnd.android.cursor.item/vnd.com.example.chapter6_storage.provider.category\u0026#34;; } return null; } } 首先在开始同样是定义了4个常量，分别用于表示访问Book表中的所有数据、访问Book表中的单条数据、访问Category表中的所有数据和访问Category表中的单条数据。然后，在静态代码块里对UriMatcher进行初始化，将添加期望匹配的几种URI格式并绑定常量代码\n解析下实现的各个方法:\nonCreate()\n创建MyDatabaseHelper实例，返回true表示内容提供器初始化成功，此时数据库已经完成创建或升级。\nquery()\n先获取SQLiteDatabase实例，然后根据传入的Uri参数判断出用户想要访问哪张表，再调用SQLiteDatabase.query()进行查询，并将结果存储到Cursor对象返回\n注意: 访问单条数据的时候有一个细节，这里调用了Uri对象的**getPathSegments()**方法，它会将内容URI权限之后的部分以“/”符号进行分割，并把分割后的结果放入到一个字符串列表中.该列表第0个位置存放的是路径，第1个位置存放的是id。得到了id后，再通过selection和selectionArgs参数进行约束，就实现了查询单条数据的功能\ninsert()\n先获取到了SQLiteDatabase的实例，然后根据传入的Uri参数判断出用户想要往哪张表里添加数据，再调用SQLiteDatabase的insert()方法进行添加\n注意: insert()方法，要求返回一个能够表示这条新增数据的URI，所以我们还需要调用Uri.parse()方法来将一个内容URI解析成Uri对象，当然这个内容URI是以新增数据的id结尾的\nupdate()\n先获取SQLiteDatabase实例，根据传入的Uri参数判断出用户想要更新哪张表里的数据，再调用SQLiteDatabase的update()方法进行更新，返回受影响的行数\ndelete()\n先获取SQLiteDatabase实例，根据传入的Uri参数判断出用户想要删除哪张表里的数据，再调用SQLiteDatabase的delete()方法进行删除就好了，返回被删除的行数\ngetType()\n按照上一节中介绍的格式规则编写即可\n另外需要在AndroidManifest注册Provider,使用Android快捷新建会自动注册\n注意安装该程序前先删除原程序,防止上一章的遗留数据干扰,安装后创建数据库并添加数据\n之后修改Chapter7_ContentProvider,实现访问DatabaseProvider数据的功能\n布局如下,增删改查4个按钮\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/add_data\u0026#34; android:text=\u0026#34;Add To Book\u0026#34;/\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/query_data\u0026#34; android:text=\u0026#34;Query From Book\u0026#34;/\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/update_data\u0026#34; android:text=\u0026#34;Update Book\u0026#34;/\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/delete_data\u0026#34; android:text=\u0026#34;Delete From Book\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 修改MainActivity,分别在4个按钮的点击事件中处理增删改查逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 package com.example.chapter7_contentprovider; import androidx.appcompat.app.AppCompatActivity; import android.annotation.SuppressLint; import android.content.ContentValues; import android.database.Cursor; import android.net.Uri; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { private String newId; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button adddata=(Button) findViewById(R.id.add_data); adddata.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Uri uri= Uri.parse(\u0026#34;content://com.example.databasetest.provider/book\u0026#34;); ContentValues contentValues=new ContentValues(); contentValues.put(\u0026#34;name\u0026#34;,\u0026#34;A king\u0026#34;); contentValues.put(\u0026#34;author\u0026#34;,\u0026#34;Tom\u0026#34;); contentValues.put(\u0026#34;price\u0026#34;,22.85); contentValues.put(\u0026#34;pages\u0026#34;,1040); Uri newUri=getContentResolver().insert(uri,contentValues); newId=newUri.getPathSegments().get(1); } }); Button queryData=(Button) findViewById(R.id.query_data); queryData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Uri uri=Uri.parse(\u0026#34;content://com.example.databasetest.provider/book\u0026#34;); Cursor cursor=getContentResolver().query(uri,null,null,null,null); if (cursor!=null){ while (cursor.moveToNext()){ @SuppressLint(\u0026#34;Range\u0026#34;) String name=cursor.getString(cursor.getColumnIndex(\u0026#34;name\u0026#34;)); @SuppressLint(\u0026#34;Range\u0026#34;) String author=cursor.getString(cursor.getColumnIndex(\u0026#34;author\u0026#34;)); @SuppressLint(\u0026#34;Range\u0026#34;) int pages=cursor.getInt(cursor.getColumnIndex(\u0026#34;pages\u0026#34;)); @SuppressLint(\u0026#34;Range\u0026#34;) double price =cursor.getDouble(cursor.getColumnIndex(\u0026#34;price\u0026#34;)); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;book name is \u0026#34;+name); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;book author is \u0026#34;+author); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;book pages is \u0026#34;+pages); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;book price is \u0026#34;+price); } cursor.close(); } } }); Button updateData=(Button) findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Uri uri=Uri.parse(\u0026#34;content://com.example.databasetest.provider/book/\u0026#34;+newId); ContentValues contentValues=new ContentValues(); contentValues.put(\u0026#34;name\u0026#34;,\u0026#34;Two kings\u0026#34;); contentValues.put(\u0026#34;price\u0026#34;,9.99); contentValues.put(\u0026#34;pages\u0026#34;,666); getContentResolver().update(uri,contentValues,null,null); } }); Button deleteData=(Button) findViewById(R.id.delete_data); deleteData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Uri uri=Uri.parse(\u0026#34;content://com.example.databasetest.provider/book/\u0026#34;+newId); getContentResolver().delete(uri,null,null); } }); } } 代码解析:\n添加数据\n首先调用Uri.parse()将一个内容URI解析成Uri对象，然后把要添加的数据都存放到ContentValues对象中，接着调用ContentResolver的insert()方法执行添加操作就可以了。注意insert()方法会返回一个Uri对象，这个对象中包含了新增数据的id，我们通过getPathSegments()方法将这个id取出，稍后会用到它。\n查询数据\n同样是调用了Uri.parse()方法将一个内容URI解析成Uri对象，然后调用ContentResolver的query()方法去查询数据，查询的结果当然还是存放在Cursor对象中的。之后对Cursor进行遍历，从中取出查询结果，并一一打印出来。\n更新数据\n也是先将内容URI解析成Uri对象，然后把想要更新的数据存放到ContentValues对象中，再调用ContentResolver的update()方法执行更新操作就可以了。注意这里我们为了不想让Book表中的其他行受到影响，在调用Uri.parse()方法时，给内容URI的尾部增加了一个id，而这个id正是添加数据时所返回的。这就表示我们只希望更新刚刚添加的那条数据，Book表中的其他行都不会受影响。\n删除数据\n也是使用同样的方法解析了一个以id结尾的内容URI，然后调用ContentResolver的delete()方法执行删除操作就可以了。由于我们在内容URI里指定了一个id，因此只会删掉拥有相应id的那行数据，Book表中的其他数据都不会受影响。\n最后,在Android11以后由于权限策略,访问其他应用的content provider需要添加声明\n修改Manifest如下\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;queries\u0026gt; \u0026lt;provider android:authorities=\u0026#34;com.example.chapter6_storage.provider\u0026#34;/\u0026gt; \u0026lt;/queries\u0026gt; \u0026lt;!--需要声明访问的provider--\u0026gt; \u0026lt;application ...... \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 可以看到成功调用各类接口\n第8章 运用手机多媒体 8.1 使用通知 通知（Notification）是Android系统中比较有特色的一个功能，当某个应用程序希望向用户发出一些提示信息，而该应用程序又不在前台运行时，就可以借助通知来实现。\n发出一条通知后，手机最上方的状态栏中会显示一个通知的图标，下拉状态栏后可以看到通知的详细内容。\n8.1.1 通知的基本用法 通知的用法较为灵活，既可以在活动里创建，也可以在广播接收器里创建，还可以在下一章中即将学习的在服务里创建。相比于广播接收器和服务，在活动里创建通知的场景还是比较少的，因为一般当程序进入到后台的时候我们才需要使用通知。\n无论是在哪里创建通知，整体的步骤都是相同的,首先需要一个NotificationManager来对通知进行管理，可以调用Context的getSystemService()方法获取到。\ngetSystemService()方法接收一个字符串参数用于确定获取系统的哪个服务，这里我们传入Context.NOTIFICATION_SERVICE即可。因此，获取NotificationManager的实例就可以写成：\n1 NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE); 接下来，需要使用一个Builder构造器来创建Notification对象，但问题在于，几乎Android系统的每一个版本都会对通知这部分功能进行或多或少的修改，API不稳定性问题在通知上面突显得尤其严重。那么该如何解决这个问题呢？\n其实解决方案我们之前已经见过好几回了，就是使用support库中提供的兼容API。support-v4库中提供了一个NotificationCompat类，使用这个类的构造器来创建Notification对象，就可以保证我们的程序在所有Android系统版本上都能正常工作了，代码如下所示：\n1 Notification notification = new NotificationCompat.Builder(context).build(); 注: 该方法自Android8.0后被废弃,推荐使用新方法(添加了channelId参数)\n1 NotificationCompat.Builder(Context context, String channelId) 创建具体的通知\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.example.chapter8_media; import android.app.Notification; import android.app.NotificationManager; import android.content.Context; import android.graphics.BitmapFactory; import android.os.Bundle; import androidx.appcompat.app.AppCompatActivity; import androidx.core.app.NotificationCompat; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE); Notification notification = new NotificationCompat.Builder(MainActivity.this,\u0026#34;default\u0026#34;) .setContentTitle(\u0026#34;This is content title\u0026#34;) //指定通知的标题 .setContentText(\u0026#34;This is content text\u0026#34;) //指定通知的正文内容 .setWhen(System.currentTimeMillis()) //指定通知被创建的时间，以毫秒为单位，当下拉系统状态栏时，这里指定的时间会显示在相应的通知上 .setSmallIcon(R.mipmap.ic_launcher) //设置通知的小图标 .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher_round)).build();//设置通知的大图标，当下拉系统状态栏时，可以看到设置的大图标 } } 方法解释\nsetContentTitle()\n指定通知的标题内容，下拉系统状态栏就可以看到这部分内容\nsetContentText()\n指定通知的正文内容，同样下拉系统状态栏就可以看到这部分内容\nsetWhen()\n指定通知被创建的时间，以毫秒为单位，当下拉系统状态栏时，这里指定的时间会显示在相应的通知上\nsetSmallIcon()\n设置通知的小图标，注意只能使用纯alpha图层的图片进行设置，小图标会显示在系统状态栏上。\nsetLargeIcon()\n设置通知的大图标，当下拉系统状态栏时，就可以看到设置的大图标\n创建完毕Notification对象后调用NotificationManager.notify()方法即可显示通知,id参数需要保证每个通知的id都不同\n1 public void notify(int id, Notification notification) 修改布局,添加发送通知按钮\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/send_notice\u0026#34; android:text=\u0026#34;Send notice\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 修改MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.example.chapter8_media; import androidx.appcompat.app.AppCompatActivity; import androidx.core.app.NotificationCompat; import android.app.Notification; import android.app.NotificationChannel; import android.app.NotificationManager; import android.graphics.BitmapFactory; import android.os.Build; import android.os.Bundle; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendNotice=(Button)findViewById(R.id.send_notice); sendNotice.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { //Android 8.0+需要开启channel NotificationManager manager=(NotificationManager) getSystemService(NOTIFICATION_SERVICE); if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { String channelId = \u0026#34;default\u0026#34;; //通道名称 String channelName = \u0026#34;默认通知\u0026#34;; manager.createNotificationChannel(new NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_HIGH)); } //创建通知 Notification notification = new NotificationCompat.Builder(MainActivity.this,\u0026#34;default\u0026#34;) .setContentTitle(\u0026#34;My notification\u0026#34;) .setContentText(\u0026#34;Hello World!\u0026#34;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher_round)).build(); //通知 manager.notify(1,notification); } }); } } Android8.0以后需要开启channel才能使用通知,参考NotificationCompat.Builder（）过时，失效\nAndroid13以后需要添加通知权限声明,参考https://developer.android.com/develop/ui/views/notifications/build-notification?hl=zh-cn\n1 \u0026lt;uses-permission android:name=\u0026#34;android.permission.POST_NOTIFICATIONS\u0026#34; /\u0026gt; 运行后效果如下,成功弹出通知\n但下拉系统状态栏并点击这条通知时，没有任何效果。要想实现通知的点击效果，还需要在代码中进行相应的设置，这就涉及了一个新的概念：PendingIntent。\nPendingIntent从名字上看起来就和Intent有些类似，它们之间也确实存在着不少共同点。比如它们都可以去指明某一个“意图”，都可以用于启动活动、启动服务以及发送广播等。不同的是，Intent更加倾向于去立即执行某个动作，而PendingIntent更加倾向于在某个合适的时机去执行某个动作。所以，也可以把PendingIntent简单地理解为延迟执行的Intent。\nPendingIntent的用法同样很简单，它主要提供了几个静态方法用于获取PendingIntent的实例，可以根据需求来选择是使用getActivity()方法、getBroadcast()方法，还是getService()方法。这几个方法所接收的参数都是相同的：\n第一个参数依旧是Context，不用多做解释。 第二个参数一般用不到，通常都是传入0即可。 第三个参数是一个Intent对象，我们可以通过这个对象构建出PendingIntent的“意图”。 第四个参数用于确定PendingIntent的行为,默认推荐PendingIntent.FLAG_IMMUTABLE(不能传0) 对PendingIntent有了一定的了解后，我们再回过头来看一下NotificationCompat.Builder。这个构造器还可以再连缀一个**setContentIntent()**方法，接收的参数正是一个PendingIntent对象。因此，这里就可以通过PendingIntent构建出一个延迟执行的“意图”，当用户点击这条通知时就会执行相应的逻辑。\n在我们来优化一下项目，给刚才的通知加上点击功能，让用户点击它的时候可以启动另一个活动。首先需要准备好另一个活动，右键包→New→Activity→Empty Activity，新建NotificationActivity，布局起名为notification_layout\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;RelativeLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerInParent=\u0026#34;true\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; android:text=\u0026#34;This is notification layout\u0026#34;/\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 修改MainActivity,点击通知跳转到NotificationActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.example.chapter8_media; import androidx.appcompat.app.AppCompatActivity; import androidx.core.app.NotificationCompat; import android.app.Notification; import android.app.NotificationChannel; import android.app.NotificationManager; import android.app.PendingIntent; import android.content.Intent; import android.graphics.BitmapFactory; import android.os.Build; import android.os.Bundle; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendNotice=(Button)findViewById(R.id.send_notice); sendNotice.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Intent intent =new Intent(MainActivity.this,NotificationActivity.class); PendingIntent pendingIntent=PendingIntent.getActivity(MainActivity.this,0,intent, PendingIntent.FLAG_IMMUTABLE); NotificationManager manager=(NotificationManager) getSystemService(NOTIFICATION_SERVICE); if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { String channelId = \u0026#34;default\u0026#34;; String channelName = \u0026#34;默认通知\u0026#34;; manager.createNotificationChannel(new NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_HIGH)); } Notification notification = new NotificationCompat.Builder(MainActivity.this,\u0026#34;default\u0026#34;) .setContentTitle(\u0026#34;My notification\u0026#34;) .setContentText(\u0026#34;Hello World!\u0026#34;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentIntent(pendingIntent).build();//添加pendingIntent manager.notify(1,notification); } }); } } 然而，点击之后系统状态上的通知图标还没有消失。如果我们没有在代码中对该通知进行取消，它就会一直显示在系统的状态栏上。解决的方法有两种，一种是在NotificationCompat.Builder中再连缀一个setAutoCancel()方法，一种是显式地调用NotificationManager的cancel()方法将它取消\n第一种,创建通知时使用.setAutoCancel()传入true即可(比较方便)\n1 2 3 Notification notification = new NotificationCompat.Builder(MainActivity.this,\u0026#34;default\u0026#34;) .setAutoCancel(true) .build(); 第二种,给NoticificationActivity添加代码,使用NotificationManager.cancel()\n注意传入的id要和调用manager.notify()通知时的id一致\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package com.example.chapter8_media; import android.app.NotificationManager; import android.os.Bundle; import androidx.appcompat.app.AppCompatActivity; public class NotificationActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_notification); NotificationManager notificationManager=(NotificationManager) getSystemService(NOTIFICATION_SERVICE); notificationManager.cancel(1);//主动调用cancel关闭通知,注意id要对应 } } 8.1.2 通知的进阶技巧 NotificationCompat.Builder中提供了非常丰富的API来让我们创建出更加多样的通知效果,从中选一些比较常用的API来进行学习。先来看看setSound()方法，它可以在通知发出的时候播放一段音频。\nsetSound()方法接收一个Uri参数，所以在指定音频文件的时候还需要先获取到音频文件对应的URI。比如说，每个手机的/system/media/audio/ringtones目录下都有很多的音频文件，我们可以从中随便选一个音频文件，那么在代码中就可以这样指定：\n1 2 3 Notification notification = new NotificationCompat.Builder(MainActivity.this,\u0026#34;default\u0026#34;) .setSound(Uri.fromFile(new File(\u0026#34;/system/media/audio/ringtones/music.mp3\u0026#34;))) .build(); 我们还可以使用.setVibrate()方法,在通知到来的时候让手机进行振动。需要传入一个长整型的数组，用于设置手机静止和振动的时长，以毫秒为单位。\n下标为0的值表示手机静止的时长，下标为1的值表示手机振动的时长，下标为2的值又表示手机静止的时长，以此类推。所以，如果想要让手机在通知到来的时候立刻振动1秒，然后静止1秒，再振动1秒，代码就可以写成：\n1 2 3 4 Notification notification = new NotificationCompat.Builder(MainActivity.this,\u0026#34;default\u0026#34;) ... .setVibrate(new long[] {0,1000,1000,1000}) .build(); 以上代码在Android 8.0后无效,由**NotificationChannel#setVibrationPattern(long[])**代替setVibrate\n并且无法指定震动频率,等价于enableVibration(true),实际上震动为系统默认\n1 2 3 4 5 6 7 8 if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { String channelId = \u0026#34;default\u0026#34;; String channelName = \u0026#34;默认通知\u0026#34;; NotificationChannel notificationChannel=new NotificationChannel(channelId,channelName,NotificationManager.IMPORTANCE_HIGH); notificationChannel.enableVibration(true); notificationChannel.setVibrationPattern(new long[]{1000,1000,1000,1000,1000,1000}); manager.createNotificationChannel(notificationChannel); } 不过，想要控制手机振动还需要声明权限。因此，我们还得编辑AndroidManifest.xml文件，加入如下声明：\n1 \u0026lt;uses-permission android:name=\u0026#34;android.permission.VIBRATE\u0026#34;/\u0026gt; 下面我们来看一下如何在通知到来时控制手机LED灯的显示。现在的手机基本上都会前置一个LED灯，当有未接电话或未读短信，而此时手机又处于锁屏状态时，LED灯就会不停地闪烁，提醒用户去查看\n我们可以使用setLights()方法来实现这种效果，setLights()方法接收3个参数：\n第一个参数用于指定LED灯的颜色 第二个参数用于指定LED灯亮起的时长，以毫秒为单位 第三个参数用于指定LED灯暗去的时长，也是以毫秒为单位 所以，当通知到来时，如果想要实现LED灯以绿色的灯光一闪一闪的效果，就可以写成：\n1 2 3 Notification notification = new NotificationCompat.Builder(MainActivity.this,\u0026#34;default\u0026#34;) .setLights(Color.GREEN,1000,1000) .build(); 如果你不想进行那么多繁杂的设置，也可以直接使用通知的默认效果，它会根据当前手机的环境来决定播放什么铃声，以及如何振动，写法如下：\n1 2 3 Notification notification = new NotificationCompat.Builder(MainActivity.this,\u0026#34;default\u0026#34;) .setDefaults(NotificationCompat.DEFAULT_ALL) .build(); 注意，以上所涉及的这些进阶技巧都要在手机上运行才能看得到效果，模拟器是无法表现出振动以及LED灯闪烁等功能的\n在Android8.0以后,使用如下代码替代\n1 2 notificationChannel.enableLights(true); notificationChannel.setLightColor(Color.GREEN); 8.1.3 通知的高级功能 继续观察NotificationCompat.Builder这个类，你会发现里面还有很多API是我们没有使用过的\nsetStyle()方法,这个方法允许我们构建出富文本的通知内容,也就是说通知中不光可以有文字和图标,还可以包含更多的东西setStyle()方法接收一个NotificationCompat.Style参数，这个参数就是用来构建具体的富文本信息的，如长文字、图片等\n在开始使用setStyle()方法之前，我们先来做一个试验吧，之前的通知内容都比较短，如果设置成很长的文字会是什么效果呢？\n1 2 3 4 Notification notification = new NotificationCompat.Builder(MainActivity.this,\u0026#34;default\u0026#34;) .setContentTitle(\u0026#34;My notification\u0026#34;) .setContentText(\u0026#34;Learn how to build notifications,send and sync data, and use voice actions.Get the official Android IDE and developer tools to build apps for Android.\u0026#34;) .build(); 现在重新运行程序并触发通知,效果如下,过长文本会被省略\n1 setStyle(new NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(getResources(),R.drawable.img))) 另外\nPRIORITY_DEFAULT 表示默认的重要程度，和不设置效果是一样的 PRIORITY_MIN 表示最低的重要程度，系统可能只会在特定的场景才显示这条通知，比如用户下拉状态栏的时候 PRIORITY_LOW 表示较低的重要程度，系统可能会将这类通知缩小，或改变其显示的顺序，将其排在更重要的通知之后 PRIORITY_HIGH 表示较高的重要程度，系统可能会将这类通知放大，或改变其显示的顺序，将其排在比较靠前的位置 PRIORITY_MAX 表示最高的重要程度，这类通知消息必须要让用户立刻看到，甚至需要用户做出响应操作 具体写法如下 1 2 3 Notification notification = new NotificationCompat.Builder(MainActivity.this,\u0026#34;default\u0026#34;) .setPriority(NotificationCompat.PRIORITY_MAX) .build(); 这里我们将通知的重要程度设置成了最高，表示这是一条非常重要的通知，要求用户必须立刻看到\n8.2 调用摄像头和相册 8.2.1 调用摄像头拍照 8.2.2 从相册中选择图片 8.3 播放多媒体文件 8.3.1 播放音频 8.3.2 播放视频 第9章 使用网络技术 作为开发者，我们需要考虑如何利用网络来编写出更加出色的应用程序，像QQ、微博、微信等常见的应用都会大量使用网络技术。本章主要学习如何在手机端使用HTTP协议和服务器端进行网络交互，并对服务器返回的数据进行解析，这也是Android中最常使用到的网络技术\n9.1 WebView的用法 比如说，要求在应用程序里展示一些网页。加载和显示网页通常都是浏览器的任务，但是需求里又明确指出，不允许打开系统浏览器，而我们当然也不可能自己去编写一个浏览器出来，这时应该怎么办呢？\nAndroid早就已经考虑到了，并提供了一个WebView控件，借助它就可以在自己的应用程序里嵌入一个浏览器，从而非常轻松地展示各种各样的网页。WebView的用法也是相当简单，下面我们就通过一个例子来学习一下吧。新建项目Chapter9_Web，修改activity_main.xml：\n1 2 3 4 5 6 7 8 9 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;WebView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:id=\u0026#34;@+id/web_view\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 在布局文件中使用到了一个新的控件：WebView。这个控件用来显示网页的，给它设置了一个id，并让它充满整个屏幕。然后修改MainActivity中的代码，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.example.webviewtest; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.webkit.WebView; import android.webkit.WebViewClient; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); WebView webView=(WebView) findViewById(R.id.web_view); webView.getSettings().setJavaScriptEnabled(true);//支持js脚本 webView.setWebViewClient(new WebViewClient());//保证web页面在当前webview显示,而非打开系统浏览器 webView.loadUrl(\u0026#34;https://www.baidu.com\u0026#34;); } } MainActivity中，首先使用findViewById()方法获取到了WebView的实例，然后调用WebView的getSettings()方法可以去设置一些浏览器的属性，这里只是调用了setJavaScriptEnabled()方法来让WebView支持JavaScript脚本\n接下来，调用了WebView的setWebViewClient()方法，并传入了一个WebViewClient的实例。这段代码的作用是，当需要从一个网页跳转到另一个网页时，我们希望目标网页仍然在当前WebView中显示，而不是打开系统浏览器。\n最后一步，调用WebView的loadUrl()方法，并将网址传入，即可展示相应网页的内容\n注意: 由于本程序使用到了网络功能，而访问网络是需要声明权限的，因此需要加入权限声明,如下所示\n1 2 3 4 5 6 7 8 9 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34;/\u0026gt; \u0026lt;application android:usesCleartextTraffic=\u0026#34;true\u0026#34; ...\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 运行效果如下\n9.2 使用HTTP协议访问网络 如果说真的要去深入分析HTTP协议，可能需要花费整整一本书的篇幅。这里只需要稍微了解一些就足够了，它的工作原理特别简单，就是客户端向服务器发出一条HTTP请求，服务器收到请求之后会返回一些数据给客户端，然后客户端再对这些数据进行解析和处理就可以了。\n比如，上一节中使用到的WebView控件，其实也就是我们向服务器发起了一条HTTP请求，接着服务器分析出我们想要访问的页面，于是会把该网页的HTML代码进行返回，然后WebView再调用手机浏览器的内核对返回的HTML代码进行解析，最终将页面展示出来。\n简单来说，WebView已经在后台帮我们处理好了发送HTTP请求、接收服务响应、解析返回数据，以及最终的页面展示这几步工作，不过由于它封装得实在是太好了，反而使得我们不能那么直观地看出HTTP协议到底是如何工作的。因此，接下来就让我们通过手动发送HTTP请求的方式，来更加深入地理解一下这个过程。\n9.2.1 使用HttpURLConnection 过去，Android上发送HTTP请求一般有两种方式：HttpURLConnection和HttpClient\n由于HttpClient存在API数量过多、扩展困难等缺点，在Android 6.0系统中，HttpClient被完全移除，此功能被正式弃用，因此本小节我们学习现在官方建议使用的HttpURLConnection的用法\n首先需要获取到HttpURLConnection的实例，一般只需new出一个URL对象，传入目标的网络地址，然后调用openConnection()方法即可\n1 2 URL url = new URL(\u0026#34;http://baidu.com\u0026#34;); HttpURLConnection connection = (HttpURLConnection)url.openConnection(); 在得到了HttpURLConnection的实例之后，可以设置一下HTTP请求所使用的方法。常用的方法主要有两个：GET和POST。GET表示希望从服务器那里获取数据，而POST则表示希望提交数据给服务器。写法如下\n1 connection.setRequestMethod(\u0026#34;GET\u0026#34;); 接下来，就可以进行一些自由的定制了，比如设置连接超时、读取超时的毫秒数，以及服务器希望得到的一些消息头等。这部分内容根据自己的实际情况进行编写，示例写法如下：\n1 2 connection.setConnectTimeout(8000); connection.setReadTimeout(8000); 之后再调用getInputStream()方法就可以获取到服务器返回的输入流了，剩下的任务就是对输入流进行读取，如下所示：\n1 InputStream in = connection.getInputStream(); 最后，可以调用disconnect()方法将这个HTTP连接关闭掉，如下所示：\n1 connection.disconnect(); 下面通过一个具体的例子来真正体验一下HttpURLConnection的用法。修改activity_main.xml，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/send_request\u0026#34; android:text=\u0026#34;Send Request\u0026#34;/\u0026gt; \u0026lt;ScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:id=\u0026#34;@+id/response_text\u0026#34;/\u0026gt; \u0026lt;/ScrollView\u0026gt; \u0026lt;/LinearLayout\u0026gt; 使用了一个新的控件：ScrollView，它是用来做什么的呢？由于手机屏幕的空间一般都比较小，有些时候过多的内容一屏是显示不下的，借助ScrollView控件的话，我们就可以以滚动的形式查看屏幕外的那部分内容。另外，布局中还放置了一个Button和一个TextView, Button用于发送HTTP请求，TextView用于将服务器返回的数据显示出来。接着修改MainActivity中的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 package com.example.chapter9_web; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.Reader; import java.net.HttpURLConnection; import java.net.URL; public class MainActivity extends AppCompatActivity implements View.OnClickListener{ TextView responseText; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendRequest =(Button) findViewById(R.id.send_request); responseText=(TextView) findViewById(R.id.response_text); sendRequest.setOnClickListener(this); } @Override public void onClick(View view) { if (view.getId()==R.id.send_request){ sendRequestWithHttpURLConnection(); } } private void sendRequestWithHttpURLConnection(){ new Thread(new Runnable() { @Override public void run() { HttpURLConnection connection=null; BufferedReader reader=null; try { URL url=new URL(\u0026#34;http://www.baidu.com\u0026#34;); connection=(HttpURLConnection) url.openConnection(); connection.setRequestMethod(\u0026#34;GET\u0026#34;); connection.setConnectTimeout(8000); connection.setReadTimeout(8000); InputStream in =connection.getInputStream(); //下面对获取到的输入流进行读取 reader=new BufferedReader(new InputStreamReader(in)); String line; StringBuilder response=new StringBuilder(); while ((line =reader.readLine())!=null){ response.append(line); } showResponse(response.toString()); }catch (Exception e){ e.printStackTrace(); }finally { if (reader!=null){ try { reader.close(); }catch (IOException e){ e.printStackTrace(); } } if (connection!=null){ connection.disconnect(); } } } }).start(); } private void showResponse(final String response){ runOnUiThread(new Runnable() { @Override public void run() { responseText.setText(response); } }); } } 在Send Request按钮的点击事件里调用了sendRequestWithHttpURLConnection()方法，在这个方法中先是开启了一个子线程，然后在子线程里使用HttpURLConnection发出一条HTTP请求，请求的目标地址就是百度的首页。接着利用BufferedReader对服务器返回的流进行读取，并将结果传入到了showResponse()方法中。\n而在showResponse()方法里则是调用了一个runOnUiThread()方法，然后在这个方法的匿名类参数中进行操作，将返回的数据显示到界面上。为什么要用这个runOnUiThread()方法呢？因为Android不允许在子线程中进行UI操作，需要通过这个方法将线程切换到主线程，再更新UI元素\n运行效果如下,返回的html文件以文本形式展现\n服务器返回给我们的就是这种HTML代码，只是通常情况下浏览器都会将这些代码解析成漂亮的网页后再展示出来。\n那么如果是想要提交数据给服务器应该怎么办呢？只需要将HTTP请求的方法改成POST，并在获取输入流之前把要提交的数据写出即可。注意每条数据都要以键值对的形式存在，数据与数据之间用“\u0026amp;”符号隔开，比如说我们想要向服务器提交用户名和密码，就可以这样写(类似url中的get方法传参形式)\n1 2 3 connection.setRequestMethod(\u0026#34;POST\u0026#34;); DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream()) ; outputStream.writeBytes(\u0026#34;username=admin\u0026amp;\u0026amp;password=123456\u0026#34;); 9.2.2 使用OkHttp 当然，我们并不是只能使用HttpURLConnection，完全没有任何其他选择，事实上在开源盛行的今天，有许多出色的网络通信库都可以替代原生的HttpURLConnection，而其中OkHttp无疑是做得最出色的一个。\nOkHttp是由Square公司开发的，这个公司在开源事业上面贡献良多，除OkHttp外，还开发了Picasso、Retrofit等著名的开源项目。OkHttp不仅在接口封装上面做得简单易用，就连在底层实现上也是自成一派，比起原生的HttpURLConnection，可以说是有过之而无不及，现在已经成了广大Android开发者首选的网络通信库。那么本小节我们就来学习一下OkHttp的用法，OkHttp项目地址：https://github.com/square/okhttp\n在使用OkHttp之前，我们需要先在项目中添加OkHttp库的依赖。编辑app/build.gradle文件，在dependencies闭包中添加如下内容：\n1 implementation(\u0026#34;com.squareup.okhttp3:okhttp:4.12.0\u0026#34;) 添加上述依赖会自动下载两个库，一个是OkHttp库，一个是Okio库，后者是前者的通信基础。\n下面我们来看一下OkHttp的具体用法，首先需要创建一个OkHttpClient的实例，如下所示：\n1 OkHttpClient client = new OkHttpClient(); 接下来，如果想要发起一条HTTP请求，就需要创建一个Request对象,通过url()方法来设置目标的网络地址\n1 2 3 Request request = new Request.Builder() .url(\u0026#34;https://www.baidu.com\u0026#34;) .build(); 之后，调用OkHttpClient的newCall()方法创建一个Call对象，并调用它的execute()方法发送请求并获取服务器返回的数据，写法如下：\n1 Response response = client.newCall(request).execute(); 其中，Response对象就是服务器返回的数据了，我们可以使用如下写法来得到返回的具体内容：\n1 String responseData = response.body().string(); 如果是发起一条POST请求会比GET请求稍微复杂一点，我们需要先构建出一个RequestBody对象来存放待提交的参数，如下所示：\n1 2 3 4 RequestBody requestBody = new FormBody.Builder() .add(\u0026#34;username\u0026#34;,\u0026#34;admin\u0026#34;) .add(\u0026#34;password\u0026#34;,\u0026#34;123456\u0026#34;) .build(); 然后，在Request.Builder中调用一下post()方法，并将RequestBody对象传入：\n1 2 3 4 Request request = new Request.Builder() .url(\u0026#34;http://www.baidu.com\u0026#34;) .post(requestBody) .build(); 接下来的操作就和GET请求一样了，调用execute()方法来发送请求并获取服务器返回的数据即可。\n书中后面所有网络相关的功能我们都将会使用OkHttp来实现，到时候再进行进一步的学习。那么现在我们先把NetworkTest这个项目改用OkHttp的方式再实现一遍吧。由于布局部分完全不用改动，所以现在直接修改MainActivity中的代码，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 private void sendRequestWithOkHttp(){ new Thread(new Runnable() { @Override public void run() { try { OkHttpClient okHttpClient=new OkHttpClient(); Request request=new Request.Builder() .url(\u0026#34;https://www.baidu.com\u0026#34;) .build(); Response response=okHttpClient.newCall(request).execute(); String responseData=response.body().string(); showResponse(responseData); }catch (Exception e){ e.printStackTrace(); } } }).start(); } 这里并没有做太多的改动，只是添加了一个sendRequestWithOkHttp()方法，并在Send Request按钮的点击事件里去调用这个方法。在这个方法中同样还是先开启了一个子线程，然后在子线程里使用OkHttp发出一条HTTP请求，请求的目标地址还是百度的首页，OkHttp的用法也正如前面所介绍的一样。\n最后仍然还是调用了showResponse()方法来将服务器返回的数据显示到界面上。重新运行一下程序,点击SendRequest按钮后，测试结果OK，由此证明，使用OkHttp来发送HTTP请求的功能也已经成功实现了。\n9.3 解析XML格式数据 通常情况下，每个需要访问网络的应用程序都会有一个自己的服务器，我们可以向服务器提交数据，也可以从服务器上获取数据。不过这个时候就出现了一个问题，这些数据到底要以什么样的格式在网络上传输呢？随便传递一段文本肯定是不行的，因为另一方根本就不会知道这段文本的用途是什么。因此，一般我们都会在网络上传输一些格式化后的数据，这种数据会有一定的结构规格和语义，当另一方收到数据消息之后就可以按照相同的结构规格进行解析，从而取出他想要的那部分内容。\n在网络上传输数据时最常用的格式有两种：XML和JSON，下面我们就来一个一个地进行学习，本节首先学习一下如何解析XML格式的数据。在开始之前我们还需要先解决一个问题，就是从哪儿才能获取一段XML格式的数据呢？这里我们学习搭建一个最简单的Web服务器，在这个服务器上提供一段XML文本，然后我们在程序里去访问这个服务器，再对得到的XML文本进行解析。\n搭建Web服务器其实非常简单，有很多的服务器类型可供选择,这里使用kali linux虚拟机运行apatch服务器,保证虚拟机直连物理网络,和手机wifi处于同一网段\n1 2 systemctl start apache2 systemctl status apache2 接下来创建一个get_data.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;apps\u0026gt; \u0026lt;app\u0026gt; \u0026lt;id\u0026gt;1\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Google Maps\u0026lt;/name\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/app\u0026gt; \u0026lt;app\u0026gt; \u0026lt;id\u0026gt;2\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Chrome\u0026lt;/name\u0026gt; \u0026lt;version\u0026gt;2.1\u0026lt;/version\u0026gt; \u0026lt;/app\u0026gt; \u0026lt;app\u0026gt; \u0026lt;id\u0026gt;3\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Google Play\u0026lt;/name\u0026gt; \u0026lt;version\u0026gt;2.3\u0026lt;/version\u0026gt; \u0026lt;/app\u0026gt; \u0026lt;/apps\u0026gt; 移动到/var/www/html/路径下(该路径为linux下apache服务器默认的网页根目录)\n1 sudo mv get_data.xml /var/www/html/ 主机可访问xml文件即可\n准备工作结束,接下来开始解析xml数据\n9.3.1 Pull解析方式 继续使用Chapter9_Web项目,修改MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 private void parseXMLWithPull(String xmlData){ try { //通过Xml解析工厂获取实例 XmlPullParserFactory xmlPullParserFactory=XmlPullParserFactory.newInstance(); XmlPullParser xmlPullParser=xmlPullParserFactory.newPullParser(); //为解析器提供xml流 xmlPullParser.setInput(new StringReader(xmlData)); //获取事件的类型 int eventType=xmlPullParser.getEventType(); String id=\u0026#34;\u0026#34; ; String name=\u0026#34;\u0026#34;; String version=\u0026#34;\u0026#34;; //直到文件尾 while (eventType!=XmlPullParser.END_DOCUMENT){ String nodeName=xmlPullParser.getName(); //用switch对不同事件进行处理 switch (eventType){ //开始读标签，通过解析器的getName方法获得标签名进行比较 case XmlPullParser.START_TAG:{ if (\u0026#34;id\u0026#34;.equals(nodeName)){ //获取节点内容 id=xmlPullParser.nextText(); }else if (\u0026#34;name\u0026#34;.equals(nodeName)){ name=xmlPullParser.nextText(); }else if (\u0026#34;version\u0026#34;.equals(nodeName)){ version=xmlPullParser.nextText(); } break; } //标签结束，进行打印 case XmlPullParser.END_TAG:{ if (\u0026#34;app\u0026#34;.equals(nodeName)){ Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;id is \u0026#34;+id); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;name is \u0026#34;+name); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;version is \u0026#34;+version); } break; } default: break; } //解析下一个元素 eventType=xmlPullParser.next(); } } catch (Exception e){ e.printStackTrace(); } } private void sendRequestWithOkHttp(){ new Thread(new Runnable() { @Override public void run() { try { OkHttpClient okHttpClient=new OkHttpClient(); Request request=new Request.Builder() .url(\u0026#34;http://192.168.88.132/get_data.xml\u0026#34;) .build(); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;Get Response Successed!Parsing XML....\u0026#34;); Response response=okHttpClient.newCall(request).execute(); String responseData=response.body().string(); parseXMLWithPull(responseData); }catch (Exception e){ e.printStackTrace(); } } }).start(); } 运行效果如下\n在得到了服务器返回的数据后，调用parseXMLWithPull()方法解析服务器返回的数据parseXMLWithPull()方法中的代码，首先要获取到一个XmlPullParserFactory的实例，并借助这个实例得到XmlPullParser对象，然后调用XmlPullParser的setInput()方法将服务器返回的XML数据设置进去就可以开始解析了。\n解析的过程也非常简单，通过getEventType()可以得到当前的解析事件，然后在一个while循环中不断地进行解析，如果当前的解析事件不等于XmlPullParser.END_DOCUMENT，说明解析工作还没完成，调用next()方法后可以获取下一个解析事件。\n在while循环中，我们通过getName()方法得到当前节点的名字，如果发现节点名等于id、name或version，就调用nextText()方法来获取节点内具体的内容，每当解析完一个app节点后就将获取到的内容打印出来。\n9.3.2 SAX解析方式 Pull解析方式虽然非常好用，但它并不是我们唯一的选择。SAX解析也是一种特别常用的XML解析方式，虽然它的用法比Pull解析要复杂一些，但在语义方面会更加清楚。通常情况下我们都会新建一个类继承自DefaultHandler，并重写父类的5个方法，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package com.example.networktest; import org.xml.sax.Attributes; import org.xml.sax.SAXException; import org.xml.sax.helpers.DefaultHandler; public class ContentHandler extends DefaultHandler { @Override public void startDocument() throws SAXException { super.startDocument(); } @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException { super.startElement(uri, localName, qName, attributes); } @Override public void characters(char[] ch, int start, int length) throws SAXException { super.characters(ch, start, length); } @Override public void endElement(String uri, String localName, String qName) throws SAXException { super.endElement(uri, localName, qName); } @Override public void endDocument() throws SAXException { super.endDocument(); } }language-java复制代码 startDocument()方法会在开始XML解析的时候调用；\nstartElement()方法会在开始解析某个节点的时候调用；\ncharacters()方法会在获取节点中内容的时候调用；\nendElement()方法会在完成解析某个节点的时候调用；\nendDocument()方法会在完成整个XML解析的时候调用。\n其中，startElement()、characters()和endElement()这3个方法是有参数的，从XML中解析出的数据就会以参数的形式传入到这些方法中。需要注意的是，在获取节点中的内容时，characters()方法可能会被调用多次，一些换行符也被当作内容解析出来，我们需要针对这种情况在代码中做好控制。那么下面就让我们尝试用SAX解析的方式来实现和上一小节中同样的功能吧。新建一个ContentHandler类继承自DefaultHandler，并重写父类的5个方法，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package com.example.networktest; import android.util.Log; import org.xml.sax.Attributes; import org.xml.sax.SAXException; import org.xml.sax.helpers.DefaultHandler; public class ContentHandler extends DefaultHandler { private String nodeName; private StringBuilder id; private StringBuilder name; private StringBuilder version; @Override public void startDocument() throws SAXException { id=new StringBuilder(); name =new StringBuilder(); version=new StringBuilder(); } @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException { //记录当前节点名字 nodeName=localName; } @Override public void characters(char[] ch, int start, int length) throws SAXException { //根据当前的节点名判断内容添加到哪一个StringBUilder对象中 if (\u0026#34;id\u0026#34;.equals(nodeName)){ id.append(ch,start,length); } else if (\u0026#34;name\u0026#34;.equals(nodeName)){ name.append(ch,start,length); }else if (\u0026#34;version\u0026#34;.equals(nodeName)){ version.append(ch,start,length); } } @Override public void endElement(String uri, String localName, String qName) throws SAXException { if (\u0026#34;app\u0026#34;.equals(localName)){ Log.d(\u0026#34;ContentHandler\u0026#34;,\u0026#34;id is + \u0026#34;+id.toString().trim()); Log.d(\u0026#34;ContentHandler\u0026#34;,\u0026#34;name is + \u0026#34;+name.toString().trim()); Log.d(\u0026#34;ContentHandler\u0026#34;,\u0026#34;version is + \u0026#34;+version.toString().trim()); //最后将StringBuilder清空 id.setLength(0); name.setLength(0); version.setLength(0); } } @Override public void endDocument() throws SAXException { super.endDocument(); } }language-java复制代码 可以看到，我们首先给id、name和version节点分别定义了一个StringBuilder对象，并在startDocument()方法里对它们进行了初始化。\n每当开始解析某个节点的时候，startElement()方法就会得到调用，其中localName参数记录着当前节点的名字，这里我们把它记录下来。\n接着在解析节点中具体内容的时候就会调用characters()方法，我们会根据当前的节点名进行判断，将解析出的内容添加到哪一个StringBuilder对象中。\n最后在endElement()方法中进行判断，如果app节点已经解析完成，就打印出id、name和version的内容。\n需要注意的是，目前id、name和version中都可能是包括回车或换行符的，因此在打印之前我们还需要调用一下trim()方法，并且打印完成后还要将StringBuilder的内容清空掉，不然的话会影响下一次内容的读取。\n接下来的工作就非常简单了，修改MainActivity中的代码，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 private void ParseXmlWithSAX(String xmldata){ try { SAXParserFactory saxParserFactory=SAXParserFactory.newInstance(); XMLReader xmlReader=saxParserFactory.newSAXParser().getXMLReader(); ContentHandler handler=new ContentHandler(); //将ContentHandler的实例设置到xmlReader中 xmlReader.setContentHandler(handler); //开始解析 xmlReader.parse(new InputSource(new StringReader(xmldata))); }catch (Exception e){ e.printStackTrace(); } } private void sendRequestWithOkHttp(){ new Thread(new Runnable() { @Override public void run() { try { OkHttpClient okHttpClient=new OkHttpClient(); Request request=new Request.Builder() .url(\u0026#34;http://10.0.2.2/get_data.xml\u0026#34;) .build(); Response response=okHttpClient.newCall(request).execute(); String responseData=response.body().string(); ParseXmlWithSAX(responseData); }catch (Exception e){ e.printStackTrace(); } } }).start(); } 在得到了服务器返回的数据后，我们这次去调用parseXMLWithSAX()方法来解析XML数据。parseXMLWithSAX()方法中先是创建了一个SAXParserFactory的对象，然后再获取到XMLReader对象，接着将我们编写的ContentHandler的实例设置到XMLReader中，最后调用parse()方法开始执行解析就好了。\n9.4 解析JSON格式数据 比起XML, JSON的主要优点在于它的体积更小，在网络上传输的时候可以更省流量,\n但缺点在于，它的语义性较差，看起来不如XML直观。\n新建get_data.json并推送至http服务根目录\n1 2 3 [{\u0026#34;id\u0026#34;:\u0026#34;5\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;5.5\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;Clash of Clans\u0026#34;}, {\u0026#34;id\u0026#34;:\u0026#34;6\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;7.0\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;Boom Beach\u0026#34;}, {\u0026#34;id\u0026#34;:\u0026#34;7\u0026#34;,\u0026#34;version\u0026#34;:\u0026#34;3.5\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;Clash Royale\u0026#34;}] 9.4.1 使用JSONObject 类似地，解析JSON数据也有很多种方法，可以使用官方提供的JSONObject，也可以使用谷歌的开源库GSON。另外，一些第三方的开源库如Jackson、FastJSON等也非常不错。本节中我们就来学习一下前两种解析方式的用法。修改MainActivity中的代码，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 private void parseJSONWithJSONObject(String jsonData){ try { JSONArray jsonArray=new JSONArray(jsonData); for (int i = 0; i \u0026lt; jsonArray.length(); i++) { JSONObject jsonObject=jsonArray.getJSONObject(i); String id =jsonObject.getString(\u0026#34;id\u0026#34;); String name =jsonObject.getString(\u0026#34;name\u0026#34;); String version=jsonObject.getString(\u0026#34;version\u0026#34;); Log.d(\u0026#34;MainActivity\u0026#34; ,\u0026#34;id is \u0026#34;+id); Log.d(\u0026#34;MainActivity\u0026#34; ,\u0026#34;name is \u0026#34;+name); Log.d(\u0026#34;MainActivity\u0026#34; ,\u0026#34;version is \u0026#34;+version); } }catch (Exception e){ e.printStackTrace(); } } private void sendRequestWithOkHttp(){ new Thread(new Runnable() { @Override public void run() { try { OkHttpClient okHttpClient=new OkHttpClient(); Request request=new Request.Builder() .url(\u0026#34;http://192.168.88.132/get_data.json\u0026#34;) .build(); Response response=okHttpClient.newCall(request).execute(); String responseData=response.body().string(); parseJSONWithJSONObject(responseData); }catch (Exception e){ e.printStackTrace(); } } }).start(); } 9.4.2 使用GSON 谷歌提供的GSON开源库可以让解析JSON数据的工作变得非常简单,想要使用这个功能必须要在项目中添加GSON库的依赖。编辑app/build.gradle文件，在dependencies闭包中添加如下内容：\n1 implementation \u0026#39;com.google.code.gson:gson:2.9.0\u0026#39; GSON库可以将一段JSON格式的字符串自动映射成一个对象，从而不需要我们再手动去编写代码进行解析了。比如说一段JSON格式的数据如下所示：\n1 {\u0026#34;name\u0026#34;:\u0026#34;Tom\u0026#34;,\u0026#34;age\u0026#34;:20} 我们定义一个Person类，并加入name和age这两个字段，然后只需简单地调用如下代码就可以将JSON数据自动解析成一个Person对象了：\n1 2 Gson gson = new Gson(); Person person = gson.fromJson(jsonData,Person.class); 如果需要解析的是一段JSON数组会稍微麻烦一点，我们需要借助TypeToken将期望解析成的数据类型传入到fromJson()方法中，如下所示：\n1 List\u0026lt;Person\u0026gt; appList = gson.fromJson(gsonData,new TypeToken\u0026lt;List\u0026lt;Person\u0026gt;\u0026gt;(){}.getType()); 基本的用法就是这样，下面就让我们来真正地尝试一下吧。首先新增一个App类，并加入id、name和version这3个字段，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package com.example.chapter9_web; public class App { private String id; private String name; private String version; public String getId() { return id; } public String getName() { return name; } public String getVersion() { return version; } public void setId(String id) { this.id = id; } public void setName(String name) { this.name = name; } public void setVersion(String version) { this.version = version; } } 然后修改MainActivity中的代码，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 private void parseJSONWithGSON(String jsonData){ Gson gson=new Gson(); List\u0026lt;App\u0026gt; appList =gson.fromJson(jsonData,new TypeToken\u0026lt;List\u0026lt;App\u0026gt;\u0026gt;(){}.getType()); for (App app:appList ) { Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;GSON id is \u0026#34;+app.getId()); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;GSON name is \u0026#34;+app.getName()); Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;GSON version is \u0026#34;+app.getVersion()); } } private void sendRequestWithOkHttp(){ new Thread(new Runnable() { @Override public void run() { try { OkHttpClient okHttpClient=new OkHttpClient(); Request request=new Request.Builder() .url(\u0026#34;http://10.0.2.2/get_data.json\u0026#34;) .build(); Response response=okHttpClient.newCall(request).execute(); String responseData=response.body().string(); parseJSONWithGSON(responseData); }catch (Exception e){ e.printStackTrace(); } } }).start(); } 9.5 网络编程最佳实践 之前我们的写法其实是很有问题的。因为一个应用程序很可能会在许多地方都使用到网络功能，而发送HTTP请求的代码基本都是相同的，如果我们每次都去编写一遍发送HTTP请求的代码，这显然是非常差劲的做法。\n通常情况下我们应该将这些通用的网络操作提取到一个公共的类里，并提供一个静态方法，当想要发起网络请求的时候，只需简单地调用一下这个方法即可。比如使用如下的写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package com.example.chapter9_web; import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; public class HttpUtils { public static String sendHttpRequest(String address) { HttpURLConnection httpURLConnection = null; try { URL url =new URL(address); httpURLConnection=(HttpURLConnection) url.openConnection(); httpURLConnection.setConnectTimeout(8000); httpURLConnection.setRequestMethod(\u0026#34;GET\u0026#34;); httpURLConnection.setReadTimeout(8000); httpURLConnection.setDoInput(true); httpURLConnection.setDoOutput(true); InputStream in=httpURLConnection.getInputStream(); BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(in)); StringBuilder response=new StringBuilder(); String line; while ((line = bufferedReader.readLine())!=null){ response.append(line); } return response.toString(); }catch (Exception e){ e.printStackTrace(); return e.getMessage(); }finally { if (httpURLConnection!=null){ httpURLConnection.disconnect(); } } } } 每当发起一条http请求时可以直接调用\n1 2 String address = \u0026#34;http://www.baidu.com\u0026#34; String response = HttpUtil.sendHttpRequest(address); 需要注意，网络请求通常属于耗时操作，而sendHttpRequest()方法的内部并没有开启线程，这样就有可能导致在调用sendHttpRequest()方法的时候使得主线程被阻塞住(收到请求后再继续执行剩余代码),可以在sendHttpRequest()方法内部开启一个线程解决这个问题吗？\n答案是不行,如果我们在sendHttpRequest()方法中开启了一个线程来发起HTTP请求，那么服务器响应的数据是无法进行返回的，所有的耗时逻辑都是在子线程里进行的，sendHttpRequest()方法会在服务器还没来得及响应的时候就执行结束了，当然也就无法返回响应的数据了。\n那么遇到这种情况时应该怎么办呢？其实解决方法并不难，只需要使用Java的回调机制就可以了，下面就让我们来学习一下回调机制到底是如何使用的。首先需要定义一个接口，比如将它命名成HttpCallbackListener，代码如下所示\n1 2 3 4 5 6 package com.example.chapter9_web; public interface HttpCallbackListener { void onFinish(String response);//当服务器成功响应时调用 void onError(Exception e);//出现网络错误时调用 } 可以看到，我们在接口中定义了两个方法，onFinish()方法表示当服务器成功响应我们请求的时候调用，onError()表示当进行网络操作出现错误的时候调用。这两个方法都带有参数，onFinish()方法中的参数代表着服务器返回的数据，而onError()方法中的参数记录着错误的详细信息。接着修改HttpUtil中的代码，如下所示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.example.chapter9_web; import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; public class HttpUtils { public static void sendHttpRequest(final String address,final HttpCallbackListener listener) { new Thread(new Runnable() { @Override public void run() { HttpURLConnection httpURLConnection = null; try { URL url =new URL(address); httpURLConnection=(HttpURLConnection) url.openConnection(); httpURLConnection.setConnectTimeout(8000); httpURLConnection.setRequestMethod(\u0026#34;GET\u0026#34;); httpURLConnection.setReadTimeout(8000); httpURLConnection.setDoInput(true); httpURLConnection.setDoOutput(true); InputStream in=httpURLConnection.getInputStream(); BufferedReader bufferedReader=new BufferedReader(new InputStreamReader(in)); StringBuilder response=new StringBuilder(); String line; while ((line = bufferedReader.readLine())!=null){ response.append(line); } if (listener!=null){ listener.onFinish(response.toString()); } }catch (Exception e){ if (listener!=null){ listener.onError(e); } }finally { if (httpURLConnection!=null){ httpURLConnection.disconnect(); } } } }).start(); }} 首先给sendHttpRequest()方法添加了一个HttpCallbackListener参数，并在方法的内部开启了一个子线程，然后在子线程里去执行具体的网络操作。\n注意: 子线程中无法通过return语句返回数据，因此这里我们将服务器响应的数据传入了HttpCallbackListener的onFinish()方法中，如果出现了异常就将异常原因传入到onError()方法中。\n现在sendHttpRequest()方法接收两个参数了，因此我们在调用它的时候还需要将HttpCallbackListener的实例传入，如下所示\n1 2 3 4 5 6 7 8 9 10 HttpUtils.sendHttpRequest(address,new HttpCallbackListener(){ @Override public void onFinish(String response) { //在这里根据返回内容执行具体的逻辑 } @Override public void onError(Exception e) { //在这里对异常情况进行处理 } }); 这样的话，当服务器成功响应的时候，我们就可以在onFinish()方法里对响应数据进行处理了。类似地，如果出现了异常，就可以在onError()方法里对异常情况进行处理。如此一来，我们就巧妙地利用回调机制将响应数据成功返回给调用方了。\n不过你会发现，上述使用HttpURLConnection的写法总体来说还是比较复杂的，那么使用OkHttp会变得简单吗？答案是肯定的，而且要简单得多，下面我们来具体看一下。在HttpUtil中加入一个sendOkHttpRequest()方法，如下所示：\n1 2 3 4 5 6 7 public static void sendOkHttpRequest(String addrss,okhttp3.Callback callback){ OkHttpClient client=new OkHttpClient(); Request request=new Request.Builder() .url(addrss) .build(); client.newCall(request).enqueue(callback); } 可以看到，sendOkHttpRequest()方法中有一个okhttp3.Callback参数，这个是OkHttp库中自带的一个回调接口，类似于我们刚才自己编写的HttpCallbackListener。\n在client.newCall()之后没有像之前那样一直调用execute()方法，而是调用了一个enqueue()方法，并把okhttp3.Callback参数传入。OkHttp在enqueue()方法的内部已经帮我们开好子线程了，然后会在子线程中去执行HTTP请求，并将最终的请求结果回调到okhttp3.Callback当中。那么我们在调用sendOkHttpRequest()方法的时候就可以这样写：\n1 2 3 4 5 6 7 8 9 10 11 HttpUtil.sendOkHttpRequest(\u0026#34;http://www.baidu.com\u0026#34;,new okhttp3.Callback(){ @Override public void onResponse(Call call,Response response) throws IOException { //得到服务器返回的具体内容 String responseData = response.body().string(); } @Override public void onFailure(Call call,IOException e) { //在这里对异常情况进行处理 } }); 由此可以看出，OkHttp的接口设计得确实非常人性化，它将一些常用的功能进行了很好的封装，使得我们只需编写少量的代码就能完成较为复杂的网络操作。当然这并不是OkHttp的全部，后面我们还会继续学习它的其他相关知识。\n另外需要注意的是，不管是使用HttpURLConnection还是OkHttp，最终的回调接口都还是在子线程中运行的，因此我们不可以在这里执行任何的UI操作，除非借助runOnUiThread()方法来进行线程转换。至于具体的原因，我们很快就会在下一章中学习到了。\n第10章 探究服务 10.1 服务是什么 服务(Service)是 Android 中实现程序后台运行的解决方案，它非常适合去执行那些不需要 和用户交互而且还要求长期运行的任务。服务的运行不依赖于任何用户界面，即使程序被切换到 后台，或者用户打开了另外一个应用程序，服务仍然能够保持正常运行。\n不过需要注意的是，服务并不是运行在一个独立的进程当中的，而是依赖于创建服务时所在 的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的服务也会停止运行。\n另外，也不要被服务的后台概念所迷惑，实际上服务并不会自动开启线程，所有的代码都是 默认运行在主线程当中的。也就是说，我们需要在服务的内部手动创建子线程，并在这里执行具 体的任务，否则就有可能出现主线程被阻塞住的情况。那么本章的第一堂课，我们就先来学习一 下关于 Android 多线程编程的知识。\n10.2 Android多线程编程 10.2.1 线程的基本用法 Android多线程和Java多线程编程类似\n继承Thread类并重写run()方法\n1 2 3 4 5 6 class MyThread extends Thread{ @Override public void run(){ //线程逻辑 } } 使用只需new出实例并调用start()方法运行\n1 2 MyThread myThread=new MyThread(); myThread.start(); 实现Runnable接口定义线程\n继承Thread类的方式耦合性较高,所以更多情况下使用Runnable实现\n1 2 3 4 5 6 class MyThread implements Runnable{ @Override public void run(){ //具体逻辑 } } 启动线程\n1 2 MyThread myThread=new MyThread(); new Thread(myThread).start(); Runnable+匿名类\n无需专门定义类\n1 2 3 4 5 6 new Thread(new Runnable(){ @Override public void run(){ //具体逻辑 } }).start(); 10.2.2 在子线程中更新UI 和许多其他GUI库类似,Android的UI也是线程不安全的,想要更新UI元素则必须在主线程进行,否则会出现异常.\n但在某些情况下,我们必须在子线程执行耗时任务,再根据任务结果更新相应UI组件,对于这种情况,Android提供了一套异步消息处理机制用于解决问题\n创建项目Chapter10_Service\n布局如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;RelativeLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/change_text\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Change Text\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/text\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerInParent=\u0026#34;true\u0026#34; android:textSize=\u0026#34;20sp\u0026#34;/\u0026gt; \u0026lt;/RelativeLayout\u0026gt; MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package com.example.chapter10_service; import android.os.Bundle; import android.os.Handler; import android.os.Message; import android.view.View; import android.widget.Button; import android.widget.TextView; import androidx.appcompat.app.AppCompatActivity; public class MainActivity extends AppCompatActivity implements View.OnClickListener { public static final int UPDATE_TEXT=1;//用于表示更新动作 private TextView text; private Handler handler=new Handler(){ @Override public void handleMessage(Message msg){ switch (msg.what){ case UPDATE_TEXT: //接收到消息后执行UI更新逻辑 text.setText(\u0026#34;Nice to meet you!\u0026#34;); break; default: break; } } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); text=findViewById(R.id.text); Button changeText=findViewById(R.id.change_text); changeText.setOnClickListener(this); } @Override public void onClick(View v){ new Thread(new Runnable() { @Override public void run() { Message message=new Message(); message.what=UPDATE_TEXT; handler.sendMessage(message);//发送更新UI的message对象 } }).start(); } } 代码解析:\n定义整型常量UPDATE_TEXT表示更新TextView动作.新增Handler对象并重写父类handleMessage()方法,对message进行处理,执行UI更新逻辑 ChangeText按钮用于发送UI更新的message(android.os.Message) handler在主线程中运行 运行效果如下,点击按钮后成功更新text内容\n10.2.3 解析异步消息处理机制 Android的异步消息处理主要由4部分组成: Message,Handler,MessageQueue,Looper\nMessage\n是在线程间传递的消息,可在内部携带少量信息,用于不同线程交换数据\n除上小节使用的what字段外,还可使用arg1,arg2携带一些整形数据,obj字段携带Object对象\nHandler\n用于发送和处理消息\n发送消息使用Handler.sendMessage(), 经过一系列处理最终消息会传递到Handler.handleMessage()方法中\nMessageQueue\n消息队列用于存放所有通过Handler发送的消息,这部分消息一直存在于消息队列等待处理.每个线程只会有一个MessageQueue对象\nLooper\n是每个线程中的MessageQueue的管家,调用Looper.loop()后进入无限循环,每当发现MessageQueue存在消息便会取出并传递到Handler.handlerMessage()中\n每个线程只有一个Looper对象\n异步消息处理流程:\n主线程中创建Handler对象,重写handleMessage()方法 子线程需要进行UI操作时创建Message对象并通过Handler发送 消息被添加到主线程MessageQueue中,由Looper取出消息并分发到Handler.handleMessage() 执行handleMessage处理逻辑 一条消息经过流转后从子线程进入主线程,从而更新UI\n示意图如下\n在之前使用的runOnUiThread()方法实际为一个异步消息处理机制的接口封装,背后原理正是如此\n10.2.4 使用AsyncTask 为了更方便的在子线程中对UI进行操作,Android提供了其它工具如AsyncTask\nAsyncTask的原理基于异步消息处理机制,只是做了较好的封装\n基本用法:\nAsyncTask是一个抽象类,必须创建子类继承,继承时可指定3个泛型参数\nParams\n执行AsyncTask时需要传入的参数,可于后台任务中使用\nProgress\n后台任务执行时,如果需要显示当前进度,则使用此处指定的泛型为进度单位\nResult\n任务执行完毕后,如果需要返回结果,则使用此处指定的泛型作为返回类型\n因此,一个最简单的自定义AsyncTask写法如下\n参数1指定为Void表示不需要传入参数\n参数2指定为Integer表示进度单位为整型\n参数3指定为Boolean表示使用布尔型返回结果\n1 2 3 class DownloadTask extends AsyncTask\u0026lt;Void,Integer,Boolean\u0026gt;{ ... } 目前的自定义任务为空任务,不能执行任何实际操作,还需要重写以下方法:\nonPreExecute()\n在后台任务执行前调用,用于界面初始化,如显示进度条对话框等\ndoInBackground(Params\u0026hellip;)\n该方法的所有代码都会在子线程运行,应该在这里处理所有耗时任务\n任务完成可以通过return返回执行结果,如果AsyncTask参数3指定Void则不需要返回结果\n注意: 该方法中不可以进行UI操作,若需要更新UI元素例如反馈当前任务进度,可以调用publishProgress(Progress\u0026hellip;)完成\nonProgressUpdate(Progress\u0026hellip;)\n该方法的参数类型和AsyncTask的参数2类型一致\n当后台任务调用了publishProgress(Progress\u0026hellip;)后,onProgressUpdate(Progress\u0026hellip;)会很快被调用\n该方法携带的参数是后台任务中传递来的,该方法中可以进行UI操作,利用参数值更新界面元素\nonPostExecute(Result)\n后台任务执行完毕并通过return返回时,调用该方法.\n返回数据作为参数传递到该方法,可利用返回数据进行UI操作\n例如提醒任务执行结果,关闭进度条对话框等\n综上,一个比较完整的自定义AsyncTask代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.example.chapter10_service; import android.app.ProgressDialog; import android.os.AsyncTask; import android.widget.Toast; public class DownloadTask extends AsyncTask\u0026lt;Void,Integer,Boolean\u0026gt; { ProgressDialog progressDialog; @Override protected void onPreExecute() { progressDialog.show();//显示进度对话框 } @Override protected Boolean doInBackground(Void... voids) { try{ while(true){ int downloadPercent=doDownload();//虚构方法 publishProgress(downloadPercent); if(downloadPercent\u0026gt;=100){ break; } } }catch (Exception e){ return false; } return true; } @Override protected void onProgressUpdate(Integer... values) { //更新下载进度 progressDialog.setMessage(\u0026#34;Download\u0026#34;+values[0]+\u0026#34;%\u0026#34;); } @Override protected void onPostExecute(Boolean result) { progressDialog.dismiss();//关闭进度对话框 //提示下载结果 if(result){ Toast.makeText(progressDialog.getContext(),\u0026#34;Download Succeeded\u0026#34; ,Toast.LENGTH_LONG).show(); } else { Toast.makeText(progressDialog.getContext(),\u0026#34;Download Failed\u0026#34; ,Toast.LENGTH_LONG).show(); } } } 在这个 DownloadTask中，我们在 doInBackground()方法里去执行具体的下载任务。这个方法里的代码都是在子线程中运行的，因而不会影响到主线程的运行。\n注意这里虚构了一个doDownload()方法，这个方法用于计算当前的下载进度并返回,我们假设这个方法已经存在了在得到了当前的下载进度后，下面就该考虑如何把它显示到界面上了\n由于doInBackground()方法是在子线程中运行的,在这里肯定不能进行UI操作,所以我们可以调用publishProgress()方法并将当前的下载进度传进来，这样onProgressupdate()方法就会很快被调用，在这里就可以进行UI操作了\n当下载完成后，doInBackground()方法会返回一个布尔型变量，这样onPostExecute()方法就会很快被调用，这个方法也是在主线程中运行的。然后在这里我们会根据下载的结果来弹出相应的 Toast提示，从而完成整个 DownloadTask任务。\n简单来说,使用 AsyncTask的诀窍就是,在 doInBackground()方法中执行具体的耗时任务在onProgressupdate()方法中进行U操作,在onPostExecute()方法中执行一些任务的收尾工作。\n如果想要启动这个任务，只需编写以下代码即可\n1 new DownloadTask().execute(); 以上就是 AsyncTask的基本用法，怎么样，是不是感觉简单方便了许多?我们并不需要去考虑异步消息处理机制，也不需要专门使用一个 Handler来发送和接收消息，只需要调用一下publishProgress()方法，就可以轻松地从子线程切换到线程。\n注意: AsyncTask在Android11+ (API30)被废弃,参考AsyncTask\n10.3 服务的基本用法 10.3.1 定义一个服务 右键项目包\u0026gt;New\u0026gt;Service\u0026gt;Service新建服务\nexported表示是否允许当前程序外的其他程序访问该服务\nenabled表示是否启用该服务\n观察service代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.example.chapter10_service; import android.app.Service; import android.content.Intent; import android.os.IBinder; public class MyService extends Service { public MyService() { } @Override public IBinder onBind(Intent intent) { throw new UnsupportedOperationException(\u0026#34;Not yet implemented\u0026#34;); } } MyService继承自Service类,拥有唯一一个抽象方法onBind()\n处理事件的逻辑需要重写其他方法:\nonCreate() 服务创建时调用 onStartCommand() 每次服务启动时调用 onDestroy() 服务销毁时调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.chapter10_service; import android.app.Service; import android.content.Intent; import android.os.IBinder; public class MyService extends Service { ...... @Override public void onCreate() { super.onCreate(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { return super.onStartCommand(intent, flags, startId); } @Override public void onDestroy() { super.onDestroy(); } ...... } 通常,如果希望服务启动就立刻执行某个动作,可以将逻辑写在onStartCommand(), 服务销毁时应该在onDestroy()回收不再使用的资源\n另外,每个服务都需要在AndroidManifest中注册才可以生效(四大组件的共有特点)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;application\u0026gt; ... \u0026lt;service android:name=\u0026#34;.MyService\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/service\u0026gt; ... \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 10.3.2 启动和停止服务 启动和停止服务可以借助Intent实现\n修改activity_main.xml 添加两个按钮用于启停服务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/start_service\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Start Service\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/stop_service\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Stop Service\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 修改MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package com.example.chapter10_service; import android.content.Intent; import android.os.Bundle; import android.os.Handler; import android.os.Message; import android.view.View; import android.widget.Button; import android.widget.TextView; import androidx.appcompat.app.AppCompatActivity; public class MainActivity extends AppCompatActivity implements View.OnClickListener { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startService=findViewById(R.id.start_service); Button stopService=findViewById(R.id.stop_service); startService.setOnClickListener(this); stopService.setOnClickListener(this); } @Override public void onClick(View v){ switch (v.getId()){ case R.id.start_service: Intent startIntent=new Intent(this,MyService.class); startService(startIntent);//启动服务 break; case R.id.stop_service: Intent stopIntent=new Intent(this, MyService.class); stopService(stopIntent);//停止服务 default: break; } } } 修改MyService,添加log\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class MyService extends Service { private static final String TAG=\u0026#34;MyService\u0026#34;; @Override public void onCreate() { super.onCreate(); Log.d(TAG,\u0026#34;onCreate executed\u0026#34;); } @Override public int onStartCommand(Intent intent, int flags, int startId) { Log.d(TAG,\u0026#34;onStartCommand executed\u0026#34;); return super.onStartCommand(intent, flags, startId); } @Override public void onDestroy() { super.onDestroy(); Log.d(TAG,\u0026#34;onDestroy executed\u0026#34;); } ...... } 运行程序测试,点击start service可以发现服务确实成功创建\n可在settings\u0026gt;developer options\u0026gt;running services找到服务\nonCreate()和onStartCommand()的区别:\nonCreate()在服务第一次创建时调用,onStartCommand()在每次启动服务时调用\n注: 此处创建是指调用startService,重复点击start service会产生一条onCreate和多条onStartCommand日志,服务销毁后则需要重新创建并非从始至终只调用一次onCreate\n10.3.3 活动和服务进行通信 活动和服务的通信可以通过onBind()方法实现\n比如: 我们希望在MyService提供一个下载功能,在活动中决定何时开始下载以及随时查看下载进度,可以创建一个专门的Binder对象对下载功能进行管理\n修改MyService代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package com.example.chapter10_service; import android.app.Service; import android.content.Intent; import android.os.Binder; import android.os.IBinder; import android.util.Log; public class MyService extends Service { private static final String TAG=\u0026#34;MyService\u0026#34;; private DownloadBinder mBinder=new DownloadBinder(); class DownloadBinder extends Binder { public void startDownload(){ Log.d(TAG,\u0026#34;StartDownload executed\u0026#34;); } public int getProgress(){ Log.d(TAG,\u0026#34;GetProgress executed\u0026#34;); return 0; } } @Override public IBinder onBind(Intent intent) { return mBinder; } ...... } 此处创建了DownloadBinder类继承Binder,内部提供开始下载和查看下载进度方法,仅做模拟打印日志,创建DownloadBinder实例之后在onBinder返回该实例即可\n下面看看如何在活动中调用服务的方法\n修改activity_main,添加两个按钮用于绑定和解绑服务\n1 2 3 4 5 6 7 8 9 10 \u0026lt;Button android:id=\u0026#34;@+id/bind_service\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Bind Service\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/unbind_service\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Unbind Service\u0026#34;/\u0026gt; 当活动和服务绑定后,就可以调用服务里的Binder提供的方法\n修改MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package com.example.chapter10_service; import android.content.ComponentName; import android.content.Intent; import android.content.ServiceConnection; import android.os.Bundle; import android.os.IBinder; import android.view.View; import android.widget.Button; import androidx.appcompat.app.AppCompatActivity; public class MainActivity extends AppCompatActivity implements View.OnClickListener { private MyService.DownloadBinder downloadBinder; private ServiceConnection connection=new ServiceConnection() { @Override public void onServiceConnected(ComponentName componentName, IBinder service) { downloadBinder=(MyService.DownloadBinder)service; downloadBinder.startDownload(); downloadBinder.getProgress(); } @Override public void onServiceDisconnected(ComponentName componentName) { } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startService=findViewById(R.id.start_service); Button stopService=findViewById(R.id.stop_service); Button bindService=findViewById(R.id.bind_service); Button unbindService=findViewById(R.id.unbind_service); startService.setOnClickListener(this); stopService.setOnClickListener(this); bindService.setOnClickListener(this); unbindService.setOnClickListener(this); } @Override public void onClick(View v){ switch (v.getId()){ case R.id.start_service: Intent startIntent=new Intent(this,MyService.class); startService(startIntent);//启动服务 break; case R.id.stop_service: Intent stopIntent=new Intent(this, MyService.class); stopService(stopIntent);//停止服务 break; case R.id.bind_service: Intent bindIntent=new Intent(this, MyService.class); bindService(bindIntent,connection,BIND_AUTO_CREATE);//绑定服务 break; case R.id.unbind_service: unbindService(connection);//解绑服务 break; default: break; } } } 代码解析:\nServiceConnection匿名类\n重写onServiceConnected和onServiceDisconnected方法,分别在活动绑定和解除绑定时调用.\nonServiceConnected\n向下转型获取DownloadBinder实例,调用startDownload()和getProgress()\n调用bindService()绑定\n参数3传入BIND_AUTO_CREATE表示活动和服务绑定后自动创建服务,即自动调用MyService.onCreate(),但onStartCommand()不执行\n运行效果如下,点击Bind Service后分别调用onCreate,StartDownload,GetProgress\n任何一个服务在整个程序范围内都是通用的,可以和任意活动绑定,并且绑定完成后都可以获得相同的DownloadBinder实例\n10.4 服务的生命周期 之前我们学习过了活动以及碎片的生命周期, 类似地，服务也有自己的生命周期，前面我们使用到的 onCreate()、onStartCcommand()、onBind()和onDestroy()等方法都是在服务的生命周期内可能回调的方法。\n一旦在项目的任何位置调用了Context的startService()方法,相应的服务就会启动起来并回调 onStartCommand()方法。如果这个服务之前还没有创建过，onCreate()方法会先于onStartCommand()方法执行。\n服务启动了之后会一直保持运行状态，直到stopService()或stopSelf()方法被调用。注意，虽然每调用一次 startService()方法，onStartCommand()就会执行一次,但实际上每个服务都只会存在一个实例。所以不管你调用了多少次 startService()方法，只需调用一次 stopService()或stopSelf()方法，服务就会停止下来了。\n另外，还可以调用 Context的 bindservice()来获取一个服务的持久连接，这时就会回调服务中的 onBind()方法。类似地，如果这个服务之前还没有创建过，onCreate()方法会先于onBind()方法执行。之后，调用方可以获取到onBind()方法里返回的 IBinder 对象的实例，这样就能自由地和服务进行通信了。只要调用方和服务之间的连接没有断开,服务就会一直保持 运行状态。\n当调用了 startService()方法后，又去调用stopService()方法，这时服务中的onDestroy()方法就会执行，表示服务已经销毁了。类似地，当调用了bindService()方法后又去调用 unbindservice()方法，onDestroy()方法也会执行，这两种情况都很好理解。但是 需要注意，我们是完全有可能对一个服务既调用了startService()方法，又调用了bindService()方法的，这种情况下该如何才能让服务销毁掉呢?根据 Android系统的机制，一个服务只要被启动或者被绑定了之后，就会一直处于运行状态，必须要让以上两种条件同时不满足，服务才能被销毁。所以，这种情况下要同时调用stopService()和unbindService()方法onDestroy()方法才会执行。\n10.5 服务的更多技巧 10.5.1 使用前台服务 服务几乎都是在后台运行的,但服务的系统优先级比较低,当内存不足时可能会回收掉后台正在运行的服务\n如果希望服务可以一直运行不会由于内存不足等原因导致回收,可以使用前台服务\n前台服务和普通服务的最大区别在于: 一直有一个正在运行的图标在系统状态栏,下拉状态栏可以看到详细信息,类似于通知效果\n来看看如何创建一个前台服务,修改MyService代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package com.example.chapter10_service; import android.annotation.SuppressLint; import android.app.Notification; import android.app.NotificationChannel; import android.app.NotificationManager; import android.app.PendingIntent; import android.app.Service; import android.content.Intent; import android.graphics.BitmapFactory; import android.os.Binder; import android.os.Build; import android.os.IBinder; import android.util.Log; import androidx.core.app.NotificationCompat; public class MyService extends Service { ...... @Override public void onCreate() { super.onCreate(); Log.d(TAG,\u0026#34;onCreate executed\u0026#34;); Intent intent=new Intent(this, MainActivity.class); PendingIntent pendingIntent=PendingIntent.getActivity(this,0,intent, PendingIntent.FLAG_IMMUTABLE); NotificationManager notificationManager= (NotificationManager) getSystemService(NOTIFICATION_SERVICE); //使用channel创建通知 if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { String channelId = \u0026#34;default\u0026#34;; String channelName = \u0026#34;默认通知\u0026#34;; NotificationChannel notificationChannel= new NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_HIGH); notificationManager.createNotificationChannel(notificationChannel); } Notification notification=new NotificationCompat.Builder(this,\u0026#34;default\u0026#34;) .setContentTitle(\u0026#34;This is content text\u0026#34;) .setContentText(\u0026#34;This is content text\u0026#34;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher_round)) .build(); startForeground(1,notification);//通过该方法创建前台服务 } ...... } 这里只修改了onCreate(), 创建Notification对象后通过startForeground()使得MyService变成前台服务\n另外需要修改Manifest声明权限,从上到下分别为通知权限,前台服务权限(Android9+),特定前台服务权限(Android14+)\n并使用android:foregroundServiceType属性指定前台服务的具体类型(Android14+), 参考请求前台服务权限\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.POST_NOTIFICATIONS\u0026#34; /\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.FOREGROUND_SERVICE\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK\u0026#34;/\u0026gt; \u0026lt;application\u0026gt; \u0026lt;service android:name=\u0026#34;.MyService\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34; android:foregroundServiceType=\u0026#34;mediaPlayback\u0026#34; \u0026gt; \u0026lt;/service\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 运行效果,成功启动前台服务,可在通知栏查看\n10.5.2 使用IntentService 服务中的代码默认运行在主线程中,如果在服务中处理耗时逻辑容易出现ANR(Application Not Responding)\n所以这个时候需要使用Android的多线程编程,我们应该在每个服务的具体方法中开启线程处理耗时逻辑,因此一个标准服务可以写成如下形式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MyService extends Service{ ... @Override public int onStartCommand(Intent intent, int flags, int startId) { new Thread(new Runnable() { @Override public void run() { //处理具体逻辑 stopSelf();//执行完毕自动停止服务 } }).start(); return super.onStartCommand(intent, flags, startId); } } 虽然这种写法并不复杂,但总有程序员忘记开启线程或者忘记调用stopSelf()\n为了更简单的创建一个异步,自动停止的服务,Android提供了IntentService类解决这两个问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package com.example.chapter10_service; import android.app.IntentService; import android.content.Intent; import android.util.Log; import androidx.annotation.Nullable; public class MyIntentService extends IntentService { public MyIntentService(){ super(\u0026#34;MyIntentService\u0026#34;);//调用父类构造函数 } //实现该抽象方法,处理耗时逻辑,该方法在子线程中运行 @Override protected void onHandleIntent(@Nullable Intent intent) { //打印当前线程id Log.d(\u0026#34;MyIntentService\u0026#34;,\u0026#34;Thread id is\u0026#34;+Thread.currentThread().getId()); } @Override public void onDestroy() { super.onDestroy(); Log.d(\u0026#34;MyIntentService\u0026#34;, \u0026#34;onDestroy executed\u0026#34;); } } 其中onHandleIntent()抽象方法在子线程中运行,为印证在此处打印线程id\n接下来修改activity_main,添加按钮用于启动MyIntentService\n1 2 3 4 5 \u0026lt;Button android:id=\u0026#34;@+id/start_intent_service\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Start IntentService\u0026#34;/\u0026gt; 修改MainActivity,打印主线程id\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Override protected void onCreate(Bundle savedInstanceState){ ... Button startIntentService=findViewById(R.id.start_intent_service); startIntentService.setOnClickListener(this); } @Override public void onClick(View v){ switch (v.getId()){ ...... case R.id.start_intent_service: //打印主线程id Log.d(\u0026#34;MainActivity\u0026#34;,\u0026#34;Thread id is\u0026#34;+Thread.currentThread().getId()); Intent intentService=new Intent(this, MyIntentService.class); startService(intentService); default: break; } } 最后,到Manifest文件注册服务\n1 2 3 4 \u0026lt;service android:name=\u0026#34;.MyIntentService\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34; /\u0026gt; 运行效果如下,显然MyIntentService.onHandleIntent()运行在子线程,并且自动执行onDestroy(),说明执行完毕自动停止服务\n10.6 服务的最佳实践-完整版的下载示例 添加项目所需依赖 okhttp3\n1 implementation(\u0026#34;com.squareup.okhttp3:okhttp:4.12.0\u0026#34;) 定义回调接口用于对下载过程中的各种状态进行监听和回调\n新建DownloadListener接口\n1 2 3 4 5 6 7 public interface DownloadListener { void onProgress(int progress);//通知当前下载进度 void onSuccess();\t//通知下载成功事件 void onFailed();\t//通知下载失败事件 void onPaused();\t//通知下载暂停事件 void onCanceled();\t//通知下载取消事件 } 新建DownloadTask继承自AsyncTask\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 package com.example.chapter10_service; import android.os.AsyncTask; import android.os.Environment; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.io.RandomAccessFile; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.Response; //AsyncTask //参数1 执行AysncTask时传入1个字符串参数给后台任务 //参数2 使用int作为进度显示单位 //参数3 使用int反馈执行结果 public class DownloadTask extends AsyncTask\u0026lt;String,Integer,Integer\u0026gt; { //定义常量用于表示下载状态 public static final int TYPE_SUCCESS=0; public static final int TYPE_FAILED=1; public static final int TYPE_PAUSED=2; public static final int TYPE_CANCELED=3; private DownloadListener listener; private boolean isCanceled=false; private boolean isPaused=false; private int lastProgress; //传入listener实例,用于回调处理下载状态 public DownloadTask(DownloadListener listener){ this.listener=listener; } //暂停下载 public void pauseDownload(){ isPaused=true; } //取消下载 public void cancelDownload(){ isCanceled=true; } //后台任务执行前调用,用于界面初始化,显示进度条对话框等 @Override protected void onPreExecute() { super.onPreExecute(); } //更新下载进度 @Override protected void onProgressUpdate(Integer... values){ int progress=values[0];//当前下载进度 if(progress\u0026gt;lastProgress) { listener.onProgress(progress); lastProgress = progress; } } //通知下载结果 @Override protected void onPostExecute(Integer status){ switch(status){ case TYPE_SUCCESS: listener.onSuccess(); break; case TYPE_FAILED: listener.onFailed(); break; case TYPE_PAUSED: listener.onPaused(); break; case TYPE_CANCELED: listener.onCanceled(); break; default: break; } } //获取目标资源文件大小 private long getContentLength(String downloadUrl) throws IOException{ OkHttpClient client=new OkHttpClient(); Request request=new Request.Builder() .url(downloadUrl).build(); Response response=client.newCall(request).execute(); if(response!=null\u0026amp;\u0026amp;response.isSuccessful()){ long contentLength=response.body().contentLength(); response.close(); return contentLength; } return 0; } //后台执行具体的下载逻辑 (子线程运行,处理耗时逻辑) @Override protected Integer doInBackground(String... params) { InputStream inputStream=null; RandomAccessFile savedFile=null; File file=null; try{ long downloadedLength=0;//记录下载文件长度 String downloadUrl=params[0];//下载的url地址 String fileName=downloadUrl.substring(downloadUrl.lastIndexOf(\u0026#34;/\u0026#34;));//下载文件名 //指定下载到sd卡的download目录 String directory= Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); file=new File(directory+fileName);//创建file对象 if(file.exists()){ //如果存在下载文件则读取已下载字节数,用于后续断点续传 downloadedLength=file.length(); } long contentLength=getContentLength(downloadUrl);//获取下载文件总长度 if(contentLength==0){ return TYPE_FAILED;//长度为零说明文件有问题 } else if(contentLength==downloadedLength){ return TYPE_SUCCESS;//文件已经下载完毕,无需重复下载 } OkHttpClient client=new OkHttpClient(); Request request=new Request.Builder() //断点下载,指定从哪个字节开始下载 .addHeader(\u0026#34;RANGE\u0026#34;,\u0026#34;bytes=\u0026#34;+downloadedLength+\u0026#34;-\u0026#34;)//header用于指定从哪个字节开始下载 .url(downloadUrl) .build(); Response response=client.newCall(request).execute(); if(response!=null){ inputStream=response.body().byteStream(); savedFile=new RandomAccessFile(file,\u0026#34;rw\u0026#34;); savedFile.seek(downloadedLength);//跳过已下载字节 byte[] bytes=new byte[1024]; int total=0; int len; while((len=inputStream.read(bytes))!=-1){ //循环读取文件字节,直到下载完毕或者用户点击暂停/取消 if(isCanceled){ return TYPE_CANCELED; } else if(isPaused){ return TYPE_PAUSED; } else{ total+=len; savedFile.write(bytes,0,len);//保存文件并更新下载进度 int progress=(int)((total+downloadedLength)*100/contentLength); publishProgress(progress);//通知更新进度 } } response.body().close(); return TYPE_SUCCESS; } }catch (Exception e){ e.printStackTrace(); }finally { try{ if(inputStream!=null){ inputStream.close(); } if(savedFile!=null){ savedFile.close(); } if(isCanceled\u0026amp;\u0026amp;file!=null){ file.delete(); } }catch (Exception e){ e.printStackTrace(); } } return TYPE_FAILED; } } 新建DownloadService 调用DownloadTask进行下载\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 package com.example.chapter10_service; import android.app.Notification; import android.app.NotificationChannel; import android.app.NotificationManager; import android.app.PendingIntent; import android.app.Service; import android.content.Intent; import android.graphics.BitmapFactory; import android.os.Binder; import android.os.Build; import android.os.Environment; import android.os.IBinder; import android.widget.Toast; import androidx.core.app.NotificationCompat; import java.io.File; public class DownloadService extends Service { private DownloadTask downloadTask; private String downloadUrl; //Service创建具体的listener实例,再传递给task用于回调结果 private DownloadListener listener=new DownloadListener() { //显示下载进度 @Override public void onProgress(int progress) { getNotificationManager().notify(1,getNotification(\u0026#34;Downloading...\u0026#34;,progress)); } //下载成功时关闭前台服务通知,并创建下载成功通知 @Override public void onSuccess() { downloadTask=null;//关闭任务 stopForeground(true);//关闭通知 getNotificationManager().notify(1,getNotification(\u0026#34;Download success\u0026#34;,-1)); Toast.makeText(DownloadService.this,\u0026#34;Download success\u0026#34;,Toast.LENGTH_SHORT).show(); } //下载失败时关闭前台服务通知,创建下载失败通知 @Override public void onFailed() { downloadTask=null; stopForeground(true); getNotificationManager().notify(1,getNotification(\u0026#34;Download Failed\u0026#34;,-1)); Toast.makeText(DownloadService.this,\u0026#34;Download Failed\u0026#34;,Toast.LENGTH_SHORT).show(); } @Override public void onPaused() { downloadTask=null;//关闭下载任务? Toast.makeText(DownloadService.this,\u0026#34;Download Paused\u0026#34;,Toast.LENGTH_SHORT).show(); } @Override public void onCanceled() { downloadTask=null; stopForeground(true); Toast.makeText(DownloadService.this,\u0026#34;Download Canceled\u0026#34;,Toast.LENGTH_SHORT).show(); } }; public DownloadService() { } //binder用于活动和服务通信 private DownloadBinder mBinder=new DownloadBinder(); @Override public IBinder onBind(Intent intent){ return mBinder; } class DownloadBinder extends Binder{ public void startDownload(String url){ if(downloadTask==null){ downloadUrl=url; downloadTask=new DownloadTask(listener); downloadTask.execute(downloadUrl); startForeground(1,getNotification(\u0026#34;Downloading...\u0026#34;,0)); Toast.makeText(DownloadService.this,\u0026#34;Downloading...\u0026#34;,Toast.LENGTH_SHORT).show(); } } public void pauseDownload(){ if(downloadTask!=null){ downloadTask.pauseDownload(); } } public void cancelDownload(){ if(downloadTask!=null){ downloadTask.cancelDownload(); } else{ if(downloadUrl!=null){ //取消下载时将文件删除,并关闭通知 String fileName=downloadUrl.substring(downloadUrl.lastIndexOf(\u0026#34;/\u0026#34;)); String directory= Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getPath(); File file=new File(directory+fileName); if(file.exists()){ file.delete();//删除文件 } } } } } //获取通知管理器 private NotificationManager getNotificationManager(){ return (NotificationManager) getSystemService(NOTIFICATION_SERVICE); } private Notification getNotification(String title,int progress){ Intent intent=new Intent(this, MainActivity.class); PendingIntent pendingIntent=PendingIntent.getActivity(this,0,intent, PendingIntent.FLAG_IMMUTABLE); NotificationManager notificationManager=getNotificationManager(); if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { String channelId = \u0026#34;download\u0026#34;; //通道名称 String channelName = \u0026#34;下载通知\u0026#34;; notificationManager.createNotificationChannel(new NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_HIGH)); } NotificationCompat.Builder builder=new NotificationCompat.Builder(this,\u0026#34;download\u0026#34;); builder.setSmallIcon(R.mipmap.ic_launcher); builder.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher)); builder.setContentIntent(pendingIntent); builder.setContentTitle(title); if(progress\u0026gt;0){ //progress\u0026gt;0时才需要显示进度 builder.setContentText(progress+\u0026#34;%\u0026#34;); //参数1 最大进度 //参数2 当前进度 //参数3 是否使用模糊进度条 builder.setProgress(100,progress,false); } return builder.build(); } } 修改布局\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/start_download\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Start Download\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/pause_download\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Pause Download\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/cancel_download\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Cancel Download\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 修改MainActivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 package com.example.chapter10_service; import android.content.ComponentName; import android.content.Intent; import android.content.ServiceConnection; import android.content.pm.PackageManager; import android.os.Bundle; import android.os.IBinder; import android.view.View; import android.widget.Button; import androidx.appcompat.app.AppCompatActivity; import androidx.core.app.ActivityCompat; import androidx.core.content.ContextCompat; public class MainActivity extends AppCompatActivity implements View.OnClickListener { private DownloadService.DownloadBinder downloadBinder; private ServiceConnection connection=new ServiceConnection() { @Override public void onServiceConnected(ComponentName componentName, IBinder service) { downloadBinder=(DownloadService.DownloadBinder)service; } @Override public void onServiceDisconnected(ComponentName componentName) { } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button startDownload=findViewById(R.id.start_download); Button pauseDownload=findViewById(R.id.pause_download); Button cancelDownload=findViewById(R.id.cancel_download); startDownload.setOnClickListener(this); pauseDownload.setOnClickListener(this); cancelDownload.setOnClickListener(this); Intent intent=new Intent(this,DownloadService.class); startService(intent);//启动服务 bindService(intent,connection,BIND_AUTO_CREATE);//绑定服务 //Manifest要加上android.才能正常 if(ContextCompat.checkSelfPermission(MainActivity.this,android.Manifest.permission.WRITE_EXTERNAL_STORAGE)!= PackageManager.PERMISSION_GRANTED){ ActivityCompat.requestPermissions(MainActivity.this,new String[]{android.Manifest.permission.WRITE_EXTERNAL_STORAGE},1); } } @Override public void onClick(View v){ if(downloadBinder==null){ return; } switch (v.getId()){ case R.id.start_download: String url=\u0026#34;http://xiazai-fd.zol-img.com.cn/g2/M00/0A/02/ChMlWl6dLvqIL3dzAAFdhCttZSUAAOd9QIjQ7YAAV2c133.jpg\u0026#34;; downloadBinder.startDownload(url); break; case R.id.pause_download: downloadBinder.pauseDownload(); break; case R.id.cancel_download: downloadBinder.cancelDownload(); break; default: break; } } @Override protected void onDestroy() { super.onDestroy(); unbindService(connection); } } Others Gradle 官方仓库https://services.gradle.org/distributions/\n参考文章\nAndroid Studio 配置Gradle\n史上最全Android build.gradle配置详解(小结)\ngradle-wrapper.properties中各属性的含义\nAS的项目所用的Gradle由{your project}/gradle/wrapper/gradle-wrapper.properties文件决定,其内容如下\n1 2 3 4 5 6 #Tue Jul 09 15:29:34 CST 2024 distributionBase=GRADLE_USER_HOME # distributionBase+Path=解压后的gradle.zip路径 distributionPath=wrapper/dists distributionUrl=https\\://services.gradle.org/distributions/gradle-8.7-bin.zip zipStoreBase=GRADLE_USER_HOME\t# zipStoreBase+Path=下载的gradle.zip文件存储路径 zipStorePath=wrapper/dists Gradle可供多个项目共享,默认存储路径如下:\n1 2 Linux: ~/.gradle/wrapper/dists Windows:C:\\users\\{user name}\\.gradle\\wrapper\\dists AS打开某个工程时,首先读取gradle-wrapper.properties,从而得知该工程需要哪个版本gradle,再去GRADLE_USER_HOME文件夹查看是否存在该版本的gradle,不存在则下载\nViewBinding ViewBinding可以直接绑定layout与activity,获取binding后可直接访问组件,省去通过findViewById之类的操作\n首先在gradle.build文件中打开ViewBinding功能\n1 2 3 4 5 6 7 android{ ... viewBinding{ enabled=true } ... } 假设活动为MainActivity.java,布局为activity_main.xml\n在Activity.java中创建binding成员\n该类根据布局名称自动生成,如test_layout.xml生成TestLayoutBinding,即layoutName+Binding\n1 private ActivityMainBinding binding; 在onCreate方法中进行布局绑定\n1 2 binding=ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); 获取到binding后,可以直接通过binding.访问布局中的各个组件\n","date":"2024-09-15T02:15:28+08:00","image":"https://example.com/p/androidbasicstudy/8_%E6%B4%BB%E5%8A%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_hu14714922645838520419.png","permalink":"https://example.com/p/androidbasicstudy/","title":"AndroidBasicStudy"},{"content":"一. NDK简介 1.1 为什么把代码放到so中 c历史悠久,有很多现成代码使用 c的效率比java高 c相对java更难反编译 1.2 什么是JNI Java Native Interface 从java1.1开始jni标准成为java平台的一部分,允许java和其他语言代码交互\n1.3 什么是NDK 交叉编译工具链https://developer.android.com/ndk/guides\nNDK: 原生开发套件\nCMake: 用于指导构建so\nLLDB: Android Studio 用于调试原生代码的调试程序\n1.4 ABI与指令集 不同的 Android 设备使用不同的 CPU，而不同的 CPU 支持不同的指令集。CPU 与指令集的每种组合都有专属的应用二进制接口 (ABI)\n1.5 在so中接触到的东西 jni调用\n系统库函数\n加密算法\n魔改算法\n系统调用\n自定义算法\nso的加固和混淆\nso的dump 内存中的so是解密后的\nso的修复 修复dump下来的so\nso的文件结构\n自定义linker\n二. 第一个NDK项目 2.1 NDK项目与Java项目的区别 在New \u0026gt; Project \u0026gt; Native C++创建NDK项目\nNDK开发流程\nJava层: 声明Java Native方法\nJNI层: 定义与Java Native方法对应的JNI Native方法\n静态注册JNI方法: 通过函数名称建立关联\n动态注册JNI方法: 通过注册方法将Java层方法和Native层函数关联\nC/C++层: 实现Native函数具体功能\nJava代码中存在加载so和声明使用到的so函数\njava层需要加载so文件 (对应so文件名为libnativetest.so)\n1 2 3 static { System.loadLibrary(\u0026#34;nativetest\u0026#34;); } 使用native关键字声明native函数,具体实现在native中\n1 public native String stringFromJNI(); build.gradle中添加部分代码用于支持ndk开发\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 android { ...... defaultConfig { ...... //指定cmake设置,c++标准 externalNativeBuild { cmake{ cppFlags \u0026#34;-std=c++11\u0026#34; } } // 指定编译的so文件支持的平台,默认4种 ndk{ abiFilters \u0026#39;armeabi-v7a\u0026#39;, \u0026#39;arm64-v8a\u0026#39;, \u0026#39;x86\u0026#39;, \u0026#39;x86_64\u0026#39; } } externalNativeBuild { //指定cmakelists文件路径和cmake版本 cmake { path file(\u0026#39;src/main/cpp/CMakeLists.txt\u0026#39;) version \u0026#39;3.22.1\u0026#39; } } ...... } main/cpp/目录下的CMakeLists.txt和cpp文件\nCMakeLists.txt用于指导编译\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 编译so的cmake最低版本 cmake_minimum_required(VERSION 3.22.1) # 项目名称 project(\u0026#34;nativetest\u0026#34;) # 设置so的名字,类型,源文件 add_library(${CMAKE_PROJECT_NAME} SHARED native-lib.cpp) # 链接相关依赖 target_link_libraries(${CMAKE_PROJECT_NAME} # List libraries link to the target library android log) native-lib.cpp中有具体的代码实现java层声明的函数\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;jni.h\u0026gt; #include \u0026lt;string\u0026gt; extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_nativetest_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { std::string hello = \u0026#34;Hello from C++\u0026#34;; return env-\u0026gt;NewStringUTF(hello.c_str()); } 三. NDK基础知识 3.1 静态注册 3.1.1 java代码 native关键字用于声明该函数为native层函数 static{ System.loadLibrary(\u0026ldquo;libname\u0026rdquo;); }用于加载动态库文件 native函数在加载完库文件后可以直接调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.nativetest; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.nativetest1.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { public native String stringFromJNI();//java层声明JNI方法 static { System.loadLibrary(\u0026#34;nativetest1\u0026#34;);//导入库文件 } private ActivityMainBinding binding;//注册绑定类 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState);//调用父类方法 binding = ActivityMainBinding.inflate(getLayoutInflater());//绑定布局 setContentView(binding.getRoot());//将根视图作为主视图 TextView tv = binding.sampleText;//通过binding类直接获取组件 tv.setText(stringFromJNI());//调用native方法 } } 3.1.2 cpp代码 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;jni.h\u0026gt; #include \u0026lt;string\u0026gt; //静态注册需要保证以C形式导出 且函数名=Java_PackageName_ClassName_MethodName才能正常被加载 extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL//指定以c方式编译 指定为JNI导出函数 返回值类型 调用方式 Java_com_example_nativetest_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { std::string hello = \u0026#34;Hello from C++\u0026#34;; return env-\u0026gt;NewStringUTF(hello.c_str());//将c字符串转换为java字符串返回 } extern \u0026ldquo;C\u0026quot;保证以C语言命名规则导出函数,防止c++的名称粉碎影响函数绑定\nnative函数命名规则\n函数名=Java_PackageName_ClassName_MethodName,加载库文件后会自动根据函数名进行绑定\nJNIEnv jobject/jclass\n和java层对接的native函数都有JNIEnv* env和jobject参数\njclass是java层对象, jobject是native函数对应java层方法所属的java层对象实例\n当native函数的声明改为static时使用jclass，因为静态方法可以通过类直接调用,无需创建对象实例\nNewstringUTF\njava层数据和native层数据不互通，如果native的数据最后要转到java层处理就需要NewstringUTF进行类型转换NewstringUTF可以成为一个hook点\nJNIIMPORT / JNICALL / JNIEXPORT\nJNIIMPORT和JNICALL宏未指定内容\nJNIEXPORT宏添加可见性属性为默认(可见)\n1 2 3 #define JNIIMPORT #define JNIEXPORT __attribute__ ((visibility (\u0026#34;default\u0026#34;))) #define JNICALL 3.1.3 layout代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/sample_text\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Hello World!\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 3.1.4 逆向分析结果 根据函数名直接找到JNI函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 __int64 __fastcall Java_com_example_nativetest1_MainActivity_stringFromJNI(_JNIEnv *a1) { const char *v1; // rax __int64 v3; // [rsp+18h] [rbp-48h] char v4[24]; // [rsp+40h] [rbp-20h] BYREF unsigned __int64 v5; // [rsp+58h] [rbp-8h] v5 = __readfsqword(0x28u); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(v4, \u0026#34;Hello from C++\u0026#34;); v1 = (const char *)sub_20CC0((__int64)v4); v3 = _JNIEnv::NewStringUTF(a1, v1); std::string::~string(v4); return v3; } 恢复符号后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 __int64 __fastcall Java_com_example_nativetest1_MainActivity_stringFromJNI(_JNIEnv *env) { const char *v1; // rax __int64 v3; // [rsp+18h] [rbp-48h] char str[24]; // [rsp+40h] [rbp-20h] BYREF unsigned __int64 v5; // [rsp+58h] [rbp-8h] v5 = __readfsqword(0x28u); std::string::basic_string\u0026lt;decltype(nullptr)\u0026gt;(str, \u0026#34;Hello from C++\u0026#34;); v1 = (const char *)strTocstr((__int64)str); v3 = _JNIEnv::NewStringUTF(env, v1); std::string::~string(str); return v3; } 3.2 动态注册 动态注册的函数名称无需遵守静态注册的函数名称规则\n并且不要求函数是导出类型,安全性高于静态注册\n3.2.1 java代码 xml布局代码同上,java代码额外声明add和sub函数用于测试动态注册\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package com.example.nativetest; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.widget.TextView; import com.example.nativetest1.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { public native String stringFromJNI(); public native int add(int x,int y); public native int sub(int x,int y); static { System.loadLibrary(\u0026#34;nativetest\u0026#34;); } private ActivityMainBinding binding;//注册绑定类 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); binding = ActivityMainBinding.inflate(getLayoutInflater());//绑定布局 setContentView(binding.getRoot());//将根视图作为主视图 TextView tv = binding.sampleText;//通过binding类直接获取组件 Log.d(\u0026#34;add\u0026#34;,\u0026#34;\u0026#34;+add(51,5)); tv.setText(stringFromJNI()+add(7,8)); } } 3.2.2 动态注册相关知识 RegisterNatives 该函数用于注册native函数,用于将java层方法和native层函数绑定,声明如下\n1 2 3 4 //clazz：指定的类,即 native 方法所属的类 //methods：方法数组 //nMethods：方法数组的长度,即有多少个动态注册的导出函数 jint RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods) JNINativeMethod 该结构体用于保存java层函数和native层函数映射关系\n1 2 3 4 5 typedef struct { const char* name;\t// java层的方法名 const char* signature; // 方法签名,与函数参数类型和返回值类型有关,例如 ()Ljava/lang/String; void* fnPtr; // native层的函数指针 } JNINativeMethod; 方法签名signature 方法签名用于描述方法的参数和返回值类型,基本格式如下\n1 \u0026#34;(参数类型)返回值类型\u0026#34; 例如有以下函数,他们的方法签名对应关系如下\n1 2 3 void func();//\u0026#34;()V\u0026#34; jint add(jint x,jint y);//\u0026#34;(II)I\u0026#34; jstring stringFromJNI();//\u0026#34;()Ljava/lang/String;\u0026#34; 注意String后要跟; 签名规则\n基本类型参照类型和签名字符映射表\n引用类型以\u0026quot;L\u0026quot;开头，以\u0026rdquo;;\u0026ldquo;结尾，中间用\u0026rdquo;/\u0026ldquo;隔开包及类名,其对应的C函数的参数类型为jobject()\n例如：Ljava/lang/String; 、Ljava/net/Socket; 等\n注意: String类对应C类型为jstring而非jobject\n如果java函数位于一个内部类，则用$作为类名间的分隔符\n例如：\u0026ldquo;Landroid/os/FileUtils$FileStatus;\u0026rdquo;\nJNI数据类型 Java类型 Native类型 签名字符 描述 基本类型 void void V boolean jboolean Z C/C++8位整型 byte jbyte B C/C++带符号的8位整型 char jchar C C/C++无符号的16位整型 short jshort S C/C++带符号的16位整型 int jint I C/C++带符号的32位整型 long jlong J C/C++带符号的64位整型 float jfloat F C/C++32位浮点型 double jdouble D C/C++64位浮点型 Object jobject Ljava/lang/Object; 任何Java对象，或者没有对应java类型的对象 Class jclass Ljava/lang/Class; Class对象 String jstring Ljava/lang/String; 字符串对象 数组类型 Object[] jobjectArray 任何对象的数组 boolean[] jbooleanArray [Z 布尔型数组 byte[] jbyteArray [B 比特型数组 char[] jcharArray [C 字符型数组 short[] jshortArray [S 短整型数组 int[] jintArray [I 整型数组 long[] jlongArray [J 长整型数组 float[] jfloatArray [F 浮点型数组 double[] jdoubleArray [D 双浮点型数组 3.2.3 cpp代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;jni.h\u0026gt; #include \u0026lt;string\u0026gt; //native函数对应的java方法所属类 static const char *ClassName=\u0026#34;com/example/nativetest1/MainActivity\u0026#34;; jint add(JNIEnv* env,jobject obj,jint x,jint y){ return x+y; } jint sub(JNIEnv* env,jobject obj,jint x,jint y){ return x-y; } //定义本地方法数组 建立映射关系 //JNINativeMethod结构体成员为函数名,函数签名,函数指针 static JNINativeMethod methods[]={ {\u0026#34;add\u0026#34;,\u0026#34;(II)I\u0026#34;,(void*)add}, {\u0026#34;sub\u0026#34;,\u0026#34;(II)I\u0026#34;,(void*)sub} }; //编写加载注册方法 jint JNI_OnLoad(JavaVM* vm,void* reserved){ JNIEnv* env=NULL;//获取JNIEnv对象 if(vm-\u0026gt;GetEnv((void**)\u0026amp;env,JNI_VERSION_1_6)!=JNI_OK) return -1; //获取对应java方法所属的类对象 jclass clazz=env-\u0026gt;FindClass(ClassName); //调用RegisterNatives注册方法 if(clazz){ env-\u0026gt;RegisterNatives(clazz,methods,sizeof(methods)/sizeof(methods[0])); return JNI_VERSION_1_6;//注意必须返回JNI版本 } else return -1; } 注意: JNI_OnLoad函数最后一定要返回JNI_VERSION才能成功执行,否则程序会崩溃\n使用registerNativeMethods方法的作用:\n改变丑陋的长方法名\n提高效率\n当Java类别透过VM呼叫到Native函数时，通常是依靠VM去动态寻找.so中的Native函数(因此它们才需要特定规则的命名格式)\n如果某方法需要连续呼叫很多次，则每次都要寻找一遍，使用RegisterNatives将本地函数向VM进行登记，可以让其更快找到函数\n运行时动态调整Native函数与Java函数之间的映射关系\n通过多次调用registerNativeMethods()方法，并传入不同的映射表参数即可实现\n3.2.4 逆向分析结果 恢复符号后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 __int64 __fastcall JNI_OnLoad(_JavaVM *vm) { __int64 clazz; // [rsp+10h] [rbp-30h] _JNIEnv *env; // [rsp+30h] [rbp-10h] BYREF unsigned __int64 v5; // [rsp+38h] [rbp-8h] v5 = __readfsqword(0x28u); env = 0LL; if ( (unsigned int)_JavaVM::GetEnv(vm, (void **)\u0026amp;env, 0x10006) )// vm \u0026amp;env JNI_VERSION { return (unsigned int)-1; } else { clazz = _JNIEnv::FindClass(env, className); if ( clazz ) { _JNIEnv::RegisterNatives(env, clazz, methods, 2LL); return 65542; } else { return (unsigned int)-1; } } } 其中methods数组如下:\n第一个是Java层函数名 第二个是方法签名 第三个是函数地址\n跟进查看函数\n1 2 3 4 __int64 __fastcall add(__int64 env, __int64 obj, int x, int y) { return (unsigned int)(y + x); } 3.3 JNI_OnLoad so中各种函数的执行顺序: init-\u0026gt;init_array-\u0026gt;JNI_OnLoad\nJNI_OnLoad格式如下\n1 2 3 4 5 6 7 8 JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env = nullptr; if (vm-\u0026gt;GetEnv((void **) \u0026amp;env, JNI_VERSION_1_6) != JNI_OK) { LOGD(\u0026#34;GetEnv failed\u0026#34;); return -1; } return JNI_VERSION_1_6;//共有1_1 1_2 1_4 1_6这4个版本 } 注意:\nso中可以不定义JNI_OnLoad,定义后在so被加载时自动执行 必须返回JNI版本号,如果so中没有提供JNI_OnLoad,VM默认该so使用最老的JNI 1.1版本 so被卸载时会调用JNI_UnLoad 1 JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved); 3.4 JavaVM JavaVM是JVM虚拟机在JNI中的表示，一个JVM中只有一个JavaVM实例，这个实例是线程共享的。\n通过JNIEnv可以获取一个Java虚拟机实例,vm用于存放返回的虚拟机指针实例\n1 jint GetJavaVM(JNIEnv *env, JavaVM **vm);//获取成功时返回0 定义如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //C语言版JavaVM定义 struct JNIInvokeInterface { void* reserved0; void* reserved1; void* reserved2; jint (*DestroyJavaVM)(JavaVM*); jint (*AttachCurrentThread)(JavaVM*, JNIEnv**, void*); jint (*DetachCurrentThread)(JavaVM*); jint (*GetEnv)(JavaVM*, void**, jint);//用于主线程中获取env jint (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, void*);//用于子线程中获取env }; //C++版本JavaVM是C版本的封装,逆向时看到的都是C版本 struct _JavaVM { const struct JNIInvokeInterface* functions; #if defined(__cplusplus) jint DestroyJavaVM() { return functions-\u0026gt;DestroyJavaVM(this); } jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) { return functions-\u0026gt;AttachCurrentThread(this, p_env, thr_args); } jint DetachCurrentThread() { return functions-\u0026gt;DetachCurrentThread(this); } jint GetEnv(void** env, jint version) { return functions-\u0026gt;GetEnv(this, env, version); }//c++传递this指针省略了C版的JavaVM*参数 jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args) { return functions-\u0026gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); } #endif /*__cplusplus*/ }; JavaVM的获取方式:\nJNI_OnLoad的第一个参数\nJNI_OnUnload的第一个参数\nenv-\u0026gt;GetJavaVM\n3.5 JNIEnv JNIEnv一般是是由虚拟机传入，且与线程相关的变量，也就是说线程A不能使用线程B的JNIEnv。\n作为一个结构体,它定义了JNI的相关操作函数,其定义如下:\nC版本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct JNINativeInterface { void* reserved0; void* reserved1; void* reserved2; void* reserved3; jint (*GetVersion)(JNIEnv *); jclass (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*, jsize); jclass (*FindClass)(JNIEnv*, const char*); jmethodID (*FromReflectedMethod)(JNIEnv*, jobject); jfieldID (*FromReflectedField)(JNIEnv*, jobject); /* spec doesn\u0026#39;t show jboolean parameter */ jobject (*ToReflectedMethod)(JNIEnv*, jclass, jmethodID, jboolean); jclass (*GetSuperclass)(JNIEnv*, jclass); jboolean (*IsAssignableFrom)(JNIEnv*, jclass, jclass); ...... } C++版本,对C版本的封装\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 struct _JNIEnv { /* do not rename this; it does not seem to be entirely opaque */ const struct JNINativeInterface* functions; #if defined(__cplusplus) jint GetVersion() { return functions-\u0026gt;GetVersion(this); } jclass DefineClass(const char *name, jobject loader, const jbyte* buf, jsize bufLen) { return functions-\u0026gt;DefineClass(this, name, loader, buf, bufLen); } jclass FindClass(const char* name) { return functions-\u0026gt;FindClass(this, name); } ...... #endif } #if defined(__cplusplus) typedef _JNIEnv JNIEnv; #else typedef const struct JNINativeInterface* JNIEnv; #endif _JNIEnv中定义了一个functions变量,指向JNINativeInterface该结构聚合了所有JNI函数指针\n所以可以通过env调用其中的函数\n1 2 env-\u0026gt;FindClass(\u0026#34;java/lang/String\u0026#34;);//c++写法 (*env)-\u0026gt;FindClass(env, \u0026#34;java/lang/String\u0026#34;) //c写法 JNIEnv的获取方式\n函数静态/动态注册时的第一个参数 主线程JavaVM-\u0026gt;GetEnv() 子线程JavaVM-\u0026gt;AttachCurrentThread() 3.6 NativeLog 相当于java层的log.d()函数\n使用宏定义进行封装,支持格式化字符串\nLOGD(\u0026hellip;)宏定义中,省略号表示是可变参数宏,可接收任意数量参数\n__VA_ARGS__则是可变参数占位符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;jni.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;android/log.h\u0026gt; #define TAG \u0026#34;glass\u0026#34; #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__); #define LOGI(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__); #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__); extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_nativetest_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { std::string hello = \u0026#34;Hello from C++\u0026#34;; LOGD(\u0026#34;LOGD test%d\u0026#34;,1);// LOGI(\u0026#34;LOGI test%d,%d\u0026#34;,1,2); LOGE(\u0026#34;LOGE test%d,%d,%d\u0026#34;,1,2,3); return env-\u0026gt;NewStringUTF(hello.c_str()); } 3.7 NDK多线程 在native层使用pthread_create()创建一个线程,函数声明如下\n1 int pthread_create(pthread_t* __pthread_ptr, pthread_attr_t const* __attr, void* (*__start_routine)(void*), void*); 参数1是指向pthread的指针，也是线程id\n参数2是线程属性\n参数3是线程执行的函数\n参数4是函数参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;jni.h\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;android/log.h\u0026gt; #define TAG \u0026#34;glass\u0026#34; #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__); #define LOGI(...) __android_log_print(ANDROID_LOG_INFO , TAG, __VA_ARGS__); #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, TAG, __VA_ARGS__); void myThread(){ LOGD(\u0026#34;Hello,myThread!\u0026#34;) pthread_exit(0);//退出线程 } extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_nativetest_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) { std::string hello = \u0026#34;Hello from C++\u0026#34;; pthread_t pthread; //线程id 线程属性 执行的函数 函数参数 //默认线程属性为joinable,主线程结束时子线程结束 pthread_create(\u0026amp;pthread, nullptr, reinterpret_cast\u0026lt;void *(*)(void *)\u0026gt;(myThread), nullptr); //使用join可以阻塞主线程直到子线程结束 pthread_join(pthread, nullptr); return env-\u0026gt;NewStringUTF(hello.c_str()); } 3.8 so的相关知识 so中,在导出表,导入表的函数一般可以通过frida的api直接获得函数地址\n不在导出表/导入表/符号表的函数需要手动计算地址\n3.8.1 多个cpp文件编译成一个so 创建cpp源文件,编写代码 修改CMakeLists.txt,添加源文件 默认源文件为native-lib.cpp,创建test.cpp文件并添加\n1 2 3 4 5 add_library(${CMAKE_PROJECT_NAME} SHARED # List C/C++ source files with relative paths to this CMakeLists.txt. native-lib.cpp test.cpp ) 3.8.2 编译多个so 通过cmakelists中使用add_library()添加新的so,注意需要target_link_libraries()进行链接\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 cmake_minimum_required(VERSION 3.22.1) project(\u0026#34;nativetest\u0026#34;) add_library(${CMAKE_PROJECT_NAME} SHARED # List C/C++ source files with relative paths to this CMakeLists.txt. native-lib.cpp ) add_library( test SHARED test.cpp ) target_link_libraries(${CMAKE_PROJECT_NAME} # List libraries link to the target library android log) target_link_libraries( test android log ) 3.8.3 动态获取so的路径 每次安装apk时,/data/app/\u0026lt;app_path\u0026gt;/\u0026lt;package_name\u0026gt;/lib/中\u0026lt;app_path\u0026gt;是随机的\n所以需要动态获取app的路径,以下代码获取app的so所在目录,具体的so需要使用目录+名称获取\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public String getPath(Context context){ PackageManager packageManager=context.getPackageManager();//获取包管理器 List\u0026lt;PackageInfo\u0026gt; packageInfoList=packageManager.getInstalledPackages(0);//获取已安装的包列表 if(packageInfoList==null||packageInfoList.size()==0) return null; //遍历列表,寻找目标app for(PackageInfo packageInfo:packageInfoList){ //用户app在/data/app/内,用于过滤系统app,包名用于确定目标app if(packageInfo.applicationInfo.nativeLibraryDir.startsWith(\u0026#34;/data/app/\u0026#34;) \u0026amp;\u0026amp;packageInfo.packageName.startsWith(\u0026#34;com.example.app\u0026#34;)){ return packageInfo.applicationInfo.nativeLibraryDir; } } return null; } 3.8.4 so之间的相互调用 导入dlfcn.h,使用dlopen函数 修改cmakelists的链接选项实现 四. JNI相关操作 4.1 创建java对象 4.1.1 NewObject创建对象 调用java层对象的构造函数,创建新的对象直接使用\n1 2 3 4 5 jclass clazz=env-\u0026gt;FindClass(\u0026#34;com/example/nativetest/MainActivity\u0026#34;);//获取java类 //参数为jclass,方法名,方法签名 \u0026lt;init\u0026gt;表示构造函数 jmethodID jmethodId=env-\u0026gt;GetMethodID(clazz,\u0026#34;\u0026lt;init\u0026gt;\u0026#34;,\u0026#34;()V\u0026#34;);//获取方法id jobject reflectObj=env-\u0026gt;NewObject(clazz,jmethodId);//通过类和方法id,调用构造方法创建对象 LOGD(\u0026#34;ReflectObject %p\u0026#34;,reflectObj);//使用对象 4.1.2 AllocObject创建对象 给对象分配内存初始化,但需要初始化对象再使用\n1 2 3 4 5 jclass clazz = env-\u0026gt;FindClass(\u0026#34;com/example/nativetest/MainActivity\u0026#34;); jmethodID methodID2 = env-\u0026gt;GetMethodID(clazz, \u0026#34;\u0026lt;init\u0026gt;\u0026#34;, \u0026#34;(Ljava/lang/String;I)V\u0026#34;); jobject ReflectDemoObj2 = env-\u0026gt;AllocObject(clazz); jstring jstr = env-\u0026gt;NewStringUTF(\u0026#34;from jni str\u0026#34;); env-\u0026gt;CallNonvirtualVoidMethod(ReflectDemoObj2, clazz, methodID2, jstr, 100); 4.2 访问java属性 4.2.1获取静态字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //1. 获取静态字段id jclass clazz = env-\u0026gt;FindClass(\u0026#34;com/example/nativetest/MainActivity\u0026#34;); //java类,字段名,字段类型 jfieldID privateStaticStringField = env-\u0026gt;GetStaticFieldID(clazz, \u0026#34;privateStaticStringField\u0026#34;, \u0026#34;Ljava/lang/String;\u0026#34;); // 根据字段类型选择不同GetStaticxxxField函数 此处java的String为引用型,使用Object // env-\u0026gt;GetStaticBooleanField(); // env-\u0026gt;GetStaticIntField(); // env-\u0026gt;GetStaticShortField(); // env-\u0026gt;GetStaticByteField(); // env-\u0026gt;GetStaticCharField(); // env-\u0026gt;GetStaticFloatField(); // env-\u0026gt;GetStaticDoubleField(); // env-\u0026gt;GetStaticLongField(); // env-\u0026gt;GetStaticObjectField(); //2. 获取字段并进行类型转换 jstring privateStaticString = static_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;GetStaticObjectField(clazz, privateStaticStringField)); //jstring在java虚拟机,需要通过env获取对应c字符串使用 const char* privatecstr = env-\u0026gt;GetStringUTFChars(privateStaticString, nullptr); LOGD(\u0026#34;privateStaticString: %s\u0026#34;, privatecstr); //使用完后需要释放,否则会导致出错 env-\u0026gt;ReleaseStringUTFChars(privateStaticString, privatecstr); 4.2.2 获取实例字段 获取实例字段前必须拥有实例对象,可以通过java层传递或者native层创建\n不能直接从native层获取java层实例\n1 2 3 4 5 6 7 8 jclass clazz = env-\u0026gt;FindClass(\u0026#34;com/example/nativetest/MainActivity\u0026#34;); //创建实例并通过实例获取字段 jmethodID methodID = env-\u0026gt;GetMethodID(clazz, \u0026#34;\u0026lt;init\u0026gt;\u0026#34;, \u0026#34;()V\u0026#34;); jobject instance = env-\u0026gt;NewObject(clazz, methodID); //GetxxxFiled方法 jstring publicString = static_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;GetObjectField(instance, publicStringField)); LOGD(\u0026#34;privateStaticString: %s\u0026#34;, privatecstr); env-\u0026gt;ReleaseStringUTFChars(privateStaticString, privatecstr); 4.2.3 设置字段 1 2 //对象,字段id,值 env-\u0026gt;SetObjectField(ReflectDemoObj, privateStringFieldID, env-\u0026gt;NewStringUTF(\u0026#34;glass\u0026#34;)); 1 2 3 4 5 6 7 8 9 10 11 jfieldID privateStringFieldID = env-\u0026gt;GetFieldID(clazz, \u0026#34;privateStringField\u0026#34;, \u0026#34;Ljava/lang/String;\u0026#34;); jstring privateString = static_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;GetObjectField(ReflectDemoObj, privateStringFieldID)); const char* privateCstr = env-\u0026gt;GetStringUTFChars(privateString, nullptr); LOGD(\u0026#34;privateStringField old: %s\u0026#34;, privateCstr); env-\u0026gt;ReleaseStringUTFChars(privateString, privateCstr); //使用SetObjectField修改字段并重新打印 env-\u0026gt;SetObjectField(ReflectDemoObj, privateStringFieldID, env-\u0026gt;NewStringUTF(\u0026#34;glass\u0026#34;)); privateString = static_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;GetObjectField(ReflectDemoObj, privateStringFieldID)); privateCstr = env-\u0026gt;GetStringUTFChars(privateString, nullptr); LOGD(\u0026#34;privateStringField new: %s\u0026#34;, privateCstr); env-\u0026gt;ReleaseStringUTFChars(privateString, privateCstr); 4.3 访问java数组 java层定义如下\n1 2 byte[] byteArray; public native String stringFromJNI(); native层代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_nativetest_MainActivity_stringFromJNI(JNIEnv* env,jobject ReflectDemoObj) { std::string hello = \u0026#34;Hello from C++\u0026#34;; //1. 获取java的byteArray对象 jclass clazz=env-\u0026gt;FindClass(\u0026#34;com/example/nativetest/MainActivity\u0026#34;); //获取Java对象的class和byte数组的字段ID jfieldID byteArrayID = env-\u0026gt;GetFieldID(clazz, \u0026#34;byteArray\u0026#34;, \u0026#34;[B\u0026#34;); //通过GetObjectField获取byte数组对象，并且通过GetArrayLength获取byte数组的长度。 jbyteArray byteArray = static_cast\u0026lt;jbyteArray\u0026gt;(env-\u0026gt;GetObjectField(ReflectDemoObj, byteArrayID)); int byteArrayLength = env-\u0026gt;GetArrayLength(byteArray); //2. 修改byteArray内容 //在C++中创建一个char类型的数组cByteArray，并且为其赋值。 char cByteArray[10]; for(int i = 0; i \u0026lt; 10; i++){ cByteArray[i] = static_cast\u0026lt;char\u0026gt;(100 - i); } //将cByteArray中的元素转换成jbyte类型的数组。 const jbyte *java_array = reinterpret_cast\u0026lt;const jbyte *\u0026gt;(cByteArray); //使用SetByteArrayRegion函数将java数组元素设置为cByteArray中的元素。 env-\u0026gt;SetByteArrayRegion(byteArray, 0, byteArrayLength, java_array); //3. 判断修改结果 //再次获取Java对象的byte数组，并且获取byte数组的元素。 byteArray = static_cast\u0026lt;jbyteArray\u0026gt;(env-\u0026gt;GetObjectField(ReflectDemoObj, byteArrayID)); byteArrayLength = env-\u0026gt;GetArrayLength(byteArray); //使用GetByteArrayElements函数将byte数组的元素转换到C++中的char数组CBytes中。 char* CBytes = reinterpret_cast\u0026lt;char *\u0026gt;(env-\u0026gt;GetByteArrayElements(byteArray, nullptr)); //遍历CBytes数组元素，输出数组内容。 for(int i = 0; i \u0026lt; byteArrayLength; i++) { LOGD(\u0026#34;CArray: %d\u0026#34;, CBytes[i]); } //释放CBytes数组元素，将其转移回byte数组中。 env-\u0026gt;ReleaseByteArrayElements(byteArray, (jbyte*)CBytes, 0); return env-\u0026gt;NewStringUTF(hello.c_str()); } 4.4 访问java方法 4.4.1 调用静态方法 获取类和方法id后直接调用即可\n1 2 3 4 jclass clazz=env-\u0026gt;FindClass(\u0026#34;com/example/nativetest/MainActivity\u0026#34;); jmethodID publicStaticFuncId=env-\u0026gt;GetStaticMethodID(clazz,\u0026#34;publicStaticFunc\u0026#34;,\u0026#34;()V\u0026#34;); env-\u0026gt;CallStaticVoidMethod(clazz, publicStaticFuncId); //\tCallStaticxxxMethod 4.4.2 调用实例方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //获取类和方法id jclass clazz=env-\u0026gt;FindClass(\u0026#34;com/example/nativetest/MainActivity\u0026#34;); jmethodID privateFuncID =env-\u0026gt;GetMethodID(clazz,\u0026#34;privateFunc\u0026#34;,\u0026#34;(Ljava/lang/String;I)Ljava/lang/String;\u0026#34;); //创建参数并调用 jstring str1 = env-\u0026gt;NewStringUTF(\u0026#34;this is from JNI\u0026#34;); jstring retval_jstring = static_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;CallObjectMethod(ReflectDemoObj, privateFuncID, str1, 1000)); //处理返回值 const char* retval_cstr = env-\u0026gt;GetStringUTFChars(retval_jstring, nullptr); LOGD(\u0026#34;privateStaticString: %s\u0026#34;, retval_cstr); env-\u0026gt;ReleaseStringUTFChars(retval_jstring, retval_cstr); // env-\u0026gt;CallBooleanMethod(); // env-\u0026gt;CallVoidMethod(); // env-\u0026gt;CallByteMethod(); // env-\u0026gt;CallShortMethod(); // env-\u0026gt;CallIntMethod(); // env-\u0026gt;CallCharMethod(); // env-\u0026gt;CallDoubleMethod(); // env-\u0026gt;CallLongMethod(); // env-\u0026gt;CallFloatMethod(); // env-\u0026gt;CallObjectMethod(); 4.4.3 CallVoidMethodA CallVoidMethod底层调用的是CallVoidMethodV\n区别在于CallVoidMethod会帮我们封装参数，而CallVoidMethodV需要我们自己封装参数(使用较少)\n1 2 3 4 5 6 7 8 9 10 11 void CallVoidMethod(jobject obj, jmethodID methodID, ...) { va_list args; va_start(args, methodID); functions-\u0026gt;CallVoidMethodV(this, obj, methodID, args); va_end(args); } void CallVoidMethodV(jobject obj, jmethodID methodID, va_list args) { functions-\u0026gt;CallVoidMethodV(this, obj, methodID, args); } void CallVoidMethodA(jobject obj, jmethodID methodID, const jvalue* args) { functions-\u0026gt;CallVoidMethodA(this, obj, methodID, args); } 对于CallVoidMethodA,它的参数是jvalue*,而jvalue是一个联合体,可以存储任意类型\n1 2 3 4 5 6 7 8 9 10 11 typedef union jvalue { jboolean z; jbyte b; jchar c; jshort s; jint i; jlong j; jfloat f; jdouble d; jobject l; } jvalue; 调用CallVoidMethodA并通过jvalue传递参数\n1 2 3 4 5 6 7 8 9 10 jmethodID privateFuncID = env-\u0026gt;GetMethodID(clazz,\u0026#34;privateFunc\u0026#34;,\u0026#34;(Ljava/lang/String;I)Ljava/lang/String;\u0026#34;); jstring str2 = env-\u0026gt;NewStringUTF(\u0026#34;this is from JNI2\u0026#34;); jvalue args[2]; args[0].l = str2; args[1].i = 1000; jstring retval = static_cast\u0026lt;jstring\u0026gt;(env-\u0026gt;CallObjectMethodA(ReflectDemoObj, privateFuncID, args)); const char* cpp_retval = env-\u0026gt;GetStringUTFChars(retval, nullptr); LOGD(\u0026#34;cpp_retval: %s\u0026#34;, cpp_retval); env-\u0026gt;ReleaseStringUTFChars(retval, cpp_retval); 4.5 访问java父类方法 通过env-\u0026gt;CallNonvirtualXXXMethod()可以调用父类方法\nactivity类的onCreate方法中必定调用父类的onCreate,否则程序崩溃\n1 2 3 4 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); } 可以修改为native方法\n1 2 @Override protected native void onCreate(Bundle savedInstanceState); 1 2 3 4 5 6 7 8 9 extern \u0026#34;C\u0026#34; JNIEXPORT void JNICALL Java_com_example_nativetest_MainActivity_onCreate( JNIEnv *env, jobject thiz,jobject saved_instance_state) { jclass AppCompatActivityClazz=env-\u0026gt;FindClass(\u0026#34;androidx/fragment/app/FragmentActivity\u0026#34;);//获取父类 jmethodID onCreateID=env-\u0026gt;GetMethodID(AppCompatActivityClazz,\u0026#34;onCreate\u0026#34;, \u0026#34;(Landroid/os/Bundle;)V\u0026#34;);//获取onCreate方法 env-\u0026gt;CallNonvirtualVoidMethod(thiz,AppCompatActivityClazz,onCreateID,saved_instance_state);//调用父类onCreate() } //CallNonvirtualXXXMethod根据不同返回值类型也有多个版本 4.6 内存管理 4.6.1 局部引用 局部引用只能在函数体内部使用,不能跨函数使用,即使定义为全局变量也不行\n大多数的jni函数返回结果都是局部引用\n因此一般不用env-\u0026gt;NewLocalRef()创建局部引用\n函数体内部的局部引用数量有限\n如果需要大量使用需要及时调用env-\u0026gt;DeleteLocalRef()删除局部引用\n当函数体内需要大量使用局部引用时, 可以使用 env-\u0026gt;DeleteLocalRef 删除局部引用\n其他函数\nenv-\u0026gt;EnsureLocalcapacity(num) 判断是否有num个局部引用可以使用,足够则返回0\n以下两个函数用于批量管理局部引用\nenv-\u0026gt;PushLocalFrame(num)\nenv-\u0026gt;PopLocalFrame(nullptr)\n1 2 3 4 5 6 7 8 9 10 11 env-\u0026gt;PushLocalFrame(100);//开辟100个局部引用空间 if(env-\u0026gt;EnsureLocalCapacity(100) == 0) { for(int i = 0; i \u0026lt; 3; i++){ jstring tempString = env-\u0026gt;NewStringUTF(\u0026#34;glass\u0026#34;); env-\u0026gt;SetObjectArrayElement(_jstringArray, i, tempString); //env-\u0026gt;DeleteLocalRef(tempString); sleep(1);//防止执行太快导致log失效 LOGD(\u0026#34;env-\u0026gt;EnsureLocalCapacity\u0026#34;); } } env-\u0026gt;PopLocalFrame(nullptr);//释放空间 4.6.2 全局引用 当需要跨函数使用引用时,可以定义全局变量并设置全局引用\n使用env-\u0026gt;NewGlobalRef 和 env-\u0026gt;DeleteGlobalRef 创建和删除全局引用\n1 2 3 jobject tempClassLoaderObj = env-\u0026gt;CallObjectMethod(MainActivityClazz, getClassLoaderID);//获取局部引用 ClassLoaderObj = env-\u0026gt;NewGlobalRef(tempClassLoaderObj);//设置为全局引用 env-\u0026gt;DeleteGlobalRef(ClassLoaderObj);//删除全局引用 4.6.3 弱全局引用 与全局引用基本相同,但可能被回收,关键函数如下:\nenv-\u0026gt;NewWeakGlobalRef\nenv-\u0026gt;DeleteWeakGlobalRef\n4.7 子线程中获取java类 子线程中可以直接获取系统类,但不能获取用户类\n1 2 3 4 jclass ClassLoaderClazz = env-\u0026gt;FindClass(\u0026#34;java/lang/ClassLoader\u0026#34;); LOGD(\u0026#34;myThread ClassLoaderClazz: %p\u0026#34;, ClassLoaderClazz); jclass StringClasszz=env-\u0026gt;FindClass(\u0026#34;java/lang/String\u0026#34;); LOGD(\u0026#34;myThread StringClasszz: %p\u0026#34;, StringClasszz); 主线程中获取类,设置为全局引用传递给子线程(常用)\n1 2 3 4 5 jclass MainActivityClazz = env-\u0026gt;FindClass(\u0026#34;com/example/javaandso/MainActivity\u0026#34;); globalClass= static_cast\u0026lt;jclass\u0026gt;(env-\u0026gt;NewGlobalRef(MainActivityClazz)); //子线程中调用 LOGD(\u0026#34;myThread globalClass: %p\u0026#34;, globalClass); 在主线程中获取ClassLoader，在子线程中去加载类(麻烦,不推荐)\n4.8 init和initarray so加载后,函数的执行顺序为: init\u0026gt;initarray\u0026gt;JNI_OnLoad\n一般在init和initarray中执行so和字符串解密,用于后续JNI_OnLoad进行绑定\n4.8.1 init 使用方法如下,名称必须为_init()\n1 2 3 extern \u0026#34;C\u0026#34; void _init(){ LOGD(\u0026#34;_init \u0026#34;); } _init在ida反编译后为.init_proc\n4.8.2 initarray 使用_attribute_ ((constructor(priority)))修饰符修饰的函数会在initarray中执行\n规则如下:\n优先执行指定了优先级的函数,再执行未指定优先级的函数 priority值越小的优先级越高,最好从100以后开始 未指定优先级的函数的执行顺序按照定义的先后顺序 故下列函数的执行顺序为 test3\u0026gt;test4\u0026gt;test1\u0026gt;test5\u0026gt;test2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 __attribute__ ((constructor(101))) void initArrayTest3(){ LOGD(\u0026#34;initArrayTest3\u0026#34;); } __attribute__ ((constructor)) void initArrayTest5(){ LOGD(\u0026#34;initArrayTest5\u0026#34;); } __attribute__ ((constructor(303))) void initArrayTest1(){ LOGD(\u0026#34;initArrayTest1 \u0026#34;); } __attribute__ ((constructor)) void initArrayTest2(){ LOGD(\u0026#34;initArrayTest2 \u0026#34;); } __attribute__ ((constructor(202))) void initArrayTest4(){ LOGD(\u0026#34;initArrayTest4\u0026#34;); } 另外可以使用visibility(\u0026ldquo;hidden\u0026rdquo;)属性去除函数符号\n1 2 3 __attribute__ ((constructor, visibility(\u0026#34;hidden\u0026#34;))) void initArrayTest6(){ LOGD(\u0026#34;initArrayTest6\u0026#34;); } initarray反编译后在.init_array段中\n4.9 Java代码Native化 以java层的MainActivity.onCreate()方法为例\njava代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package com.example.nativetest; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.widget.TextView; import com.example.nativetest.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { static { System.loadLibrary(\u0026#34;nativetest\u0026#34;); } private ActivityMainBinding binding; @Override protected native void onCreate(Bundle savedInstanceState); // @Override // protected void onCreate(Bundle savedInstanceState) { // super.onCreate(savedInstanceState); // binding = ActivityMainBinding.inflate(getLayoutInflater()); // setContentView(binding.getRoot()); // // // Example of a call to a native method // TextView tv = binding.sampleText; // tv.setText(\u0026#34;Hello,World\u0026#34;); // } } cpp代码-静态注册版\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;jni.h\u0026gt; #include \u0026lt;string\u0026gt; extern \u0026#34;C\u0026#34; JNIEXPORT void JNICALL Java_com_example_nativetest_MainActivity_onCreate( JNIEnv *env, jobject thiz,jobject saved_instance_state) { //1. 获取java的activity对象 jclass mainActivity=env-\u0026gt;GetObjectClass(thiz); //2. 调用父类方法 super.onCreate() jclass superActivity=env-\u0026gt;GetSuperclass(mainActivity);//直接获取父类 //jclass superActivity=env-\u0026gt;FindClass(\u0026#34;androidx/fragment/app/FragmentActivity\u0026#34;);//手动寻找父类 jmethodID onCreateID=env-\u0026gt;GetMethodID(superActivity, \u0026#34;onCreate\u0026#34;, \u0026#34;(Landroid/os/Bundle;)V\u0026#34;); env-\u0026gt;CallNonvirtualVoidMethod(thiz, superActivity, onCreateID, saved_instance_state);//调用父类方法 //调用方法时,需要传入调用的类实例,方法所属根类,方法id,参数 //3. 获取binding并调用inflate方法 ActivityMainBinding.inflate(getLayoutInflater()) //getLayoutInflater() jclass Activity=env-\u0026gt;FindClass(\u0026#34;android/app/Activity\u0026#34;); jmethodID getLayoutInflater=env-\u0026gt;GetMethodID(Activity,\u0026#34;getLayoutInflater\u0026#34;, \u0026#34;()Landroid/view/LayoutInflater;\u0026#34;); jobject layoutInflater=env-\u0026gt;CallObjectMethod(thiz,getLayoutInflater); //bingding=ActivityMainBinding.inflate(getLayoutInflater()) jclass ActivityMainBinding=env-\u0026gt;FindClass(\u0026#34;com/example/nativetest/databinding/ActivityMainBinding\u0026#34;);//此处ide找不到,因为binding类此时不存在,在编译时生成 jmethodID inflate=env-\u0026gt;GetStaticMethodID(ActivityMainBinding,\u0026#34;inflate\u0026#34;,\u0026#34;(Landroid/view/LayoutInflater;)Lcom/example/nativetest/databinding/ActivityMainBinding;\u0026#34;); jobject binding=env-\u0026gt;CallStaticObjectMethod(ActivityMainBinding,inflate,layoutInflater); //4. 使用setContentView绑定布局 jclass AppCompatActivity=env-\u0026gt;FindClass(\u0026#34;androidx/appcompat/app/AppCompatActivity\u0026#34;); jmethodID setContentView=env-\u0026gt;GetMethodID(AppCompatActivity,\u0026#34;setContentView\u0026#34;, \u0026#34;(Landroid/view/View;)V\u0026#34;); //binding.getRoot() jmethodID getRoot=env-\u0026gt;GetMethodID(ActivityMainBinding,\u0026#34;getRoot\u0026#34;,\u0026#34;()Landroidx/constraintlayout/widget/ConstraintLayout;\u0026#34;); jobject layout=env-\u0026gt;CallObjectMethod(binding,getRoot); //setContentView(binding.getRoot()) env-\u0026gt;CallVoidMethod(thiz,setContentView,layout); //5. 创建TextView并设置内容 TextView.setText() jclass TextView=env-\u0026gt;FindClass(\u0026#34;android/widget/TextView\u0026#34;); jfieldID sampleText=env-\u0026gt;GetFieldID(ActivityMainBinding,\u0026#34;sampleText\u0026#34;,\u0026#34;Landroid/widget/TextView;\u0026#34;); jobject textView=env-\u0026gt;GetObjectField(binding,sampleText); jmethodID setText=env-\u0026gt;GetMethodID(TextView, \u0026#34;setText\u0026#34;, \u0026#34;(Ljava/lang/CharSequence;)V\u0026#34;); env-\u0026gt;CallVoidMethod(textView,setText,env-\u0026gt;NewStringUTF(\u0026#34;Hello,Native!\u0026#34;)); } cpp代码-动态注册版\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;jni.h\u0026gt; #include \u0026lt;string\u0026gt; void func(JNIEnv *env, jobject thiz,jobject saved_instance_state){ ...... //内容同上Java_com_example_nativetest_MainActivity_onCreate ...... } JNINativeMethod methods[]={ {\u0026#34;onCreate\u0026#34;, \u0026#34;(Landroid/os/Bundle;)V\u0026#34;,(void*)func} }; jint JNI_OnLoad(JavaVM* vm,void* reserved){ const char* ClassName=\u0026#34;com/example/nativetest/MainActivity\u0026#34;; //1. 获取JNIEnv对象 JNIEnv* env=NULL; if(vm-\u0026gt;GetEnv((void**)\u0026amp;env,JNI_VERSION_1_6)!=JNI_OK) return -1; //2. 获取对应java方法所属的类对象,并调用RegisterNatives注册方法 jclass clazz=env-\u0026gt;FindClass(ClassName); if(clazz){ env-\u0026gt;RegisterNatives(clazz,methods,sizeof(methods)/sizeof(methods[0])); return JNI_VERSION_1_6;//注意必须返回JNI版本 } else return -1; } 反汇编效果如下\nJNI_OnLoad\nfunc\n五. References Android官方NDK指南 Android开发学习笔记——NDK开发 Android JNI编程—JNI基础 [原创]《安卓逆向这档事》十二、大佬帮我分析一下 Android JNI学习(三)——Java与Native相互调用 ","date":"2024-09-15T02:15:28+08:00","permalink":"https://example.com/p/ndkstudy/","title":"NDKStudy"}]